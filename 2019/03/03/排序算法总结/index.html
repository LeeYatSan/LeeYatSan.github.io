<!DOCTYPE html>
<html  lang="zh">
<head>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8" />

<meta name="generator" content="Hexo 3.8.0" />

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<title>10种经典排序算法总结 - LEE YAT-SAN&#39;s ZONE</title>


    <meta name="description" content="最近复习数据结构与算法，先从基本的排序算法开始。在此，对10种经典的排序算法进行总结，加深自己对相关算法的理解与掌握，其中也参考了维基百科以及部分网上优秀博客的总结。">
<meta name="keywords" content="Algorithm,Java,Sort">
<meta property="og:type" content="article">
<meta property="og:title" content="10种经典排序算法总结">
<meta property="og:url" content="https://leeyatsan.cn/2019/03/03/排序算法总结/index.html">
<meta property="og:site_name" content="LEE YAT-SAN&#39;s ZONE">
<meta property="og:description" content="最近复习数据结构与算法，先从基本的排序算法开始。在此，对10种经典的排序算法进行总结，加深自己对相关算法的理解与掌握，其中也参考了维基百科以及部分网上优秀博客的总结。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://leeyatsan.cn/images/og_image.png">
<meta property="og:updated_time" content="2019-12-12T03:36:05.440Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="10种经典排序算法总结">
<meta name="twitter:description" content="最近复习数据结构与算法，先从基本的排序算法开始。在此，对10种经典的排序算法进行总结，加深自己对相关算法的理解与掌握，其中也参考了维基百科以及部分网上优秀博客的总结。">
<meta name="twitter:image" content="https://leeyatsan.cn/images/og_image.png">







<link rel="icon" href="/images/favicon">


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.7.2/css/bulma.css">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.4.1/css/all.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css">


    
    
<style>body>.footer,body>.navbar,body>.section{opacity:0}</style>

    
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css">

    
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css">

    
    
    
    
<link rel="stylesheet" href="/css/back-to-top.css">

    
    
    
    
    
    
    
    <link rel="stylesheet" href="/css/progressbar.css">
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
    
    
    


<link rel="stylesheet" href="/css/style.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>
<body class="is-3-column">
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><nav class="navbar navbar-main">
    <div class="container">
        <div class="navbar-brand is-flex-center">
            <a class="navbar-item navbar-logo" href="/">
            
                <img src="/images/logo.svg" alt="10种经典排序算法总结" height="28">
            
            </a>
        </div>
        <div class="navbar-menu">
            
            <div class="navbar-start">
                
                <a class="navbar-item"
                href="/">首页</a>
                
                <a class="navbar-item"
                href="/archives">归档</a>
                
                <a class="navbar-item"
                href="/categories">目录</a>
                
                <a class="navbar-item"
                href="/tags">标签</a>
                
                <a class="navbar-item"
                href="/about">关于</a>
                
            </div>
            
            <div class="navbar-end">
                
                    
                    <a class="navbar-item" target="_blank" title="Download on GitHub" href="https://github.com/LeeYatSan">
                        
                        <i class="fab fa-github"></i>
                        
                    </a>
                    
                
                
                <a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;">
                    <i class="fas fa-list-ul"></i>
                </a>
                
                
                <a class="navbar-item search" title="Search" href="javascript:;">
                    <i class="fas fa-search"></i>
                </a>
                
            </div>
        </div>
    </div>
</nav>
    
    <section class="section">
        <div class="container">
            <div class="columns">
                <div class="column is-8-tablet is-8-desktop is-9-widescreen has-order-2 column-main">
<div class="card">
    <div class="card-content article ">
    <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
        
    <i class="fas fa-angle-double-right"></i>10种经典排序算法总结
    
    </h1>
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
            <time class="level-item has-text-grey" datetime="2019-03-03T08:16:44.763Z"><i class="far fa-calendar-alt">&nbsp;</i>2019-03-03</time>
            
            <time class="level-item has-text-grey is-hidden-mobile" datetime="2019-12-12T03:36:05.440Z"><i class="far fa-calendar-check">&nbsp;</i>2019-12-12</time>
            
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/Algorithm/">Algorithm</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    40 minutes read (About 5974 words)
                </span>
                
                
            </div>
        </div>
        
        <div class="content">
            <p>最近复习数据结构与算法，先从基本的排序算法开始。在此，对10种经典的排序算法进行总结，加深自己对相关算法的理解与掌握，其中也参考了维基百科以及部分网上优秀博客的总结。</p>
<p><img src="https://embedwistia-a.akamaihd.net/deliveries/70d6f4e10e2badb5ef394f00c17ad2bc1c14f6e7.jpg" alt="sorted-algorithms"> </p>
<a id="more"></a>
<blockquote>
<p>本文所有代码参见：<strong><a href="https://github.com/LeeYatSan/Algorithms/tree/master/Sorting%20Algorithms" target="_blank" rel="noopener">Github</a></strong></p>
</blockquote>
<h1 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h1><p>排序算法是数据结构中的重中之重，也是面试中基本必考的项目。排序的是将一组“无序”的记录序列调整为“有序”的记录序列。<br>所有排序算法基本上都遵循两大原则：</p>
<ul>
<li>输出结果为递增序列（递增是针对所需的排序顺序而言）  </li>
<li>输出结果是原输入的一种排列、或是重组  </li>
</ul>
<p>在计算机科学中，排序算法有很多，本文在此仅仅总结其中的10种经典的排序算法。</p>
<h1 id="算法性能评价"><a href="#算法性能评价" class="headerlink" title="算法性能评价"></a>算法性能评价</h1><p>基本上，大部分的算法都需要通过计算其时间复杂度和空间复杂度来对其性能进行评价，对于排序算法亦如此。而对于排序算法来说，还需要从其排序所产生的结构的稳定性对其进行评价，分为稳定的和不稳定的。</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>指对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。</p>
<blockquote>
<p><strong>非线性时间比较类排序</strong>：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此称为非线性时间比较类排序。<br><strong>线性时间非比较类排序</strong>：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此称为线性时间非比较类排序。   </p>
</blockquote>
<p><img src="https://blog.tangdongsheng.com/upload/image/article/2018/12/18/1545141561304815.png" alt="按时间复杂度划分"></p>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。  </p>
<h2 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h2><p>指是否让原本有相等键值的纪录维持相对次序。</p>
<blockquote>
<p><strong>稳定</strong>：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。<br><strong>不稳定</strong>：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。  </p>
</blockquote>
<h2 id="10种经典算法的性能总结："><a href="#10种经典算法的性能总结：" class="headerlink" title="10种经典算法的性能总结："></a>10种经典算法的性能总结：</h2><p><img src="https://github.com/LeeYatSan/Algorithms/blob/master/theme%20images/Sorting%20Algorithm%20Performance.png?raw=true" alt="sorted-algorithms-performances"> </p>
<h1 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h1><p>接下来将详细描述本人对各算法的实现原理的理解。所有实现将统一采用Java语言。  </p>
<h2 id="冒泡排序-Bubble-Sort"><a href="#冒泡排序-Bubble-Sort" class="headerlink" title="冒泡排序 Bubble Sort"></a>冒泡排序 Bubble Sort</h2><p>如果你是新入坑的程序猿，会许你可能会疑惑：为什么它要叫冒泡排序？根据生活常识我们可知，在水中，较大的气泡将会逐渐向上浮，直到浮出水面。而冒泡排序的实现过程则与这个气泡过程极其相似，当然，我们所说的气泡大小是相对的，并不是说比较完后得出的序列中元素越大越靠前，结果序列是升序降序其实问题不大。  </p>
<p>冒泡排序是一种简单的排序方式。它重复遍历待排序的序列，依次比较相邻的两个元素的大小，如果他们的大小不符合要求，则进行交换顺序。此过程一直重复，知道所有元素排列有序化。</p>
<h3 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h3><p>在这里，我们以将序列升序化，即较大的元素放在后面。  </p>
<blockquote>
<p><strong>STEP1:</strong> 在每一轮中，比较相邻的两个元素，如果前面的元素比后面的元素大，则交换它们的顺序。这样做的结果是<strong>本轮最大的元素会”浮”到序列末尾</strong>，这样意味着本轮成功有序化至少一个元素<br><strong>STEP2:</strong> 将待有序化的元素个数减<br><strong>STEP3:</strong> 对除了最后一个的所有元素重复STEP1和STEP2，直至所有排序完成   </p>
</blockquote>
<h3 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h3><p><img src="http://louiszhai.github.io/docImages/sort05.gif" alt="bubble sort">  </p>
<h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">coreSort</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; ++i)</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; arr.length - i - <span class="hljs-number">1</span>; ++j)</span><br><span class="line">                <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>])</span><br><span class="line">                    swap(j, j + <span class="hljs-number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">```  </span><br><span class="line">  </span><br><span class="line">&gt; **[查看完整代码](https:<span class="hljs-comment">//github.com/LeeYatSan/Algorithms/tree/master/Sorting%20Algorithms)**  </span></span><br><span class="line">  </span><br><span class="line">## 选择排序 Selection Sort    </span><br><span class="line">选择排序是一种非常简单、直观的排序方式。它将整个序列分为两部分，有序部分和无序部分。以将无序序列升序化为例，整个序列前面部分为有序部分（初始长度为<span class="hljs-number">0</span>），后面部分为无序部分（完成有序化后长度为<span class="hljs-number">0</span>）。为什么要叫选择排序呢？因为它每次遍历整个无序序列，选择出数值最小的元素，将其提到有序部分的最末尾。不断重复次过程，直到无序部分长度减为<span class="hljs-number">0</span>。  </span><br><span class="line">  </span><br><span class="line">### 工作过程    </span><br><span class="line">n个记录的直接选择排序可经过n-<span class="hljs-number">1</span>趟直接选择排序得到有序结果。具体算法描述如下：</span><br><span class="line">  </span><br><span class="line">&gt; **初始:** 初始状态：序列前面部分为有序区，此时为空；序列后面部分为无序区，当前范围为R[<span class="hljs-number">1</span>..n]</span><br><span class="line">&gt; **STEP1:** 第i趟排序(i=<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>…n-<span class="hljs-number">1</span>)开始时，当前有序区和无序区分别为R[<span class="hljs-number">1</span>..i-<span class="hljs-number">1</span>]和R(i..n）。该趟排序从当前无序区中选出关键字最小的记录R[k]，将它与无序区的*第<span class="hljs-number">1</span>个记录R*交换，使R[<span class="hljs-number">1</span>..i]和R[i+<span class="hljs-number">1</span>..n)分别变为记录个数增加<span class="hljs-number">1</span>个的新有序区和记录个数减少<span class="hljs-number">1</span>个的新无序区</span><br><span class="line">&gt; **STEP2:** 重复STEP1，直至无序区长度为<span class="hljs-number">0</span>，完成排序    </span><br><span class="line">  </span><br><span class="line">### 动画演示  </span><br><span class="line">![selection sort](http:<span class="hljs-comment">//louiszhai.github.io/docImages/sort06.gif)  </span></span><br><span class="line">  </span><br><span class="line">### Java代码   </span><br><span class="line">  </span><br><span class="line">```java  </span><br><span class="line">  </span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">coreSort</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> unsorted_min = <span class="hljs-number">0</span>, sorted_last; <span class="hljs-comment">//the former is the index of the min value of unsorted part, and the later is the index of the last element in the sorted part</span></span><br><span class="line">        <span class="hljs-keyword">for</span>(sorted_last = <span class="hljs-number">0</span>; sorted_last &lt; arr.length-<span class="hljs-number">1</span>; ++sorted_last)&#123;</span><br><span class="line">            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = sorted_last+<span class="hljs-number">1</span>; j &lt; arr.length; ++j)<span class="hljs-comment">//find the min value within the unsorted part</span></span><br><span class="line">                <span class="hljs-keyword">if</span>(arr[j] &lt; arr[unsorted_min])</span><br><span class="line">                    unsorted_min = j;</span><br><span class="line">            swap(sorted_last, unsorted_min);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">```  </span><br><span class="line">  </span><br><span class="line">&gt; **[查看完整代码](https:<span class="hljs-comment">//github.com/LeeYatSan/Algorithms/tree/master/Sorting%20Algorithms)**  </span></span><br><span class="line">  </span><br><span class="line">## 直接插入排序  Direct Insertion Sort  </span><br><span class="line">直接插入排序是插入排序的一种方式，也是一种简单直观的排序方式。它也将序列分为两个部分，前面部分为有序化区，后面部分为未排序区。每次取出未排序区中的第一个元素，从一排序区中的最后一个元素开始向前遍历，直到找到一个比当前元素小的元素，将当前元素插入到所寻找到的元素的下一个位置，而该位置后面直到未排序区的第一个元素（即进行插入的元素）向前顺移一位。  </span><br><span class="line">  </span><br><span class="line">### 工作过程    </span><br><span class="line">n个记录的直接选择排序可经过n-<span class="hljs-number">1</span>趟直接选择排序得到有序结果。具体算法描述如下：  </span><br><span class="line">  </span><br><span class="line">&gt; **初始:** 序列前面部分为有序区，默认首元素为有序区初始元素；序列后部分为无序区，当前范围为R[<span class="hljs-number">2</span>..n]  </span><br><span class="line">&gt; **STEP1:** 取出下一个元素，在已经排序的元素序列中从后向前扫描  </span><br><span class="line">&gt; **STEP2:** 如果该元素（已排序）大于新元素，将该元素移到下一位置   </span><br><span class="line">&gt; **STEP3:** 重复STEP2，直到找到已排序的元素小于或者等于新元素的位置  </span><br><span class="line">&gt; **STEP4:** 将新元素插入到该位置后  </span><br><span class="line">&gt; **STEP5:** 重复STEP1-STEP4，直到完成排序  </span><br><span class="line">  </span><br><span class="line">### 动画演示   </span><br><span class="line">![direct insertion sort](http:<span class="hljs-comment">//louiszhai.github.io/docImages/sort07.gif)  </span></span><br><span class="line">  </span><br><span class="line">### Java代码   </span><br><span class="line">  </span><br><span class="line">```java  </span><br><span class="line">  </span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">coreSort</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> unsorted_first = <span class="hljs-number">1</span>;<span class="hljs-comment">//the index of the first element of the unsorted part</span></span><br><span class="line">        <span class="hljs-keyword">for</span>(; unsorted_first &lt; arr.length; ++unsorted_first)&#123;</span><br><span class="line">            <span class="hljs-keyword">int</span> curr = arr[unsorted_first];<span class="hljs-comment">//keep the value of the first element in the unsorted part</span></span><br><span class="line">            <span class="hljs-keyword">int</span> i = unsorted_first - <span class="hljs-number">1</span>;</span><br><span class="line">            <span class="hljs-keyword">for</span>(; i &gt; -<span class="hljs-number">1</span> &amp;&amp; arr[i] &gt; curr; --i)&#123;<span class="hljs-comment">//move ahead to the first element from the last element of the sorted part, and exchange the value if current value is larger than the current value of the first element in the unsorted part. This process will loop until find a value is smaller than the current first element of the unsorted part.</span></span><br><span class="line">                arr[i+<span class="hljs-number">1</span>] = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">            arr[i+<span class="hljs-number">1</span>] = curr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">```  </span><br><span class="line">  </span><br><span class="line">&gt; **[查看完整代码](https:<span class="hljs-comment">//github.com/LeeYatSan/Algorithms/tree/master/Sorting%20Algorithms)**  </span></span><br><span class="line"></span><br><span class="line">## 希尔排序 Shell Sort  </span><br><span class="line">希尔排序是Donald Shell在<span class="hljs-number">1959</span>年公布的一种对直接插入排序算法进行改进的一种插入排序算法，它突破了直接插入排序算法时间复杂度O(n^<span class="hljs-number">2</span>)的限制。传统的直接插入排序每次只能移动一格，最坏情况有n^<span class="hljs-number">2</span>次，而希尔排序则可以大跨步的移动，加快了排序效率。  </span><br><span class="line">一个更好理解的希尔排序实现：将数组列在一个表中并对列排序（用插入排序）。重复这过程，不过每次用更长的列来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身仅仅对原数组进行排序（通过增加索引的步长，例如是用i += step_size而不是i++） </span><br><span class="line">  </span><br><span class="line">### 增量序列  </span><br><span class="line">由上述描述可以得知，希尔排序依赖于一个增量序列，而这个增量序列也成为希尔增量。下面列举常用的希尔增量，其中已知的最好步长序列是由Sedgewick提出的。  </span><br><span class="line">  </span><br><span class="line">&gt; **希尔增量：** ht = N / <span class="hljs-number">2</span>, h[k] = h[k+<span class="hljs-number">1</span>] / <span class="hljs-number">2</span>，即&#123;N/<span class="hljs-number">2</span>, (N / <span class="hljs-number">2</span>)/<span class="hljs-number">2</span>, ..., <span class="hljs-number">1</span>&#125;  </span><br><span class="line">&gt; **Hibbard增量：**&#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, ..., <span class="hljs-number">2</span>^k-<span class="hljs-number">1</span>&#125;  </span><br><span class="line">&gt; **Sedgewick增量：**&#123;<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">19</span>, <span class="hljs-number">41</span>, <span class="hljs-number">109</span>...&#125;，由<span class="hljs-number">9</span>\*<span class="hljs-number">4</span>^i - <span class="hljs-number">9</span>\*<span class="hljs-number">2</span>^i + <span class="hljs-number">1</span>或者是<span class="hljs-number">4</span>^i - <span class="hljs-number">3</span>*<span class="hljs-number">2</span>^i + <span class="hljs-number">1</span>得出  </span><br><span class="line">  </span><br><span class="line">### 工作过程  </span><br><span class="line">&gt; **初始:** 确定一个单调递减的序列，t1，t2，…，tk，其中ti&gt;tj，tk=<span class="hljs-number">1</span>。其中包含k个元素，即意味着要进行k轮排序。该序列中的每个元素代表这该轮排序的跨度（即两个待比较的元素之间相隔多少个元素）  </span><br><span class="line">&gt; **STEP1:** 第i趟排序中，根据初始确定的序列，每隔i个元素取为一个子序列，对该子序列进行直接插入排序     </span><br><span class="line">&gt; **STEP2:** 重复STEP1，直到完成k趟排序  </span><br><span class="line">  </span><br><span class="line">### 动画演示  </span><br><span class="line">![shell sort](https:<span class="hljs-comment">//img2018.cnblogs.com/blog/751560/201812/751560-20181204164005988-481309690.gif)  </span></span><br><span class="line">  </span><br><span class="line">### Java代码  </span><br><span class="line">  </span><br><span class="line">```java</span><br><span class="line">  </span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">coreSort</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> gap = arr.length/<span class="hljs-number">2</span>;<span class="hljs-comment">//To simplify, we used Shell Increment</span></span><br><span class="line">        <span class="hljs-keyword">while</span>(gap &gt; <span class="hljs-number">0</span>)&#123;</span><br><span class="line">            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> unsorted_first = gap; unsorted_first &lt; arr.length; ++unsorted_first)&#123;</span><br><span class="line">                <span class="hljs-keyword">int</span> curr = arr[unsorted_first];</span><br><span class="line">                <span class="hljs-keyword">int</span> i = unsorted_first-gap;</span><br><span class="line">                <span class="hljs-keyword">for</span>(; i &gt; -<span class="hljs-number">1</span> &amp;&amp; arr[i] &gt; curr; i-=gap)&#123;</span><br><span class="line">                    arr[i+gap] = arr[i];</span><br><span class="line">                &#125;</span><br><span class="line">                    arr[i+gap]=curr;</span><br><span class="line">            &#125;</span><br><span class="line">            gap/=<span class="hljs-number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">```  </span><br><span class="line">  </span><br><span class="line">&gt; **[查看完整代码](https:<span class="hljs-comment">//github.com/LeeYatSan/Algorithms/tree/master/Sorting%20Algorithms)**  </span></span><br><span class="line"></span><br><span class="line">## 归并排序 Merge Sort  </span><br><span class="line">归并采用分而治之，并行操作以及递归的思想。将一个长为n的序列分为两个n/<span class="hljs-number">2</span>的子序列，然后对每个子序列进行归并排序，直至最终的子序列长度不超过<span class="hljs-number">2</span>为止。对于每个子序列，最终实现排序，然后再到子序列之间的排序，最终实现整个序列的排序。</span><br><span class="line">  </span><br><span class="line">### 工作过程  </span><br><span class="line">&gt; **STEP1:** 每一趟，若当前序列长度大于<span class="hljs-number">2</span>，则先将当前序列平分为两部分；若无法再分，则进入STEP4</span><br><span class="line">&gt; **STEP2:** 对平分后产生的两个子序列分别调用归并排序</span><br><span class="line">&gt; **STEP3:** 重复执行STEP1和STEP2 </span><br><span class="line">&gt; **STEP4:** 对每个子序列进行排序</span><br><span class="line">&gt; **STEP5:** 同级每相邻两子序列分别完成排序后，两子序列之间再次进行排序，形成更大一级子序列</span><br><span class="line">&gt; **STEP6:** 重复STEP6直至完成排序</span><br><span class="line">  </span><br><span class="line">### 动画演示  </span><br><span class="line">![merge sort](http:<span class="hljs-comment">//louiszhai.github.io/docImages/sort08.gif)  </span></span><br><span class="line">  </span><br><span class="line">### Java代码  </span><br><span class="line">#### 数组形式  </span><br><span class="line">   </span><br><span class="line">```java  </span><br><span class="line">  </span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MergeSort</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sort</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    MergeSort(<span class="hljs-keyword">int</span>[] arr)&#123;</span><br><span class="line">        <span class="hljs-keyword">super</span>(arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">coreSort</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">        mergeSort(<span class="hljs-number">0</span>, arr.length-<span class="hljs-number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> mid = (start+end)/<span class="hljs-number">2</span>;</span><br><span class="line">        <span class="hljs-keyword">int</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[end-start+<span class="hljs-number">1</span>];</span><br><span class="line">        <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">int</span> left = start, right = mid+<span class="hljs-number">1</span>;</span><br><span class="line">        <span class="hljs-keyword">while</span>(left &lt;= mid &amp;&amp; right &lt;= end)</span><br><span class="line">            temp[index++] = arr[left] &lt;= arr[right] ? arr[left++] : arr[right++];</span><br><span class="line">        <span class="hljs-keyword">while</span>(left &lt;= mid)</span><br><span class="line">            temp[index++] = arr[left++];</span><br><span class="line">        <span class="hljs-keyword">while</span>(right &lt;= end)</span><br><span class="line">            temp[index++] = arr[right++];</span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; temp.length; ++k)</span><br><span class="line">            arr[start+k] = temp[k];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span>(end - start &lt; <span class="hljs-number">1</span>)</span><br><span class="line">            <span class="hljs-keyword">return</span>;</span><br><span class="line">        <span class="hljs-keyword">int</span> mid = (start+end)/<span class="hljs-number">2</span>;</span><br><span class="line">        mergeSort(start, mid);</span><br><span class="line">        mergeSort(mid+<span class="hljs-number">1</span>, end);</span><br><span class="line">        merge(start, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br><span class="line">    </span><br><span class="line">```   </span><br><span class="line">  </span><br><span class="line">&gt; **[查看完整代码](https:<span class="hljs-comment">//github.com/LeeYatSan/Algorithms/tree/master/Sorting%20Algorithms)**    </span></span><br><span class="line">  </span><br><span class="line">#### 链表形式  </span><br><span class="line">链表形式关键在于利用快慢指针（快指针的速度是慢指针的<span class="hljs-number">1</span>倍）来确定中间节点   </span><br><span class="line">   </span><br><span class="line">```java  </span><br><span class="line">  </span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">sortList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>)</span><br><span class="line">            <span class="hljs-keyword">return</span> head;</span><br><span class="line">        <span class="hljs-keyword">return</span> mergeSort(head);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> ListNode <span class="hljs-title">mergeSort</span><span class="hljs-params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>)</span><br><span class="line">            <span class="hljs-keyword">return</span> head;</span><br><span class="line">        ListNode fast = head, slow = head;</span><br><span class="line">        <span class="hljs-keyword">while</span>(fast.next != <span class="hljs-keyword">null</span> &amp;&amp; fast.next.next != <span class="hljs-keyword">null</span>)&#123;<span class="hljs-comment">//use fast &amp; slow pointer to find the middle node</span></span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode mid = slow.next;</span><br><span class="line">        slow.next = <span class="hljs-keyword">null</span>;<span class="hljs-comment">//cut the linked list into two sub linked list</span></span><br><span class="line">        <span class="hljs-keyword">return</span> merge(mergeSort(head), mergeSort(mid));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> ListNode <span class="hljs-title">merge</span><span class="hljs-params">(ListNode left, ListNode right)</span></span>&#123;</span><br><span class="line">        ListNode head = left.val &lt; right.val ? left : right;</span><br><span class="line">        ListNode currLeft = head == left ? left.next : left;</span><br><span class="line">        ListNode currRight = head == right ? right.next : right;</span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        <span class="hljs-keyword">while</span>(currLeft != <span class="hljs-keyword">null</span> &amp;&amp; currRight != <span class="hljs-keyword">null</span>)&#123;</span><br><span class="line">            curr.next = currLeft.val &lt; currRight.val ? currLeft : currRight;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">            <span class="hljs-keyword">if</span>(curr == currLeft)</span><br><span class="line">                currLeft = currLeft.next;</span><br><span class="line">            <span class="hljs-keyword">else</span></span><br><span class="line">                currRight = currRight.next;</span><br><span class="line">        &#125;</span><br><span class="line">        curr.next = currLeft == <span class="hljs-keyword">null</span> ? currRight : currLeft;</span><br><span class="line">        <span class="hljs-keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">    </span><br><span class="line">&gt; **[查看完整代码](https:<span class="hljs-comment">//github.com/LeeYatSan/Algorithms/tree/master/Sorting%20Algorithms)**   </span></span><br><span class="line">  </span><br><span class="line">## 快速排序 Quick Sort  </span><br><span class="line">快速排序是通过把一个序列分隔为两个字串，且其中一个字串的所有元素都比另一个字串小。然后对每个字串分别进行快速排序，实现递归，最终实现排序。</span><br><span class="line">  </span><br><span class="line">### 工作过程  </span><br><span class="line">&gt; **STEP1:** 从当前字串中选取一个元素作为基值</span><br><span class="line">&gt; **STEP2:** 当前字符串剩余所有元素与基值比较，比基值小或等于的元素放入左子串，比基值大的元素放入右子串</span><br><span class="line">&gt; **STEP3:** 对每个子串重复STEP1和STEP2，直至所有子串不可再分（通常长度为<span class="hljs-number">1</span>），完成排序  </span><br><span class="line">  </span><br><span class="line">### 动画演示  </span><br><span class="line">![quick sort](http:<span class="hljs-comment">//louiszhai.github.io/docImages/sort09.gif)  </span></span><br><span class="line">  </span><br><span class="line">### Java代码 </span><br><span class="line">   </span><br><span class="line">```java  </span><br><span class="line">  </span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QuickSort</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sort</span> </span>&#123;</span><br><span class="line">    QuickSort(<span class="hljs-keyword">int</span>[] arr)&#123;</span><br><span class="line">        <span class="hljs-keyword">super</span>(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">coreSort</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">        quickSort(<span class="hljs-number">0</span>, arr.length-<span class="hljs-number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span>(start &gt;= end)</span><br><span class="line">            <span class="hljs-keyword">return</span>;</span><br><span class="line">        <span class="hljs-keyword">int</span> privot_index = partition(start, end);</span><br><span class="line">        quickSort(start, privot_index);</span><br><span class="line">        quickSort(privot_index+<span class="hljs-number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> pivot = arr[start];<span class="hljs-comment">//we select the first element of the sequence as the pivot, which means we need to traverse the sequence from the last firstly</span></span><br><span class="line">        <span class="hljs-keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">            <span class="hljs-keyword">while</span>(start &lt; end &amp;&amp; pivot &lt;= arr[end])<span class="hljs-comment">//traverse the sequence until we find an element which value is smaller than the pivot's value</span></span><br><span class="line">                --end;</span><br><span class="line">            <span class="hljs-keyword">if</span>(start &lt; end)<span class="hljs-comment">//if we find an element which value is smaller than the pivot's value, then swap them</span></span><br><span class="line">                swap(start++, end);</span><br><span class="line">            <span class="hljs-keyword">while</span>(start &lt; end &amp;&amp; pivot &gt;= arr[start])<span class="hljs-comment">//traverse the sequence from the head until we find an element which value is larger than the pivot's value</span></span><br><span class="line">                start++;</span><br><span class="line">            <span class="hljs-keyword">if</span>(start &lt; end)</span><br><span class="line">                swap(start, end--);<span class="hljs-comment">//if we find an element which value is larger than the pivot's value, then swap them</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong><a href="https://github.com/LeeYatSan/Algorithms/tree/master/Sorting%20Algorithms" target="_blank" rel="noopener">查看完整代码</a></strong>  </p>
</blockquote>
<h2 id="堆排序-Heap-Sort"><a href="#堆排序-Heap-Sort" class="headerlink" title="堆排序 Heap Sort"></a>堆排序 Heap Sort</h2><p>在讨论堆排序之前，我们先了解一下堆这种数据结构。堆分为大、小顶堆，具有子结点的键值或索引总是小于（或者大于）它的父节点的性质。堆排序是一种树形选择排序，在排序过程中可以把元素看成是一颗完全二叉树，根据堆的性质可得：每个节点都大（小）于它的两个子节点。 这里以长度为n大顶堆为例。 </p>
<h3 id="堆排序性能"><a href="#堆排序性能" class="headerlink" title="堆排序性能"></a>堆排序性能</h3><ul>
<li><strong>不稳定排序</strong></li>
<li>时间复杂度：<ul>
<li>最好情况：O(nlgn)</li>
<li>平均情况：O(nlgn)</li>
<li>最差情况：O(nlgn)  </li>
</ul>
</li>
</ul>
<h3 id="工作过程-1"><a href="#工作过程-1" class="headerlink" title="工作过程"></a>工作过程</h3><p>在构造有序堆时，我们开始只需要扫描一半的元素[0, n/2-1]即可，为什么?因为根据完全二叉树的性质，只有序号为[0, n/2-1]的节点才有子节点，如下图所示，n=8,(n/2-1) = 3 即3 2 1 0这个四个节点才有子节点。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3661808-fbb5c9798328ac79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/336/format/webp" alt="只有一半的节点有子节点">  </p>
<p>我们需要注意的是，假设当前节点的序号为k，则其父母节点的序号为k/2向下取整的值，而其左子节点的序号为2k+1，其右节点的序号为2k+2。如上图所示，3号节点的父母节点为3/2向下取整即为1号节点，其左子节点为3*2+1=7号节点，其右节点为3*2+2=8号节点。  </p>
<p>一个共有 n 个结点的堆在第 h 层最多的结点数为：  </p>
<p><img src="//leeyatsan.cn/2019/03/03/排序算法总结/1.png" alt="一个共有 n 个结点的堆在第 h 层最多的结点数为">    </p>
<p><strong>heapify()</strong>：堆化操作：它的时间复杂度等于当前元素的层数k = lgn ， 即 O(lgn).<br><strong>buildMaxHeap()</strong>：建堆操作：O(n).    </p>
<blockquote>
<p><strong>STEP1:</strong> 先将长度为n的待排序数组建立一个大顶堆<br><strong>STEP2:</strong> 交换堆顶与结尾的元素，即将大顶堆的顶（即最大的元素）放在数组最后Rn，此时产生了一个R[1…n-1]的无序序列与一个Rn的有序序列<br><strong>STEP3:</strong> 由于交换可能导致失序，因此重新对对进行”堆化”<br><strong>STEP4:</strong> 对无序序列重复STEP1，STEP2，STEP3，完成排序  </p>
</blockquote>
<h3 id="动画演示-1"><a href="#动画演示-1" class="headerlink" title="动画演示"></a>动画演示</h3><p><img src="https://img2018.cnblogs.com/blog/751560/201812/751560-20181204174159864-316343160.gif" alt="heap sort">  </p>
<h3 id="Java代码-1"><a href="#Java代码-1" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeapSort</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sort</span> </span>&#123;</span><br><span class="line">    HeapSort(<span class="hljs-keyword">int</span>[] arr)&#123;</span><br><span class="line">        <span class="hljs-keyword">super</span>(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">coreSort</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">        buildMaxHeap();</span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = arr.length -<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">1</span>; --i)&#123;<span class="hljs-comment">//loop until the length of the sequence is less than 2</span></span><br><span class="line">            swap(<span class="hljs-number">0</span>, i);</span><br><span class="line">            heapify(<span class="hljs-number">0</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildMaxHeap</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//build a max heap</span></span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = arr.length/<span class="hljs-number">2</span>-<span class="hljs-number">1</span>; i&gt;=<span class="hljs-number">0</span>; i--)<span class="hljs-comment">//build max heap for all non-leaf nodes</span></span><br><span class="line">            heapify(i, arr.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapify</span><span class="hljs-params">(<span class="hljs-keyword">int</span> curr_index, <span class="hljs-keyword">int</span> size)</span></span>&#123;<span class="hljs-comment">//to adjust the heap to a max heap</span></span><br><span class="line">        <span class="hljs-keyword">int</span> left_index = <span class="hljs-number">2</span>*curr_index+<span class="hljs-number">1</span>, right_index = <span class="hljs-number">2</span>*curr_index+<span class="hljs-number">2</span>;</span><br><span class="line">        <span class="hljs-keyword">int</span> largest_index = curr_index;</span><br><span class="line">        <span class="hljs-keyword">if</span>(left_index &lt; size &amp;&amp; arr[left_index ] &gt; arr[largest_index])<span class="hljs-comment">//to find the largest one among current node and its child nodes</span></span><br><span class="line">            largest_index = left_index;</span><br><span class="line">        <span class="hljs-keyword">if</span>(right_index &lt;size &amp;&amp; arr[right_index] &gt; arr[largest_index])</span><br><span class="line">            largest_index = right_index;</span><br><span class="line">        <span class="hljs-keyword">if</span>(largest_index != curr_index)&#123;<span class="hljs-comment">//if current node is not the largest one, then exchange them</span></span><br><span class="line">            swap(largest_index, curr_index);<span class="hljs-comment">//exchange the value of current node and the largest node only, which means that the index of largest node is not changed but its value is not the largest one but current node one instead. In other words, the current node's index is changed to the ex-largest node's index.</span></span><br><span class="line">            heapify(largest_index, size);<span class="hljs-comment">//because of the exchange leading to the change of the current node's index, the max heap may be broken, which means we need to re-heapify a new one.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong><a href="https://github.com/LeeYatSan/Algorithms/tree/master/Sorting%20Algorithms" target="_blank" rel="noopener">查看完整代码</a></strong>  </p>
</blockquote>
<h2 id="计数排序-Counting-Sort"><a href="#计数排序-Counting-Sort" class="headerlink" title="计数排序 Counting Sort"></a>计数排序 Counting Sort</h2><p>计数排序是一种以空间换取时间的排序方式。它通过设立额外的计数数组C，统计待排序数组中每个值的出现的次数，最后再由计数数组生成有序数组。</p>
<h3 id="工作过程-2"><a href="#工作过程-2" class="headerlink" title="工作过程"></a>工作过程</h3><blockquote>
<p><strong>初始:</strong> 开辟一个新的计数数组C，其下标值对应待排序数组的每种数组的元素值，数组内元素记录的是待排序每种数值对应的出现次数<br><strong>STEP1:</strong> 找出待排序的数组中最大和最小的元素<br><strong>STEP2:</strong> 统计待排序数组的每种元素出现的次数，计数值根据元素值填入对应统计数组C对应下标的元素中，即统计数组中每个值为i的元素出现的次数，存入数组C的第i项<br><strong>STEP3:</strong> 对所有计数进行累加<br><strong>STEP4:</strong> 反向填充数组，得出有序化的数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1  </p>
</blockquote>
<h3 id="动画演示-2"><a href="#动画演示-2" class="headerlink" title="动画演示"></a>动画演示</h3><p><img src="http://louiszhai.github.io/docImages/sort10.gif" alt="counting sort">  </p>
<h3 id="Java代码-2"><a href="#Java代码-2" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountingSort</span> <span class="keyword">extends</span> <span class="title">Sort</span> </span>{

    CountingSort(<span class="keyword">int</span>[] arr){
        <span class="keyword">super</span>(arr);
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">coreSort</span><span class="params">()</span></span>{
        <span class="keyword">int</span> min = arr[<span class="number">0</span>], max = arr[<span class="number">0</span>];<span class="comment">//to keep the min and max value in unsorted array</span>
        <span class="keyword">for</span>(<span class="keyword">int</span> i : arr){
            <span class="keyword">if</span>(i &gt; max)
                max = i;
            <span class="keyword">if</span>(i &lt; min)
                min = i;
        }
        <span class="keyword">int</span> bias = <span class="number">0</span>-min;<span class="comment">//the min value may not equals to 0</span>
        <span class="keyword">int</span>[] couting_arr = <span class="keyword">new</span> <span class="keyword">int</span>[max-min+<span class="number">1</span>];<span class="comment">//temp-counting array</span>
        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) {<span class="comment">//counting the number of each value in unsorted array</span>
            couting_arr[i+bias]++;<span class="comment">//i+bias makes sure that the first non-zero element's index is 0</span>
        }
        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;
        <span class="keyword">while</span>(i &lt; couting_arr.length){
            <span class="keyword">if</span>(couting_arr[i] != <span class="number">0</span>){
                arr[j] = i - bias;
                --couting_arr[i];
                ++j;
            }
            <span class="keyword">else</span>
                i++;
        }
    }
}  

</code></pre>
<blockquote>
<p><strong><a href="https://github.com/LeeYatSan/Algorithms/tree/master/Sorting%20Algorithms" target="_blank" rel="noopener">查看完整代码</a></strong>    </p>
</blockquote>
<h2 id="桶排序-Bucket-Sort"><a href="#桶排序-Bucket-Sort" class="headerlink" title="桶排序 Bucket Sort"></a>桶排序 Bucket Sort</h2><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序）。这里以递归使用桶排序为例。  </p>
<h3 id="工作过程-3"><a href="#工作过程-3" class="headerlink" title="工作过程"></a>工作过程</h3><blockquote>
<p><strong>STEP1:</strong> 人为设置一个BucketSize，作为每个桶所能放置多少个不同数值（例如当BucketSize==5时，该桶可以存放｛1,2,3,4,5｝这几种数字，但是容量不限，即可以存放100个3）<br><strong>STEP2:</strong> 遍历输入数据，并且把数据一个一个放到对应的桶里去<br><strong>STEP3:</strong> 对每个不是空的桶进行排序，可以使用其它排序方法，也可以递归使用桶排序。注意，如果递归使用桶排序为各个桶排序，则当桶数量为1时要手动减小BucketSize增加下一循环桶的数量，否则会陷入死循环，导致内存溢出。<br><strong>STEP4:</strong> 从不是空的桶子里把项目再放回原来的序列中</p>
</blockquote>
<h3 id="动画演示-3"><a href="#动画演示-3" class="headerlink" title="动画演示"></a>动画演示</h3><p><img src="https://img2018.cnblogs.com/blog/751560/201812/751560-20181204165243219-1929503636.gif" alt="bucket sort">  </p>
<h3 id="Java代码-3"><a href="#Java代码-3" class="headerlink" title="Java代码"></a>Java代码</h3><blockquote>
<p><strong><a href="https://github.com/LeeYatSan/Algorithms/tree/master/Sort%20List" target="_blank" rel="noopener">查看完整代码</a></strong>   </p>
</blockquote>
<h2 id="基数排序-Radix-Sort"><a href="#基数排序-Radix-Sort" class="headerlink" title="基数排序 Radix Sort"></a>基数排序 Radix Sort</h2><p>基数排序也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn),为数组长度，k为数组中的数的最大的位数；基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。  </p>
<h3 id="工作过程-4"><a href="#工作过程-4" class="headerlink" title="工作过程"></a>工作过程</h3><blockquote>
<p><strong>STEP1:</strong> 查找待排序数组中最大的数，并计算其位数<br><strong>STEP2:</strong> arr为原始数组，从最低位开始取每个位组成radix数组<br><strong>STEP3:</strong> 对radix进行计数排序（利用计数排序适用于小范围数的特点）  </p>
</blockquote>
<h3 id="动画演示-4"><a href="#动画演示-4" class="headerlink" title="动画演示"></a>动画演示</h3><p><img src="http://louiszhai.github.io//docImages/sort11.gif" alt="radix sort">  </p>
<h3 id="Java代码-4"><a href="#Java代码-4" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">
<span class="keyword">import</span> java.util.ArrayList;

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RadixSort</span> <span class="keyword">extends</span> <span class="title">Sort</span> </span>{

    RadixSort(<span class="keyword">int</span>[] arr){
        <span class="keyword">super</span>(arr);
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">coreSort</span><span class="params">()</span></span>{
        <span class="keyword">int</span> max = arr[<span class="number">0</span>];
        <span class="keyword">for</span>(<span class="keyword">int</span> i : arr){<span class="comment">//find the max value in the array</span>
            <span class="keyword">if</span>(max &lt; i)
                max = i;
        }
        <span class="keyword">int</span> mod = <span class="number">10</span>, div = <span class="number">1</span>, max_digit = <span class="number">0</span>;
        <span class="keyword">while</span>(max != <span class="number">0</span>){<span class="comment">//calculate the digits of the max value</span>
            max/=<span class="number">10</span>;
            ++max_digit;
        }
        ArrayList&lt;ArrayList&lt;Integer&gt;&gt;buckets = <span class="keyword">new</span> ArrayList&lt;&gt;();
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)
            buckets.add(<span class="keyword">new</span> ArrayList&lt;&gt;());
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max_digit; mod*=<span class="number">10</span>, div*=<span class="number">10</span>, ++i){
            <span class="keyword">for</span>(<span class="keyword">int</span> elem : arr)
                buckets.get((elem%mod)/div).add(elem);
            <span class="keyword">int</span> index = <span class="number">0</span>;
            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; buckets.size(); ++k){
                ArrayList&lt;Integer&gt; curr = buckets.get(k);
                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; curr.size(); ++j)
                    arr[index++] = curr.get(j);
                curr.clear();
            }
        }
    }
}   

</code></pre>
<blockquote>
<p><strong><a href="https://github.com/LeeYatSan/Algorithms/tree/master/Sorting%20Algorithms" target="_blank" rel="noopener">查看完整代码</a></strong>  </p>
</blockquote>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><blockquote>
<p>[1] <a href="https://en.wikipedia.org/wiki/Sorting_algorithm" target="_blank" rel="noopener">Sorting algorithm</a><br>[2] <a href="https://www.cnblogs.com/onepixel/articles/7674659.html" target="_blank" rel="noopener">十大经典排序算法（动图演示）</a><br>[3] <a href="http://www.codeceo.com/article/10-sort-algorithm-interview.html#0-tsina-1-10490-397232819ff9a47a7b7e80a40613cfe1" target="_blank" rel="noopener">面试中的 10 大排序算法总结</a><br>[4] <a href="https://www.jianshu.com/p/869437746bae" target="_blank" rel="noopener">堆排序算法</a><br>[5] <a href="https://zhuanlan.zhihu.com/p/34894768" target="_blank" rel="noopener">十大经典排序算法最强总结（含Java代码实现）</a><br>[6] <a href="https://www.cnblogs.com/sky-chen/p/10065038.html" target="_blank" rel="noopener">排序算法图解（插入、选择、冒泡、快速、合并、希尔等等）</a>  </p>
</blockquote>

        </div>
        
        
        <hr style="height:1px;margin:1rem 0"/>
        <div class="level is-size-7 is-uppercase">
            <div class="level-start">
                <div class="level-item">
                    <!--<span class="is-size-6 has-text-grey has-mr-7">#</span>-->
                    <i class="fas fa-tags has-text-grey"></i>&nbsp;
                    <a class="has-link-grey -link" href="/tags/Algorithm/">Algorithm</a>,&nbsp;<a class="has-link-grey -link" href="/tags/Java/">Java</a>,&nbsp;<a class="has-link-grey -link" href="/tags/Sort/">Sort</a>
                </div>
            </div>
        </div>
        
        
        
        <div class="social-share"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css">
<script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script>
        
    </div>
</div>





<div class="card card-transparent">
    <div class="level post-navigation is-flex-wrap is-mobile">
        
        <div class="level-start">
            <a class="level level-item has-link-grey  article-nav-prev" href="/2019/03/03/hello-world/">
                <i class="level-item fas fa-chevron-left"></i>
                <span class="level-item">Hello World</span>
            </a>
        </div>
        
        
        <div class="level-end">
            <a class="level level-item has-link-grey  article-nav-next" href="/2019/03/01/Combinatorial-Games-Nim-Game/">
                <span class="level-item">LeetCode | 292.Nim Game -- 组合博弈论（巴什博弈）</span>
                <i class="level-item fas fa-chevron-right"></i>
            </a>
        </div>
        
    </div>
</div>



<div class="card">
    <div class="card-content">
        <h3 class="title is-5 has-text-weight-normal">Comments</h3>
        
<div id="comment-container"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.4.1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1.4.1/dist/gitalk.min.js"></script>
<script>
    var gitalk = new Gitalk({
        clientID: '80ed07e081b981160e61',
        clientSecret: '382ed27619498a0da41899f29b8ded4ff68dbfd7',
        id: '7654d5aeacfbc3da35fc7357242fcc27',
        repo: 'leeyatsan.github.io',
        owner: 'LeeYatSan',
        admin: "LeeYatSan",
        createIssueManually: false,
        distractionFreeMode: false
    })
    gitalk.render('comment-container')
</script>

    </div>
</div>

</div>
                




<div class="column is-4-tablet is-4-desktop is-3-widescreen  has-order-1 column-left ">
    
        
<div class="card widget column-left is-sticky" id="toc">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                Catalogue
            </h3>
            <ul class="menu-list"><li>
        <a class="is-flex" href="#算法概述">
        <span class="has-mr-6">1</span>
        <span>算法概述</span>
        </a></li><li>
        <a class="is-flex" href="#算法性能评价">
        <span class="has-mr-6">2</span>
        <span>算法性能评价</span>
        </a><ul class="menu-list"><li>
        <a class="is-flex" href="#时间复杂度">
        <span class="has-mr-6">2.1</span>
        <span>时间复杂度</span>
        </a></li><li>
        <a class="is-flex" href="#空间复杂度">
        <span class="has-mr-6">2.2</span>
        <span>空间复杂度</span>
        </a></li><li>
        <a class="is-flex" href="#稳定性">
        <span class="has-mr-6">2.3</span>
        <span>稳定性</span>
        </a></li><li>
        <a class="is-flex" href="#10种经典算法的性能总结：">
        <span class="has-mr-6">2.4</span>
        <span>10种经典算法的性能总结：</span>
        </a></li></ul></li><li>
        <a class="is-flex" href="#算法描述">
        <span class="has-mr-6">3</span>
        <span>算法描述</span>
        </a><ul class="menu-list"><li>
        <a class="is-flex" href="#冒泡排序-Bubble-Sort">
        <span class="has-mr-6">3.1</span>
        <span>冒泡排序 Bubble Sort</span>
        </a><ul class="menu-list"><li>
        <a class="is-flex" href="#工作过程">
        <span class="has-mr-6">3.1.1</span>
        <span>工作过程</span>
        </a></li><li>
        <a class="is-flex" href="#动画演示">
        <span class="has-mr-6">3.1.2</span>
        <span>动画演示</span>
        </a></li><li>
        <a class="is-flex" href="#Java代码">
        <span class="has-mr-6">3.1.3</span>
        <span>Java代码</span>
        </a></li></ul></li><li>
        <a class="is-flex" href="#堆排序-Heap-Sort">
        <span class="has-mr-6">3.2</span>
        <span>堆排序 Heap Sort</span>
        </a><ul class="menu-list"><li>
        <a class="is-flex" href="#堆排序性能">
        <span class="has-mr-6">3.2.1</span>
        <span>堆排序性能</span>
        </a></li><li>
        <a class="is-flex" href="#工作过程-1">
        <span class="has-mr-6">3.2.2</span>
        <span>工作过程</span>
        </a></li><li>
        <a class="is-flex" href="#动画演示-1">
        <span class="has-mr-6">3.2.3</span>
        <span>动画演示</span>
        </a></li><li>
        <a class="is-flex" href="#Java代码-1">
        <span class="has-mr-6">3.2.4</span>
        <span>Java代码</span>
        </a></li></ul></li><li>
        <a class="is-flex" href="#计数排序-Counting-Sort">
        <span class="has-mr-6">3.3</span>
        <span>计数排序 Counting Sort</span>
        </a><ul class="menu-list"><li>
        <a class="is-flex" href="#工作过程-2">
        <span class="has-mr-6">3.3.1</span>
        <span>工作过程</span>
        </a></li><li>
        <a class="is-flex" href="#动画演示-2">
        <span class="has-mr-6">3.3.2</span>
        <span>动画演示</span>
        </a></li><li>
        <a class="is-flex" href="#Java代码-2">
        <span class="has-mr-6">3.3.3</span>
        <span>Java代码</span>
        </a></li></ul></li><li>
        <a class="is-flex" href="#桶排序-Bucket-Sort">
        <span class="has-mr-6">3.4</span>
        <span>桶排序 Bucket Sort</span>
        </a><ul class="menu-list"><li>
        <a class="is-flex" href="#工作过程-3">
        <span class="has-mr-6">3.4.1</span>
        <span>工作过程</span>
        </a></li><li>
        <a class="is-flex" href="#动画演示-3">
        <span class="has-mr-6">3.4.2</span>
        <span>动画演示</span>
        </a></li><li>
        <a class="is-flex" href="#Java代码-3">
        <span class="has-mr-6">3.4.3</span>
        <span>Java代码</span>
        </a></li></ul></li><li>
        <a class="is-flex" href="#基数排序-Radix-Sort">
        <span class="has-mr-6">3.5</span>
        <span>基数排序 Radix Sort</span>
        </a><ul class="menu-list"><li>
        <a class="is-flex" href="#工作过程-4">
        <span class="has-mr-6">3.5.1</span>
        <span>工作过程</span>
        </a></li><li>
        <a class="is-flex" href="#动画演示-4">
        <span class="has-mr-6">3.5.2</span>
        <span>动画演示</span>
        </a></li><li>
        <a class="is-flex" href="#Java代码-4">
        <span class="has-mr-6">3.5.3</span>
        <span>Java代码</span>
        </a></li></ul></li></ul></li><li>
        <a class="is-flex" href="#参考文献">
        <span class="has-mr-6">4</span>
        <span>参考文献</span>
        </a></li></ul>
        </div>
    </div>
</div>

    
    
        <div class="column-right-shadow is-hidden-widescreen ">
        
        </div>
    
</div>


                

            </div>
        </div>
    </section>
    <footer class="footer">
    <div class="container">
        <div class="level">
            <div class="level-start has-text-centered-mobile">
                <a class="footer-logo is-block has-mb-6" href="/">
                
                    <img src="/images/logo.svg" alt="10种经典排序算法总结" height="28">
                
                </a>
                <p class="is-size-7">
                &copy; 2020 LEE YAT-SAN&nbsp;
                Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> & <a
                        href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a>
                
                </p>
            </div>
            <div class="level-end">
            
            </div>
        </div>
    </div>
</footer>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script>
<script>moment.locale("zh-Hans");</script>

<script>
var IcarusThemeSettings = {
    article: {
        highlight: {
            clipboard: true,
            fold: 'unfolded'
        }
    }
};
</script>


    <script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script>



    
    
<script src="/js/animation.js"></script>

    
    
<script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script>
<script src="/js/gallery.js" defer></script>

    
    
<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update
            my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        });
    });
</script>

    
    <script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    MathJax.Hub.Config({
        'HTML-CSS': {
            matchFontHeight: false
        },
        SVG: {
            matchFontHeight: false
        },
        CommonHTML: {
            matchFontHeight: false
        },
        tex2jax: {
            inlineMath: [
                ['$','$'],
                ['\\(','\\)']
            ]
        }
    });
});
</script>
    
    
<a id="back-to-top" title="Back to Top" href="javascript:;">
    <i class="fas fa-chevron-up"></i>
</a>
<script src="/js/back-to-top.js" defer></script>

    
    
    
    
    
    
    
    
    
    
    


<script src="/js/main.js" defer></script>

    
    <div class="searchbox ins-search">
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="Type something..." />
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: 'Posts',
                PAGES: 'Pages',
                CATEGORIES: 'Categories',
                TAGS: 'Tags',
                UNTITLED: '(Untitled)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js" defer></script>
<link rel="stylesheet" href="/css/search.css">
<link rel="stylesheet" href="/css/insight.css"><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
    
</body>
</html>
