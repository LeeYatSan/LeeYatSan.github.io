{"pages":[{"title":"about","text":"","link":"/about/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"Android 知识体系","text":"本文档收录了 Android 相关知识的总结。同时参考了 CSDN 用户「ClAndEllen」及其他技术博客主的相关博客，相关链接见本文最后一部分参考。 总路线 初级 布局 分类 线性布局(LinearLayout) 相对布局(RelativeLayout) 约束布局(ConstraintLayout) 网格布局(GridLayout) 表格布局(TableLayout) 帧布局(FrameLayout) 绝对布局(AbsoluteLayout)(过时) RTL从右到左的布局 Android 布局文件映射源码分析四大组件 Activity BroadcastReceiver ContentProvider Service 数据通信 Handler AsyncTask HandlerThread IntentService Binder Intent Bundle Fragment数据持久化 SharedPreferences(被MMKV取代) 文件存储数据 SQLite数据库存储数据 使用ContentProvider存储数据(四大组件中已经介绍) 网络存储数据 网络请求与数据解析对话框通知基础级别UI控件高级UI控件 ListView RecyclerView ViewPager WebView CardView Material + design 常用的轮子中级 高级 其他知识点参考 Android知识体系总结2019年5月份(初级到中级再到高级，你值得拥有) ｜ ClAndEllen （遵循 CC 4.0 BY-SA 版权协议）","link":"/2019/12/12/Android 知识体系/"},{"title":"LeetCode | 292.Nim Game -- 组合博弈论（巴什博弈）","text":"最近在LeetCode中遇到一个博弈论的游戏，[292] Nim Game的题，由于之前没有学习过博弈论相关知识，因此一开始我是暴力地、大胆地使用找规律的方法求解。虽然最终代码与结果均与官方答案一致，但发现其中蕴含博弈论的相关知识，结合网络上相关博客，在此记录一下学习总结。 问题引入 You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones. Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap. 简单来说就是给定一定的石头，我先你后轮流取，每次只能取1-3个石头，最后取完石头的胜利。 巴什博弈(Bash Game)只有一堆n个物品，两个人轮流从这堆物品中取物， 规定每次至少取一个，最多取m个。最后取光者得胜。 巴什博弈局面 面对[1…m]个局面，必胜 面对m+1个局面，必输 如果可以使对手面临必输局面，那么是必赢局面 如果不能使对手面临必输局面，那么是必输局面 一般定义n个物品，两个人每人每次可以取m~k个物品，最后取完的人获胜，输入n,m,k，问先手能否获胜。 证明123456789101112只能取m~k个物品，先手取了x个，后手取y个：设 x = m+z ① ④⑤⑥⑦⑧⑨⑩ y = m+i ② k = m+j ③则 ①+② 得 x+y = z+i+2m ④ ③+m 得 m+k = 2m+j ⑤其中 j &gt; z 且z,i,j都大于0ョz, ョi 使得 z+i = j ⑥即：联立④⑤⑥，对 ∀x，ョy 使得 x+y=m+k ⑦又即无论先手取多少x，后手都存在一个可取的y使得两人所取物品总和为m+k所以如果n%(m+k)==0，即先手无论取多少个，后手只要使这次取的和对手上次取的物品加起来为m+k，取完后剩下的物品总是m+k的倍数,且m不为0,先手不能取完，后手就能保证胜利，也即先手必输。 拓展如果修改为取完的失败，则1局面 (n-m)%(m+k) == 0 为必输局面 源码本题中，m = 1, k = 3，则先手必输局面为：1n%(m+k)==0 =&gt; n%4 == 0 因此本题解法如下： class Solution { public boolean canWinNim(int n) { return (n%4 != 0); } } 查看完整代码 参考文献 [1] Nim游戏[2] 组合博奕论[3] 巴什博奕","link":"/2019/03/01/Combinatorial-Games-Nim-Game/"},{"title":"Design Patterns - Adapter","text":"本文将介绍设计模式中的适配器模式（Adapter）。 定义该模式将一个类的接口转换成客户期望的另一个接口，让原本接口不兼容的类可以合作无间。适配器如同一个中间人，将客户所发出的请求转换成厂商能理解的请求。 原则 使用对象组合，以修改的接口包装被适配者 实现 客户通过目标接口调用适配器的方法对适配器发出请求 适配器使用被适配者接口把请求转换成被适配者的一个或者多个调用接口 客户接收到调用结果，但并未察觉这一切都是适配器在起转换作用 适配器有两种，一种是对象适配器，另一种是类适配器。对象适配器使用的是组合，而类适配器使用的是继承。但是，类适配器需要支持多重继承的语言才能实现它，因此 Java 只能实现对象适配器。而且对象适配器可以适配某个类及其所有子类，而类适配器只能适配某个具体类本身。 应用实例现在，我们通过适配器让一只火鸡假扮成一只鸭子： 已知鸭子接口和火鸡接口： 123456789public interface Duck { public void quack(); public void fly();}public interface Turkey { public void gobble(); public void fly();} 现在有一只火鸡： 123456789public class WildTurkey implements Turkey { public void gobble(){ System.out.println(&quot;Gobble gobble&quot;); } public void fly(){ System.out.println(&quot;Turkey flies a short distance&quot;); }} 这只调皮的火鸡试图假扮成一只鸭子，因此它需要用到鸭子火鸡适配器： 123456789101112131415161718192021/*** 该适配器将鸭子接口转换成火鸡能用的接口*/public class TurkeyAdapter implements Duck { Turkey turkey; public TurkeyAdapter(Turkey turkey){ this.turkey = turkey; } public void quack(){ turkey.gobble(); } public void fly(){ // 鸭子可以飞很远，但火鸡不能。因此让火鸡飞5次才能赶上鸭子的距离 for(int i = 0; i &lt; 5; i++){ turkey.fly(); } }} 现在开始火鸡假扮鸭子的表演： 12345678910111213141516171819202122232425public class DuckTestDrive { public static void main(String[] args){ // 先创建一个火鸡 WildTurkey turkey = new WildTurkey(); // 让火鸡做回自己先 turkey.gobble(); turkey.fly(); System.out.println(&quot;===================&quot;) // 创建火鸡鸭子适配器 TurkeyAdapter adapter = new TurkeyAdapter(turkey); // 现在这只火鸡要假扮成一只鸭子调用 testDuck()方法 testDuck(adapter); } /** * 该方法获得一只鸭子，并调用它的方法 */ static void testDuck(Duck duck){ duck.quack(); duck.fly(); }} 现在看看效果： 1234567891011// OutputGobble gobbleTurkey flies a short distance===================Gobble gobbleTurkey flies a short distanceTurkey flies a short distanceTurkey flies a short distanceTurkey flies a short distanceTurkey flies a short distance 这只火鸡成功的用适配器假扮了一只鸭子！","link":"/2019/12/22/Design Patterns - Adapter/"},{"title":"Design Patterns - Facade","text":"本文将介绍设计模式中的外观模式（Facade）。 定义该模式提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。外观模式将一个或者数个类的复杂的一切都隐藏在背后，只露出一个干净美好的外观。外观模式也允许你将客户实现从任何子系统中解耦。 外观模式的一个特征就是在提供简化接口的同时，依然将系统完整的功能暴露出来，以供需要的人使用。 原则 最小知道原则：设计一个系统，不管是任何对象，都要注意它所交互的类有哪些，并注意它们是如何交互的。如何才能避免违反该原则呢？我们应该尽可能做到只调用属于以下范围的方法： 该对象本身的方法 被当成方法的参数而传递进来的对象的方法 此方法创建或实例化的任何对象的方法 对象的任何组件的方法 实现通过创建一个类作为对外接口，封装子系统中复杂的业务。在使用外观模式时，要注意尽可能遵循最小知道原则，以降低耦合性。 应用实例我们通过一个家庭影院的例子来理解一下外观模式。 假设我们有一套家庭影院系统，包括屏幕（Screen）、播放器（Player）、灯光（Light）、扬声器（Amplifier）等等。那么我们每一次打开或者关闭影院的时候，都需要将它们一一打开或者关闭，势必造成一定的不便。： 1234567891011121314151617181920public class Screen { public void on(){/***/}; public void off(){/***/};}public class Player { public void on(){/***/}; public void off(){/***/}; public void play(String movieName){/***/};}public class Light { public void on(){/***/}; public void off(){/***/};}public class Amplifier { public void on(){/***/}; public void off(){/***/};} 那么现在通过外观模式，我们建立一个高层类来管理他们，暴露一个简化的接口来方便我们的操作： 123456789101112131415161718192021222324252627282930public class HomeTheaterFacade { Screen screen; Player player; Light light; Amplifier amplifier; public HomeTheaterFacade(Screen screen, Player player, Light light, Amplifier amplifier){ this.screen = screen; this.player = player; this.light = light; this.amplifier = amplifier; } public void watchMovie(String movieName){ screen.on(); player.on(); light.on(); amplifier.on(); player.play(movieName); } public void turnOff(){ screen.off(); player.off(); light.off(); amplifier.off(); }} 这样我们就通过外观模式成功将一套复杂的系统封装为一个简洁的接口供用户使用。","link":"/2019/12/22/Design Patterns - Facade/"},{"title":"Design Patterns - Command","text":"本文将介绍设计模式中的命令模式（Command）。 定义该模式将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。该模式使得“发出请求的对象”和“接受与执行这些请求的对象”分隔开来，实现解耦。 原则 当需要将发出请求的对象和执行请求的对象解耦时，使用命令模式 实现 创建一个抽象的命令接口 Command，其中只包含一个 execute()方法。 创建命令对象，所有命令对象都需要实现 Command 接口，即实现 execute()方法：命令接收执行者执行的动作。命令对象中还应包含命令接收执行者的应用。 创建调用者对象（Invoker），将命令传递给调用者对象，由调用者对象执行 execute()方法，使得命令接收执行者执行对应动作。 应用实例命令模式常常应用与日程安排（Scheduler）、线程池、工作队列等地方。 我们以一个餐厅中的例子来理解一下这种模式。一个餐厅中有若干顾客，有服务员，有厨师。顾客就是“发出请求的对象”，而厨师则是最终的“接受与执行这些请求的对象”。顾客只需在订单（即命令对象）上写上自己的需求，交给服务员，即调用者（Invoker），而服务员实际上无需知道订单内容，但她知道所有的订单中都有一个 execute()方法，她唯一需要做的就是将订单从顾客手中传递给厨师，即调用订单中的 execute()方法，而厨师则需知道并具体执行订单内容。 现在，我们再以一个多功能遥控器的例子来说明这个模式。 已知厂家所提供的电灯类为： 1234public class Light { public void on(){/***/} public void off(){/***/}} 我们首先来创建命令对象，让所有的命令对象实现相同的包含一个方法的接口 Command： 123public interface Command { public void execute();} 然后，我们实现一个打开电灯的命令： 123456789101112131415public LightOnCommand implements Command { Light light; public LightOnCommand(Light light){ this.light = light; } /** * 一旦调用，电灯对象将编程接受者，负责接受并执行请求 */ public void execute(){ light.on(); }} 好了，现在我们再来看看我们的遥控器。它只有一个按钮和对应的插槽（一个插槽对应一种装置，这里指电灯）： 1234567891011121314151617public class SimpleRemoteControl { Command slot; public SimpleRemoteControl(){} /** * 该方法用于设置对应插槽控制的命令。如果这段代码的客户想要改变遥控器的行为， * 多次调用该方法即可。 */ public void setCommand(Command command){ slot = command; } public void buttonWasPressed(){ slot.execute(); }} 现在，我们来用一下这个遥控器： 123456789101112131415public class RemoteControlTest { public static void main(String[] args){ // 创建遥控器实例 SimpleRemoteControl remote = new SimpleRemoteControl(); // 创建接受执行者实例 Light light = new Light(); // 创建命令 对象 LightOnCommand lightOn = new LightOnCommand(light); // 将命令传递给调用者 remote.setCommand(lightOn); // 调用者执行命令 execute() ，执行后会使得接受者执行对应动作 remote.buttonWasPressed(); }} 这样，我们就通过命令模式成功实现了一个遥控器。","link":"/2019/12/22/Design Patterns - Command/"},{"title":"Design Patterns - Iterator","text":"本文将介绍设计模式中的迭代器模式（Iterator）。 定义该模式提供一种方法顺序访问一个聚合对象种的各个元素，而不是暴露其内部的表示。 原则 单一职责原则：一个类应该只有一个引起变化的原因。类的每个责任都有改变的潜在区域。超过一个责任，意味着超过一个改变的区域。 实现聚合对象实现一个包含创建迭代器方法的一个接口 Aggregate，将迭代器的具体功能交给该聚合对象所对应的迭代器类 ConcreteIterator 来处理，该类实现统一的迭代器接口 Iterator。 迭代器接口 Iterator 内含 hasNext()、next()、remove()三个基本方法，一般来说前两个必须实现，remove()方法可以通过返回一个 java.lang.UnsupportedOperationExeception 的运行时异常。注意，在多线程环境下使用 remove() 方法使用异常！ 之所以要将迭代器的方法单独创建一个 ConcreteIterator 的具体迭代器类来处理而不是由本省的聚合对象类来处理是为了遵循单一职责原则，即使得原本类负责的任务尽可能少。 应用实例迭代器应用实例最典型的就是 Java 的 Collection 集合类，其内置的大部分集合类都已经实现 Iterator。 我们通过一个将两个不同菜单合并的例子来理解一下迭代器模式。现有两个菜单，Lou 的菜单和 Mel 的菜单。前者是通过 ArrayList 来实现的，后者则是直接通过数组来实现的。现在需要侍者 Waiter 打印两个不同的菜单。 最粗暴的方式是对两种不同的菜单进行不同方式的遍历： 12345678910111213141516171819public class Waiter { Lou lou; MealItem[] mealItems; Waiter(Lou lou, Mel mel){ this.lou = lou; this.mealItems = mel.getMenu(); } public void printMenu(){ for(int i = 0; i &lt; lou.size(); i++){ System.out.println(lou.get(i)); } for(MealItem curr : mealItems){ System.out.println(curr.getDescription()); } }} 但仔细看看上面的代码，可以发现侍者的实现与 Lou 和 Mel 菜单的内部具体实现紧密的耦合在了一起（即侍者必须知道 Lou 和 Mel 菜单内部如何实现的才能实现自身相应功能），显然不是一个很好的设计。那么，如果我们改用迭代器模式来实现会怎样呢？ 迭代器模式，先要准备好迭代器接口 Iterator 和聚合类用于创建迭代器的接口 Aggregate： 123456789public interface Iterator{ public boolean hasNext(); public Object next(); public void remove();}public interface Aggregate{ public Iterator createIterator();} 由于 Lou 菜单是基于 ArrayList 实现的（即它的基类是 ArrayList，因此，它已经有自己的迭代器模式实现。），因此我们只需要 Mel 菜单实现 Aggregate 接口： 1234567891011public class Mel implements Aggregate{ MealItem[] mealItems; /* 其他方法 */ public Iterator createIterator(){ return new MelIterator(this); }} 然后为 Mel 菜单类创建对应的迭代器类 ConcreteIterator，并实现迭代器接口 Iterator： 12345678910111213141516171819202122232425262728public class MelIterator implements Iterator{ MealItem[] items; int position = 0; public MelIterator(Mel mel){ this.items = mel.getMenu(); } public Object next(){ MealItem mealItem = items[position]; position += 1; return mealItem; } public boolean hasNext(){ if(position &gt;= items.length || items[position] == null){ return false; } else{ return true; } } public void remove(){ /* 实现忽略 */ }} 最后，我们重新实现一下侍者打印菜单的功能： 1234567891011121314151617181920212223242526272829303132333435public class Waiter { Lou lou; Mel mel; Waiter(Lou lou, Mel mel){ this.lou = lou; this.mel = mel; } public void printMenu(){ Iterator louIterator = Lou.iterator(); Iterator melIterator = mel.createIterator(); /** * Waiter 无需知道 Lou 和 Mel 内部具体如何实现菜单， * 因为它知道它们都实现了迭代器接口 Iterator。 */ while(louIterator.hasNext()){ System.out.println(louIterator.next()); } while(melIterator.hasNext()){ System.out.println(melIterator.next()); } } public void printMenu(Iterator iterator){ // 迭代器模式使得 Waiter 还可以接收其他实现了 Iterator 接口的迭代器，增加了代码的灵活性 while(iterator.hasNext()){ System.out.println(iterator.next()); } }} 可以看出，采用迭代器模式实现的侍者的代码，与 Lou 和 Mel 菜单内部具体如何实现无关，即实现解耦。","link":"/2020/01/02/Design Patterns - Iterator/"},{"title":"Design Patterns - Decorator","text":"本文将介绍设计模式中的装饰器模式（Decorator）。 定义该模式动态地将责任附加到对象上，若要扩展功能，装饰者提供了比继承更有弹性的替代方案。该模式适用于需要经常动态地为对象添加或删除责任（属性）的情况。 从图中可知，被装饰对象和装饰者有相同的类型。 原则 对扩展开放，对修改关闭 被装饰对象和装饰者有相同的类型 实现装饰者和被装饰者继承同一个基类，同时装饰者中增加一个变量记录被装饰者的引用，每次需要装饰的时候给被装饰者“套一层”装饰者再返回即可。 应用实例我们以一个咖啡馆的例子来看一下如何应用装饰器模式。假设我们有一个 Beverage 的饮料基类： 123456public abstract class Beverage { private String description; public getDescription(){ return description; } public abstract double cost(){ /* ... */ }} 现在要调制各种饮料，有的饮料要加奶，有的要加糖，有的要加可可……假如我们直接进行继承，则会爆炸性的产生大量子类，大大增加后期维护成本。而且通过继承来确定类只能在编译时静态决定，不能在运行时动态地为对象添加或删除责任（属性）。 一个健壮的系统设计应该是对扩展开放，对修改关闭，而装饰器模式则实现了这一点。 首先我们看一下如何用装饰器模式来构建饮料： 我们看一下装饰器模式实现饮料的 UML 类图： 下面我们来看看装饰器模式实现饮料的代码： 首先是饮料基类(被装饰者)和调料基类（装饰者）： 12345678910111213141516// 饮料基类(被装饰者)public abstract class Beverage { private String description = &quot;Unknown Beverage&quot;; public getDescription(){ return description; } // 此方法在子类中实现 public abstract double cost(){ /* ... */ }}// 调料基类（装饰者）// 装饰者必须和被装饰者同类，因此 CondimentDecorator 继承自 Beveragepublic abstract class CondimentDecorator extends Beverage { // 所有调料装饰者必须重新实现此方法 public abstract String getDescription();} 接下来我们再实现一些具体饮料（被装饰者），就以浓缩咖啡 Espresso 为例： 12345678public class Espresso extends Beverage { public Espresso() { description = &quot;Espresso&quot;; } public double cost(){ return 1.99; }} 然后就是一些具体的调料（装饰者）的代码，以摩卡 Mocha 为例： 1234567891011121314151617public class Mocha extends CondimentDecorator { // 用于记录被装饰者的引用 Beverage beverage； public Mocha(Beverage beverage){ this.beverage = beverage; } public String getDescription() { return beverage.getDescription() + &quot;, Mocha&quot;; } public double cost(){ return .20 + beverage.cost(); }} 最后，我们来一杯原味和一杯加摩卡的浓缩咖啡： 12345678910111213141516public class StarbuzzCoffee { public static main(String args[]){ // 原味 Beverage beverage1 = new Espresso(); System.out.println(beverage1.getDescription() + &quot; $&quot; + beverage1.cost()); // 加摩卡 // 被装饰者（浓缩咖啡 Espresso） Beverage beverage2 = new Espresso(); // 装饰者（Mocha）装饰被装饰者 beverage2 = new Mocha(beverage2); System.out.println(beverage2.getDescription() + &quot; $&quot; + beverage1.cost()); }} 这样，我们就成功地使用观察者模式制造出了一杯原味和一杯加摩卡的浓缩咖啡，舒服了～","link":"/2019/12/18/Design Patterns - Decorator/"},{"title":"Design Patterns - Singleton","text":"本文将介绍设计模式中的单例模式（Singleton）。 定义该模式确保一个类只有一个实例，并且提供一个全局访问点。 原则 私有化构造器 注意多线程环境下的对象创建 利用静态变量来记录 Singleton 类的唯一实例，并用 volatile 修饰，以防止在多线程环境下编译器对该实例创建时的字节码进行“优化”，即字节码重排序，同时 volatile 还能提高该对象的可见性 如果程序中存在多个加载器，需要自行指定类加载器，并指定同一个类加载器 实现实现单例模式的关键在于保证一个对象只能被实例化一次。 为什么不能用全局变量实现单例模式？虽然使用全局变量、静态类变量、静态方法和访问修饰符可以实现全局变量，但这就意味着程序一开始的时候就需要创建这些对象，万一这些对象比较耗资源，则会对程序造成不良影响；而且全局变量无法确保只有一个实例。全局变量也变相鼓励开发人员用许多全局变量指向许多小对象来造成命名空间污染，而单例模式不鼓励这样的现象。 单例模式的两种实现方式 懒汉式：等到需要的时候再实例化对象。 饿汉式：一开始就实例化对象，如果资源吃紧的情况下不建议使用这种情况造成资源浪费。 下面以“懒汉式”的双重检查加锁方式来实现一个单例模式类： 123456789101112131415161718192021222324public class Singleton { /* 注意使用 volatile 和 static 进行修饰，防止在多线程环境下编译器对字节码进行重排序导致实例对象被重复创建，并提高该对象的可见性 */ private volatile static Singleton instance; // 私有化构造器 private Singleton(){} public static Singleton getInstance(){ // 先判断实例是否存在，如果不存在则进入同步区，同时避免多次执行 synchronized 操作影响性能 if(instance == null){ // 避免多个线程同时进行实例检查与创建 synchronized(Singleton.class){ // 同步区区内再次检查实例是否存在 if(instance == null){ instance = new Singleton(); } } } return instance; }} ⚠️ 双重检查加锁方式不适用于 JDK 1.4 及更早版本的 Java 程序中！ 应用实例单例模式广泛应用于我们的日常开发中：线程池（ThreadPool）、缓存（Cache）、对话框、处理偏好设置和注册表（registry）的对象、日志对象、打印机和显卡等设备的驱动程序的对象等等。","link":"/2019/12/18/Design Patterns - Singleton/"},{"title":"Design Patterns - Strategy","text":"本文将介绍设计模式中的策略模式（Strategy）。 定义该模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。 原则 封装变化 多用组合，少用继承 针对接口编程，不针对实现编程 实现将变化的部分（算法）抽象出来封装成接口类型，并在基类中以借口类型进行声明，再以具体类型实现对应接口类型，并用组合等方式实现具体子类。 应用实例假设我们有 Duck 基类，要求针对不同类型的鸭子的飞行和叫声两种行为进行实现。请注意，有的鸭子不会飞，有的鸭子不会叫。如果我们直接通过在基类中定义抽象方法： 12345abstract public class Duck { public Duck(); abstract public fly(); abstract public quack();} 然后再由具体类型鸭子继承基类 Duck，则会导致默认每种鸭子都会飞，每种鸭子都会叫，显然不符合要求。但我们再看看需求，其实只是需要对不同鸭子类型的飞行和叫两种行为进行不同实现即可。我们不妨把这两种行为封装成两个独立的类型，因此我们把鸭子的飞行和叫分别定义为两个接口类型：FlyBehavior 和 QuackBehavior（定义为接口而非普通 class 类是可以避免 Java 中的单继承限制，提高程序拓展性）： 1234567interface FlyBehavior { public fly();}interface QuackBehavior { public quack();} 然后我们修改基类，注意我们要面向接口编程，而不是面向具体实现编程： 12345abstract public class Duck { public Duck(); FlyBehavior flyBehavior; QuackBehavior QuackBehavior;} 然后定义两种不同的飞行方式：用翅膀飞 FlyWithWings 和 不会飞 FlyNoWay；定义两种不同的叫声方式：叫 Quack 和 不会叫 MuteQuack； 1234567891011121314151617181920212223public class FlyWithWings implements FlyBehavior { public fly(){ System.out.println(&quot;I can fly!&quot;); }}public class FlyNoWay implements FlyBehavior { public fly(){ System.out.println(&quot;I can&apos;t fly!&quot;); }}public class Quack implements QuackBehavior { public quack(){ System.out.println(&quot;Quack！&quot;); }}public class MuteQuack implements QuackBehavior { public quack(){ System.out.println(&quot;Silent！&quot;); }} 然后我们造一种会飞不会叫的鸭子 MiniDuck： 123456public class MiniDuck extends Duck { public Duck(){ flyBehavior = new FlyWithWings; QuackBehavior = new MuteQuack() }} 这样，我们就成功地应用策略模式造出一种会飞不会叫的鸭子 MiniDuck 了！下面是应用策略模式设计后的 UML 类图：","link":"/2019/12/16/Design Patterns - Strategy/"},{"title":"Design Patterns","text":"本文将介绍软件开发中使用的主要设计模式，参考了 Freeman &amp; Freeman 所著的 Head First Design Patterns 。 OO 基础：抽象、封装、多态、继承。良好的 OO 设计必须具备可复用、可扩充、可维护三个特性，但仅仅知道指导 OO 基础并不足以让你设计出良好的 OO 系统，而设计模式则可以帮助你解决这个问题。 设计模式是大量开发者在长期的开发中总结出来的经验，具有较强的普适性，是开发人员的共享语言，能够最大化沟通的价值。设计模式将帮助我们开发出健壮、易维护、易拓展的系统。 OO 原则 封装变化 多用组合，少用继承 针对接口编程，不针对实现编程 交互对象之间尽可能采用松合设计，使得对象之间的相互依赖降到最低，使得 OO 系统更有弹性 对扩展开放，对修改关闭 依赖抽象，不要依赖具体类（依赖倒置原则）。即不能让高层组件依赖于低层组件，而且不管是高层还是低层组件，两者都应该依赖于抽象。 变量不可以持有具体类的引用：如果使用 new 关键字，就会持有具体类的引用。这时可以改用工厂模式来避开这种做法。 不要让类派生自具体类：如果派生自具体类，就会依赖于具体类。因此请派生自抽象类/接口。 不要覆盖基类中已经实现的方法：如果覆盖基类已经实现的方法，那么该基类就不是一个真正适合被继承的抽象。基类中已经实现的方法应该在子类中被共享。 当需要将发出请求的对象和执行请求的对象解时，使用命令模式 最小知道原则：设计一个系统，不管是任何对象，都要注意它所交互的类有哪些，并注意它们是如何交互的。如何才能避免违反该原则呢？我们应该尽可能做到只调用属于以下范围的方法： 该对象本身的方法 被当成方法的参数而传递进来的对象的方法 此方法创建或实例化的任何对象的方法 对象的任何组件的方法 单一职责原则：一个类应该只有一个引起变化的原因。类的每个责任都有改变的潜在区域。超过一个责任，意味着超过一个改变的区域。 设计模式创建型（Creative）工厂模式（Factory）简单工厂模式（Simple Factory）事实上，简单工厂并不属于设计模式，简单工厂只是将创建对象的方法移到一个单独的类中，并依赖于创建对象所必需实现的一个接口上。 工厂方法模式（Factory Method）该模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个，工厂方法让把类实例化推迟到子类。 抽象工厂模式（Abstract Factory）该模式提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。 建造者模式（Builder）原型模式（Prototype）单例模式（Singleton）该模式确保一个类只有一个实例，并且提供一个全局访问点。 结构型（Constructive）适配器模式（Adapter）该模式将一个类的接口转换成客户期望的另一个接口，让原本接口不兼容的类可以合作无间。 桥接模式（Bridge）组合模式（Composite）该模式允许将对象组合成树形结构来表现“整体/部分”的层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。 装饰器模式（Decorator）该模式动态地将责任附加到对象上，若要扩展功能，装饰者提供了比继承更有弹性的替代方案。 外观模式（Facade）该模式提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。 享元模式（Flyweight）代理模式（Proxy）行为型（Behavioral）责任链模式（Chain of Responsibility）命令模式（Command）该模式将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。 迭代器模式（Iterator）该模式提供一种方法顺序访问一个聚合对象种的各个元素，而不是暴露其内部的表示。 中介者模式（Mediator）备忘录模式（Memento）观察者模式（Observer）该模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。 访问者模式（Visitor）策略模式（Strategy）该模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。 状态模式（State）模板方法模式（Template Method）该模式在一个方法中定义一个算法骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。 解释器模式（Interpreter）","link":"/2019/12/16/Design Patterns/"},{"title":"面经","text":"在此记录部分春招找实习的面试记录。 酷家乐（无回音～凉）电话一面（2019/05/13 14:00-14:37）面试官：“准备纸和笔！！！” 自我介绍 项目 面试官直接说不用讲了，跳过（估计太菜了） IPC方式（一开始脑子有点懵，说了匿名管道、命名管道、共享内存、信号量，然后说不记得了…..,.） 线程和进程的区别？ 代码执行单元是？（线程） 是线程还是进程申请资源？（进程） Java线程状态有哪些？ Blocking状态和Waiting状态有什么区别？（这个我不太确定，就说了waiting是需要别的线程唤醒恢复Runnable状态，blocking是因为互斥资源竞争失败导致的，所以需要当这个资源重新可用的时候才能恢复Runnable状态。我不确定啊，等下去核验一下答案…….） 介绍一下死锁（我说了死锁的条件） 链表判断是否有环 M*N的格子组成的一个园子，如果有相连通（上下左右）的8个格子，则这8个格子组成一个水坑。问怎么求这个院子里有几个水坑？（这题我不太确定，瞎说了个一个个遍历+DFS） [1,8,6,2,5,4,7,3]建立一个小顶堆 hash原理说一下？怎么解决hash冲突的？ 说一下你Java都学了什么？（free-style：我就扯了一下并发的线程池（参数、拒绝策略、ctl…）本来还想扯点synchronized之类的，他说行了） 浏览器输入网址到页面呈现全过程 cookie和session的区别？ 介绍一下网络层的滑动窗口协议（凉凉，脑子突然死机，就说它是用来拥塞控制之类的，具体忘了……） 10亿不重复数据里面找是否存在某个数字？ 你有什么问题？ 电话二面（技术专家面）（2019/05/15 10:30-10:57） OS的段式和页式区别？ 页的大小？如何计算？ 软连接和硬连接区别？ 什么是中断？ 中断原理？ 中断应用场景？ Java多线程会占满CPU吗？ 线程用户态到内核态的切换过程？ Linux命令？ pop命令查看进程？ 路由算法？OSPF？RIP？ 弗洛伊德算法？ A类IP地址的范围？ 讲一讲滑动窗口？ 为什么滑动窗口要3次而不是4次？ 你Java好像学得挺深入的，但为什么不把计算机底层知识学扎实，不深入学习一下？（凉） 随手科技一面（2019/05/27 19:00-19:50） 面向对象的三个基本特征？ 重写和重载的区别？ Java实现多线程的方式？ 线程池了解吗？ 什么是死锁？ 线程安全问题？ 如何实现线程安全？ 介绍一下集合类？ hashset的键的数据类型如果是自定义引用类型的话有什么要求？ jdk工具类了解吗？ 看过jdk源码吗？ 类加载机制？ GC算法有哪些？ GET和POST区别 介绍一下三次握手和四次挥手？ 三次握手第三次握手的作用？ MySQL优化？ 索引？ Redis基本数据类型？ Redis除了作为缓存以外应用有哪些？ Redis怎么实现多线程安全？ Redis是单线程吗？为什么？ 缓存击穿？ 介绍一下项目中如何实现全局唯一ID吧 介绍一下redis分布式锁？ Redis的过期算法有哪些？ 中间件了解吗？ 平时看技术书和博客吗？ 平时项目组内出现分歧怎么解决？ 还有什么问题吗？ 4399（OFFER）一面（2019/06/05 09:50-10:05） 如何获得AUTO_INCREMENT的下一个自增值？ 如何获得最新插入的一条记录？ 数据库索引介绍一下 InnoDB与MySIAM引擎区别？ InnoDB引擎优点？ MySQL对于上千万条数据存储有何优化方法？ 分页具体操作？ Cookie与Session的区别？ SessionID存在哪里？ Java堆栈的区别？它们在创建时间上有什么区别？ 二面（HR面）（2019/06/13 10:45-11:00）聊天流，略～ 三面（2019/06/14 9:30-9:41） 4399每一面每一题都会有记录的！一面没答出来的题一定要弄懂，会重新问的！！！ 自我介绍 项目介绍 如何获得AUTO_INCREMENT的下一个自增值？ Http头 JSON优缺点（没答出缺点 T_T） TCL（OFFER）技术面 （2019/06/07 16:50-17:15） Java基本数据类型 Java基本数据类型字节大小 String是不是基本数据类型？ 从对象类型的角度分析String为什么不是基本数据类型？ String有没有reverse()方法？ 你如何自己实现一个字符串逆序？ StringBuilder与StringBuffer与String区别？ String为什么要是final关键字修饰的？ 介绍一下Java的堆栈 介绍一下GC 项目介绍 Session Token 哈啰出行（已挂）技术面 （2019/06/10 10:00-10:28） 项目 大学计算机核心课程哪门最重要？ 数组和链表的区别？ 现场写代码：链表实现栈","link":"/2019/05/28/Interview Record/"},{"title":"LeetCode | 136.Single_Number -- The Application of XOR 异或的应用","text":"最近在LeetCode中遇到一个在线性时间复杂度下求[136] Single Number 单身数的题，乍看之下很简单，通常思维是直接进行排序后，遍历一次数组，便能将仅出现一次的单身数轻易求出。但排序操作势必带来一定的时间复杂度增加，甚至导致非线性时间复杂度，因此我们试图寻找一个更加简单、高效和精妙的方法，这时，我发现一种利用异或找出单身数的方法。由于目前水平有限，异或等位操作的方法使用较少，因此在此记录一下。 问题引入 Given a non-empty array of integers, every element appears twice except for one. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? 异或特性 0异或任何数，得到这个数本身 任何数异或本身，得到0 异或满足结合律 异或满足交换律 问题解析利用异或的特性，本题中由于除了单身数以外的所有数字都是成对出现的，因此仅需将所有数字异或在一起，最终结果必为所求单身数。123456789101112131415161718例: [4,1,2,1,2]int result = 0for(int elem: [4,1,2,1,2]) result ^= elem; 具体异或过程result:0 =&gt; 0004 =&gt; 100 =1001 =&gt; 001 =1012 =&gt; 010 =1111 =&gt; 001 =1102 =&gt; 010 =100 =&gt; 4 源码12345678class Solution { public int singleNumber(int[] nums) { int result = 0; for(int elem : nums) result ^= elem; return result; }} 查看完整源码","link":"/2019/02/28/LeetCode-136-Single-Number-The-Application-of-Bit-Manipulation/"},{"title":"Design Patterns - Template Method","text":"本文将介绍设计模式中的模板方法模式（Template Method）。 定义该模式在一个方法中定义一个算法骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。 模板方法模式 VS 策略模式 模板方法模式：定义的是一个算法大纲骨架，而由子类定义其中某些步骤内容，可以在不同子类算法中的个别步骤不同，但算法的结构保持不变。它通过继承让子类实现算法中的某些步骤。它的一个算法的实现依赖于超类中的方法实现，因为子类只实现算法的一部分。 策略模式：定义一个算法家族，并让算法可以互换。它是通过对象组合的方式，让客户可以选择算法实现。它实现算法不依赖于任何其他类，整个算法由本类实现。 原则 将决策权放在高层模块中，以便决定如何以及何时调用低层模块。低层组件可以参与计算，但低层组件绝不可以直接调用高层组件；高层组件控制合适以及如何让低层组件参与。 实现通过将算法相同的部分提取出来，并在超类中实现（一般声明为 final 方法），而需要根据子类而变的方法在超类中声明为抽象方法，由具体子类来实现。在算法的每一部分基本都可以拆成一个方法来实现。 钩子：模版方法中部分方法实现可以预留为空或者只是简单返回布尔值的，且子类可选覆盖实现的方法称为钩子。子类可以选择覆盖实现或者不覆盖实现这些方法。钩子可以让子类实现算法中的可选部分，让子类有机会对模板方法中某些即将或刚刚发生的步骤作出反应。 应用实例现在，我们通过一个泡柠檬茶和泡咖啡的例子来理解一下模板方法模式。 首先，柠檬茶和咖啡一大相似点就是都内含咖啡因。因此，我们可以设计一个咖啡因饮品 CaffeineBeverage 的基类，再由柠檬茶 Tea 和咖啡 Coffee 继承。 泡柠檬茶步骤： 把水煮沸 boilWater() 用沸水冲泡茶叶 steepTeaBag() 将咖啡倒进杯子 pourInCup() 加柠檬 addLemon() 泡咖啡步骤： 把水煮沸 boilWater() 用沸水冲泡咖啡 brewCoffeeGrinds() 将咖啡倒进杯子 pourInCup() 加糖和牛奶 addSugarAndMilk() 我们可以发现，泡柠檬茶和泡咖啡的步骤大体相似。因此，我们将让它们共同的部分抽取出来： 把水煮沸 boilWater() 用沸水冲泡 brew() 将饮品倒进杯子 pourInCup() 加调味品 addCondiments() 现在，我们通过模板方法用代码来实现一下它们： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public abstract class CaffeineBeverage { void final prepareRecipe(){ boliWater(); brew(); pourInCup(); // 添加一个可选的挂钩 if(customerWantsCondiments()){ addCondiments(); } } abstract void brew(); abstract void addCondiments(); private final void boilWater(){ System.out.println(&quot;Boiling water&quot;); } private final void pourInCup(){ System.out.println(&quot;Pouring into cup&quot;); } // 可选挂钩 protected boolean customerWantsCondiments(){ return true; }}public class Tea extends CaffeineBeverage { public void brew(){ System.out.println(&quot;Steeping the tea&quot;); } public void addCondiments(){ System.out.println(&quot;Adding lemon&quot;); }}public class Coffee extends CaffeineBeverage { public void brew(){ System.out.println(&quot;Dripping coffee through filter&quot;); } public void addCondiments(){ System.out.println(&quot;Adding sugar &amp; milk&quot;); } // 覆盖挂钩 protected boolean customerWantsCondiments(){ String answer = getUserInputs(); if(answer.toLowerCase().startsWith(&quot;y&quot;)){ return true; } else{ return false; } } private String getUserInputs(){ String answer = null; System.out .println(&quot;Would you like milk and sugar with you coffee? (y/n)&quot;); Scanner in = new Scanner(System.in); answer = in.nextLine(); if(answer == null){ return &quot;n&quot;; } else if(answer.equals(&quot;y&quot;) || answer.equals(&quot;n&quot;){ return answer; } else{ System.out.println(Illegal input!); return &quot;n&quot;; } }} 这样，我们就通过模板方法模式实现了一个含咖啡因饮料的代码编写。","link":"/2019/12/26/Design Patterns - Template Method/"},{"title":"MySQL的几种删除表的方法","text":"在此记录部分MySQL的几种删除表的方法及其区别。 MySQL删除表方法DROPDROP 方法适用于完全放弃当前表，删除表全部数据和表结构，立刻释放磁盘空间，不管是 Innodb 和 MyISAM DROP TABLE student; TRUNCATETURNCATE 适用于仅删除当前表中所有的数据，但保留表结构，删除后立刻释放磁盘空间，不管是 Innodb 和 MyISAM TRUNCATE TABLE student; DELETE / DELETE FROMDELETE 删除表中数据，但保留表结构，删除操作会被记录到binlog日志中，可以回滚；而且它可以与 WHERE 连用，进行条件查询删除特定行 如果只针对一张表进行删除，则 DELETE 和 DELETE FROM 效果一样；如果需要联合其他表，则需要使用DELETE FROM 对于DELETE操作，它会删除表全部数据，表结构不变，对于 MyISAM 会立刻释放磁盘空间，InnoDB 不会释放磁盘空间 DELETE FROM student; DELETE 操作以后，使用 OPTIMIZE TABLE table_name 会立刻释放磁盘空间，不管是 InnoDB 还是 MyISAM 对于与 WHERE 连用的 DELETE FROM 的带条件的删除，表结构不变，不管是 innodb 还是 MyISAM 都不会释放磁盘空间 DELETE FROM student WHERE T_name = &quot;张三&quot;; DELETE FROM 表以后虽然未释放磁盘空间，但是下次插入数据的时候，仍然可以使用这部分空间 TRUNCATE VS DELETE 事务：TRUNCATE 删除后不记录 binlog 日志，因此不可以回滚，更不可以恢复数据；而 DELETE 则记录 binlog，所以是可以回滚。因此 TRUNCATE 相当于保留原 MySQL 表的结果，重新创建了这个表，所有的状态都相当于新的，而 DELETE 的效果相当于一行行删除，即可以回滚 效果：效率上 TRUNCATE 比 DELETE 快，而且 TRUNCATE 删除后将重建索引（新插入数据后id从0开始记起），而 DELETE 不会删除索引 （新插入的数据将在删除数据的索引后继续增加） TRUNCATE 不会触发任何 DELETE触发器 返回值：DELETE 操作后返回删除的记录数，而 TRUNCATE 返回的是0或者-1（成功则返回0，失败返回-1）","link":"/2019/06/05/MySQL的几种删除表的方法/"},{"title":"Hello World","text":"欢迎来到 LEE YAT-SAN 地带，这是记录他在编程过程中所产生的思考、灵感与得出的经验的唯一网站。 Welcome to LEE YAT-SAN‘s zone, which is the only website recording his thoughts, inspirations and experiences on programming.","link":"/2019/03/03/hello-world/"},{"title":"JAVA 整型溢出问题","text":"最近在做一道经典算法水题：整数反转问题时，无意间发现自己没有仔细学习下Java数据类型的溢出问题。因此，在此以整型(Integer)为例，简要谈谈我对Java整型溢出问题的理解。其中参考了部分文献资料以及网上优秀技术博客。新人学识浅陋，若存纰漏错误，欢迎指正🙏！ 基本知识在讨论Java基本数据类型溢出问题之前，我们首先要了解Java各种基本数据类型的数值范围。详细见下图。因此，在处理大量数值问题时，我们要各位注意Java的各种基本数据类型的数值范围，新手程序猿很容易忽视这一点。还有一点需要注意的是，对于有符号的数据类型，其存储单元的首位存储符号：1为负，0为正。但补码消除了消除了+0和-0的冗余和歧义，使0只用1个表达式：100000000 00000000 00000000 00000000 因此负数范围比正数范围多1个。 Java基本数据类型溢出表现说了那么多，终于进入到类我们的主题。现在让我们来看看Java基本数据类型发生溢出时会出现什么情况。这里以整型为例。 视频快速了解 具体表现编程设值期间在编程过程中，当我们输入的数值超过对应基本数据类型的合法表示范围时，当前主流IDE都基本能够识别并在编译过程中跑出错误，这里以我的IntelliJ IDEA为例，代码： 例112int a = 20000000000;System.out.println(\"a= \"+a); 如上所示，我赋予a一个超过Integer合法范围的数值（200亿），则抛出如下错误1Error:(12, 17) java: 过大的整数: 20000000000 运行输出期间（动态语义错误）然后我们再来看看程序运行期间所产生的动态语义错误： 例21234int a = 2000000000;int b = 2*a;System.out.println(\"a= \"+a);System.out.println(\"b= \"+ b); 如上代码，a为2000000000（20亿），正常输出，说明没有超过Integer的合法表示范围，没有出现溢出情况。按照一般思维，b为2倍的a，应该输出的是4000000000（40亿），然而实际情况却不是这样：12a= 2000000000b= -294967296 由上面可以看出，b并没有按照预期输出4000000000，也没有抛出异常，而是输出了一个负值。 例3让我们再来看看刚好超过Integer合法范围的情况1234System.out.println(Integer.MAX_VALUE);System.out.println(Integer.MIN_VALUE);System.out.println(Integer.MAX_VALUE+1);System.out.println(Integer.MIN_VALUE-1); 输出：12342147483647-2147483648-21474836482147483647 由此，我们可以得出推论： 在恰好要溢出的情况下：当结果超出了integer的最大表示范围时，结果变成负数当结果超出了integer的最小表示范围时，结果变成正数 Java基本数据类型溢出机制为什么会出现上述情况呢？我们再回忆下最开头我们所讲的：”对于有符号的数据类型，其存储单元的首位存储符号：1为负，0为正”。在例2中，因为4000000000超出了integer的合法表示范围，使得计算结果二进制表示时占用了存储单元的第一位符号位，使得符号位由0变为1，因此输出结果为负数。例3同理，在此不再赘述。让我们再来看看下面这个例子： 例4123456int num = 907654321;System.out.println(\"1：\"+Integer.toHexString(num));System.out.println(\"2：\"+Long.toHexString(num * 16L));System.out.println(\"3：\"+num * 16L);System.out.println(\"4：\"+(int)((num * 16L) &amp; 0xffffffff));System.out.println(\"5：\"+num * 16); 结果：123451：3619b4b12：3619b4b103：145224691364：16375672485：1637567248 我们可以得知，num*16的结果是超过Integer的合法表示范围的，但奇怪的是，它似乎与上面的推论相悖：两个int类型的数相乘，溢出后没有变为负数。这是为什么呢？这是因为它在溢出后又发生过至少1此溢出，使得符号位由1又改为0，使得结果为正。而由3可以看出：通过类型提升来输出正确结果，详细将在下一节详细介绍。而从4和5中我们可以发现，实际上溢出后输出的结果是对底32位（因为Integer的存储单位为32位）截断后的结果。查阅The Java Language Specification (JLS)§4.2.2, “Integer Operations” ，得知: The built-in integer operators do not indicate overflow or underflow in any way. Integer operators can throw a NullPointerException if unboxing conversion of a null reference is required. Other than that, the only integer operators that can throw an exception are the integer divide operator / and the integer remainder operator %, which throw an ArithmeticException if the right-hand operand is zero, and the increment and decrement operators ++ and – which can throw an OutOfMemoryError if boxing conversion is required and there is insufficient memory to perform the conversion. 由上可知，在运行期间发生的数据溢出不会抛出任何异常，而是直接截断输出。对于整型数据，则是截断输出低32位数据。 检测方法JDK8的Math为我们实现了对基本运算的结果是否溢出判断：12345public static int addExact(int x, int y)public static int subtractExact(int x, int y)public static int multiplyExact(int x, int y)//int型乘法public static int multiplyExact(long x, long y)//long型乘法...... 防止溢出措施 使用前提条件;即范围检查输入使得溢出是不可能的 使用上述检测方法 类型提升：byte ➡ short, int, long, float, doubleshort ➡ int, long, float, doublechar ➡ int, long, float, doubleint ➡ long, float, doublelong ➡ float, doublefloat ➡ double 参考文献 [1] java int溢出总结[2] Widening Primitive Conversion[3] NUM00-J. Detect or prevent integer overflow","link":"/2019/02/16/JAVA整型溢出问题/"},{"title":"Boyer–Moore majority vote algorithm 摩尔投票法","text":"最近在LeetCode中遇到一个求众数的题，乍看之下很简单，但尝试过几种方法求解后发现没有时间与空间复杂度没有到达令人满意的水平。那么是否存在一种使用一次遍历且空间复杂度足够小的算法呢？这时，就引出接下来要讨论的摩尔投票法(Boyer–Moore majority vote algorithm)。 问题引入LeetCode 169. Majority Element: 给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于⌊n/2⌋的元素。你可以假设数组是非空的，并且给定的数组总是存在众数。 算法性能比较在讨论摩尔投票法之前，先看看我尝试过的几种算法的性能差异。 方法 时间复杂度 空间复杂度 先排序，再统计出现次数最多的元素 O(nlgn) O(n) 哈希表统计各元素出现次数 O(n) O(n) 先排序，出现次数过半的众数一定出现在数组中间位（太暴力了，基本无算法技巧） O(nlgn) O(1) 摩尔投票法 O(n) O(1) 由此可见，摩尔投票法在时间与空间复杂度均优于前述算法。 摩尔投票法原理摩尔投票法(Boyer–Moore majority vote algorithm)是一种使用线性时间与固定空间来寻找一个序列中的众数的算法。摩尔投票算法是基于这个事实：每次从序列里选择两个不相同的数字删除掉（或称为“抵消”），最后剩下一个数字或几个相同的数字，就是出现次数大于总数一半的那个。通俗的来讲，对候选甲乙投票，如果甲得一票，乙得一票，结果等价于甲乙都没有得票，即上述所谓的”抵消”。将这个两人投票的问题推广至对n人投票的问题，得票数过半者当选，即为上述求众数问题。 摩尔投票法最简单的形式中(即n/2的情况)，只需要两个变量result和counter，其中result记录当前暂时无法”抵消”的数字，或者是当前暂时”胜出”的数字，而counter则记录这个数字当前经过抵消后的剩余票数（即暂时胜出票数）。 摩尔投票法过程 初始: 初始化result为数组第一个元素，counter计数为0。STEP1: 从当位置遍历数组，对于数组中每个元素：如果当前遍历元素curr == result，则++counter，即记得一票；如果当前遍历元素curr != result，则–counter，即抵消一票STEP2: 如果当前counter == 0， 则表明当前result所记元素暂时败选，也同时说明原数组序列中截至该元素的子数组序列不存在众数，或者说不存在数量超过子数组序列长度一般的众数，因此换取新的元素进行统计，通常将result = curr，然后返回STEP1，从当前遍历位置继续遍历数组寻找众数。STEP3: 遍历完成，输出结果。 对于上述过程举一个例子：{1,2,1,3,1,1,2,1,5} Initialize：result = 1， counter = 0 curr = 1： result = 1 =&gt; result == curr =&gt; counter = 1 curr = 2： result = 1 =&gt; result != curr =&gt; counter = 0 =&gt; result = curr =&gt; result = 2, counter = 1 curr = 1： result = 2 =&gt; result != curr =&gt; counter = 0 =&gt; result = curr =&gt; result = 1, counter = 1; curr = 3： result = 1 =&gt; result != curr =&gt; counter = 0 =&gt; result = curr =&gt; result = 3, counter = 1; curr = 1： result = 3 =&gt; result != curr =&gt; counter = 0 =&gt; result = curr =&gt; result = 1, counter = 1; curr = 1： result = 1 =&gt; result == curr =&gt; counter = 2 curr = 2： result = 1 =&gt; result != curr =&gt; counter = 1 curr = 1： result = 1 =&gt; result == curr =&gt; counter = 2 curr = 5： result = 1 =&gt; result != curr =&gt; counter = 1 Output result;//1 摩尔投票法应用求众数(n/2) 169. Majority Element : SOLUTION12345678910111213141516171819202122class Solution { public int majorityElement(int[] nums) { if(nums.length == 0) return 0; else { int count = 1; int res = nums[0]; for(int num : nums){ if(num == res) ++count; else { --count; if(count == 0){ count = 1; res = num; } } } return res; } }} 求众数(n/3)(待更新) 参考文献 [1] Boyer–Moore majority vote algorithm[2] 如何理解摩尔投票算法？(@喝七喜)","link":"/2019/02/27/Moore-Voting-Algorithm/"},{"title":"计网 | 面试 | URL输入后的加载全过程","text":"最近复习计算机网络，本以为熟记于心，但一面才发现暴露了不少知识遗忘区，一些基本的计算机网络知识尚未理清。因此，在这总结一下经典面试题：URL从输入地址栏到加载出页面的全过程。 总体流程总的来说，URL从输入地址栏到浏览器加载出来大致经历如下步骤： 1234561. DNS解析2. TCP连接3. 发送HTTP请求4. 服务器处理请求并返回HTTP报文5. 浏览器解析渲染页面6. 连接结束 下面将对上述各步进行详细说明。 1. DNS解析 | 应用层当用户在浏览器中输入网址的地址后，浏览器要做的第一件事就是解析 DNS： 1. 检查浏览器缓存浏览器检查缓存中是否有域名对应的 IP，如果有就结束DNS解析过程。浏览器中的DNS缓存有时间和大小双重限制，时间一般为几分钟到几个小时不等。DNS缓存时间过长会导致如果IP地址发生变化，无法解析到正确的IP地址；时间过短会导致浏览器重复解析域名。 2. 检查系统缓存如果浏览器缓存中没有对应的IP地址，浏览器会继续查找操作系统缓存中是否有域名对应的DNS解析结果。我们可以通过在操作系统中设置hosts文件来设置IP与域名的关系。 3. 向本地DNS服务器发送解析请求如果还没有拿到解析结果，操作系统就会把域名发送给本地区的域名服务器（LDNS），LDNS 通常由互联网服务提供商（ISP）提供，比如电信或者联通。这个域名服务器一般在城市某个角落，并且性能较好。 DNS解析过程第3步实际上是一种递归解析过程 1. 查找DNS服务器缓存当拿到域名后，首先也是从缓存中查找，看是否有匹配的结果。一般来说，大多数的DNS解析到这里就结束了，所以LDNS/ISP DNS承担了大部分的域名解析工作。如果缓存中有IP地址，就直接返回，并且会被标记为非权威服务器应答。 2. 请求根服务器如果前面三步还没有命中DNS缓存，那只能到Root Server域名服务器中请求解析了。根域名服务器拿到请求后，首先判断域名是哪个顶级域名下的，比如 .com, .cn, .org等，全球一共 13 台顶级域名服务器。根域名服务器返回对应的顶级域名服务器（gTLD Server）地址。 3. 请求顶级服务器本地域名服务器（LDNS）拿到地址后，向gTLD Server发送请求，gTLD服务器查找并且返回此域名对应的 Name Server 域名服务器地址。这个Name Server通常就是用户注册的域名服务器，例如用户在某个域名服务提供商申请的域名，那么这个域名解析任务就由这个域名提供商的服务器来完成。 2. TCP连接 | 传输层3. 发送HTTP请求4. 服务器处理请求并返回HTTP报文5. 浏览器解析渲染页面6. 连接结束","link":"/2019/04/21/计网 | 面试 | URL输入后的加载全过程/"},{"title":"Design Patterns - Composite","text":"本文将介绍设计模式中的组合模式（Composite）。 定义该模式允许将对象组合成树形结构来表现“整体/部分”的层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。组合包含组件，组件有两种：组合与叶子节点元素。这是一种递归结构。使用组合结构，我们能把相同的操作应用在组合和个别对象上。换句话说，在大多数情况下，可以忽略对象组合和个别对象之间的差别。 原则组合模式不但要管理层次结构，还要执行菜单的操作，可以说是通过牺牲“单一职责原则”来换取透明性（transparency）。 透明性指的是通过让组件的接口同时包含一些管理子节点和叶子节点的操作，客户就可以将组合和叶子节点一视同仁。也就是说，一个元素究竟是组合还是叶子节点，对于客户来说都是透明的。 实现通过让组合与叶子节点元素继承自统一抽象类并实现对应方法，采用递归的形式实现。 应用实例现在，我们通过一个菜单的例子来理解一下组合模式。 现在有一个菜单，服务员 Waiter 需要能打印菜单所有菜品。但是菜单又分为 A、B、C 三个模块，其中 B 模块中又包含一个 Vegetarian 素食子模块，要求服务员还可以单独打印该模块，并且为未来可能增加其他新模块或者子模块预留实现可能。 那么，根据组合模式的思想，我们需要先实现一个组件抽象类 MenuComponent： 12345678910111213141516171819202122232425262728293031323334public abstract class MenuComponent{ public void add(MenuComponent menuComponent){ throw new UnsupportedOperationExeception(); } public void remove(MenuComponent menuComponent){ throw new UnsupportedOperationExeception(); } public MenuComponent getChild(int i){ throw new UnsupportedOperationExeception(); } public String getName(){ throw new UnsupportedOperationExeception(); } public String getDescription(){ throw new UnsupportedOperationExeception(); } public String getPrice(){ throw new UnsupportedOperationExeception(); } public boolean isVegetarian(){ throw new UnsupportedOperationExeception(); } public void print(){ throw new UnsupportedOperationExeception(); }} 然后，我们实现一下菜单项，即组合模式中的叶子节点元素： 1234567891011121314151617181920212223242526272829303132333435363738394041public class MenuItem extends MenuComponent { String name; String description; boolean vegetarian; double price; public MenuItem(String name, String description, boolean vegetarian, double price;){ this.name = name; this.description = description; this.vegetarian = vegetarian; this.price = price; } // 我们只需要覆盖叶子节点元素需要的方法即可 public String getName(){ return name; } public String getDescription(){ return description; } public String getPrice(){ return price; } public boolean isVegetarian(){ return vegetarian; } public void print(){ System.out.print(&quot; &quot; + getName()); if(isVegetarian()){ System.out.print(&quot; (v)&quot;); } System.out.print(&quot;, &quot; + getPrice()); System.out.print(&quot; --&quot; + getDescription()); }} 然后，我们实现一下菜单模块项，即组合模式中的组合： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Menu extends MenuComponent{ // 组合节点可以有任意数量的孩子 ArrayList menuComponents = new ArrayList&lt;MenuComponent&gt;(); String name; String description; public Menu(String name, String description){ this.name = name; this.description = description; } // 我们只需要覆盖组合需要的方法即可 public void add(MenuComponent menuComponent){ menuComponents.add(menuComponent); } public void remove(MenuComponent menuComponent){ menuComponents.remove(menuComponent); } public getChild(int i){ return (MenuComponent)menuComponents.get(i); } public getName(){ return name; } public getDescription(){ return description; } /** * 通过使用迭代器+递归的方式，将该模块中所有的子菜单及菜品打印出来 */ public void print(){ System.out.println(&quot;\\n&quot; + getName() + &quot;, &quot; + getDescription()); System.out.println(&quot;--------------------------&quot;) Iterator iterator = menuComponents.iterator(); while(iterator.hasNext()){ MenuComponent menuComponent = (MenuComponent)iterator.next(); menuComponent.print(); } }} 最后，我们编写服务员 Waiter： 1234567891011public class Waiter{ MenuComponent allMenus; public Waiter(MenuComponent allMenus){ this.allMenus = allMenus; } public void printMenu(){ allMenus.print(); }} 那么，对于单独打印素食菜菜单这个需求该如何实现呢？这个时候就需要迭代器模式+组合模式来实现。 那么，为了实现组合迭代器，我们需要对上面的代码进行一定的调整。首先是在组件类 MenuComponent 中添加 createIterator 方法，并在菜单模块 Menu 和菜单项 MenuItem 分别对其实现。 1234567891011121314151617181920212223242526public abstract class MenuComponent{ /* 其他代码保持不变，添加下面代码*/ public Iterator createIterator(){ throw new UnsupportedOperationExeception(); }}public class MenuItem extends MenuComponent { /* 其他代码保持不变，添加下面代码*/ public Iterator createIterator(){ return new CompositeIterator(); }}public class Menu extends MenuComponent{ /* 其他代码保持不变，添加下面代码*/ public Iterator createIterator(){ return new NullIterator(); }} 其中，由于菜单项是叶子节点元素，因此它没有迭代器，但为了保持透明性，我们还是让它返回一个 NullIterator ，它的作用就是没有迭代器，有两种实现方式。一种是让 createIterator() 返回 null，但这样有可能因为忘记检查 null 导致 NonPointerExeception；另一种是让 hasNext() 永远返回 false，这里推荐第二种实现方式。 123456789101112131415import java.util.Iterator;public class NullIterator implements Iterator { public Object next(){ return null; } public boolean hasNext(){ return false; } public void remove(){ throw new UnsupportedOperationException(); }} 然后，我们还要实现一下 CompositeIterator，它的作用是遍历组件内的菜单项，而且确保所有子菜单都被包括进来。 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.*;public class CompositeIterator implements Iterator{ Stack stack = new Stack&lt;Iterator&gt;(); public CompositeIterator(Iterator iterator){ stack.push(iterator); } public Object next(){ if(hasNext()){ Iterator iterator = (Iterator)stack.peek(); MenuComponent component = (MenuComponent)iterator.next(); if(component instanceof Menu){ stack.push(component.createIterator()); } return component; } else { return null; } } public boolean hasNext(){ if(stack.isEmpty()){ return false; } else { Iterator iterator = (Iterator)stack.peek(); if(!iterator.hasNext()){ stack.pop(); return hasNext(); } else { return true; } } } public void remove(){ throw new UnsupportedOperationException(); }} 最后，我们编写服务员 Waiter，为他添加素食菜单： 12345678910111213141516171819202122232425public class Waiter{ MenuComponent allMenus; public Waiter(MenuComponent allMenus){ this.allMenus = allMenus; } public void printMenu(){ allMenus.print(); } public void printVegetarianMenu(){ Iterator iterator = allMenus.createIterator(); System.out.println(&quot;/nVEGERTARIAN MENU ---&quot;); while(iterator.hasNext()){ MenuComponent menuComponent = (MenuComponent)iterator.next(); try { if(menuComponent.isVegetarian()){ menuComponent.print(); } } catch(UnsupportedOperationException e){} } }} 这样，我们就通过组合模式，外加迭代器模式，实现了一个拥有子菜单的菜单程序。","link":"/2020/01/04/Design Patterns - Composite/"},{"title":"Design Patterns - Factory","text":"本文将介绍设计模式中的工厂模式（Factory）。 定义简单工厂事实上，简单工厂并不属于设计模式，简单工厂只是将创建对象的方法移到一个单独的类中，并依赖于创建对象所必需实现的一个接口上。 工厂方法该模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个，工厂方法让把类实例化推迟到子类。 抽象工厂该模式提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。 原则 依赖抽象，不要依赖具体类（依赖倒置原则）。即不能让高层组件依赖于低层组件，而且不管是高层还是低层组件，两者都应该依赖于抽象。所谓高层组件，是由其他低层组件定义其行为的类。如下面的应用实例中， PizzaStore 是一个高层组件，因为它的行为由低层组件 Pizza 定义。通过以下方针可以帮助避免违反依赖 倒置原则： 变量不可以持有具体类的引用：如果使用 new 关键字，就会持有具体类的引用。这时可以改用工厂模式来避开这种做法。 不要让类派生自具体类：如果派生自具体类，就会依赖于具体类。因此请派生自抽象类/接口。 不要覆盖基类中已经实现的方法：如果覆盖基类已经实现的方法，那么该基类就不是一个真正适合被继承的抽象。基类中已经实现的方法应该在子类中被共享。 实现简单工厂简单工厂只是将创建对象的方法移到一个单独的类中，并依赖于创建对象所必需实现的一个接口上。 工厂方法通过将创建对象的方法声明为 abstract 抽象方法，将创建对象的行为转由具体子类来处理。所谓子类来“决定”具体创建对象，并不是指子类运行的时候再做决定，而是指在（基类）编写创建者的时候不知道需要具体创建什么子类，而是你一旦已经选定一个子类，那么也就已经决定了你要创建什么具体类型。 抽象工厂抽象工厂允许客户使用抽象的接口来创建一组相关的产品，而不需要知道或关心实际生产出的产品时什么。这样依赖，客户就从具体的产品中被解耦。 因为我们要创建的是一个产品家族，因此通常以抽象接口的方式定义抽象抽象工厂，由每个具体子类创建对应的家族产品。而在抽象工厂中创建（声明）的生产产品的方法，通常是以工厂方法的形式来实现的。可以这样简单的理解：抽象工厂是一组工厂方法所封装成的一个接口。 通过抽象工厂所提供的接口，可以创建产品的家族，利用这个接口编写代码，我们的代码得以从实际放入工厂解耦，以便在不同的上下文中实现各式各样的工厂，制造出不同的产品。因为代码从实际的产品中解耦，我们可以替换不同的工厂来取得不同的行为。 应用实例 Spring 中的 IoC、AOP 为了介绍工厂模式，我们以一个披萨店 PizzaStore 的例子来说明。现在有一个披萨店，里面售卖各种披萨。那么，点披萨的时候的代码如下： 12345678910111213141516public class PizzaStore{ Pizza orderPizza(String type) { Pizza pizza; if(type.equals(&quot;cheese&quot;)){ pizza = new CheesePizza(); } else if(type.equals(&quot;greek&quot;)){ pizza = new GreekPizza(); } else if(type.equals(&quot;Pepperoni&quot;)){ pizza = new PepperoniPizza(); } return pizza; }} 上面代码中，我们可以发现有一个严重的问题：一旦披萨店推出了新款披萨，那么就需要对披萨店类 PizzaStore 进行侵入式修改，违反了设计模式的“对修改关闭”的原则，因此，我们需要找一种新的方式来创建披萨，使得披萨店代码不再过度依赖于披萨的具体种类。因此，在这里需要强调一下，下面代码的终极目标，就是实现披萨店 PizzaStore 与具体披萨类型的代码解耦合。 简单工厂首先，最简单的方法就是将创建披萨的方法 orderPizza() 移出 PizzaStore ，这也就是所谓的简单工厂。我们来建立一个披萨工厂 SimplePizzaFactory ，使得它依赖于具体披萨种类，而 PizzaStore 依赖于它，这样依赖，我们就可以实现 PizzaStore 与具体披萨种类的解耦： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class PizzaStore{ private SimplePizzaFactory factory; public PizzaStore(SimplePizzaFactory factory){ this.factory = factory; } Pizza orderPizza(String type) { Pizza pizza = factory.createPizza(type); pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); return pizza; }}public class SimplePizzaStore{ Pizza createPizza(String type) { Pizza pizza; if(type.equals(&quot;cheese&quot;)){ pizza = new CheesePizza(); } else if(type.equals(&quot;greek&quot;)){ pizza = new GreekPizza(); } else if(type.equals(&quot;Pepperoni&quot;)){ pizza = new PepperoniPizza(); } else return null; pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); return pizza; }} 以上就是用简单工厂的方式实现披萨店的初步解耦优化。 可以用静态方法来定义一个简单工厂呢？我们可以使用静态方法来定义一个简单工厂方法，成为静态工厂。因为使用静态方法时不需要使用创建对象的方法来实例化对象。但它也有缺点，就是不能通过继承来改变创建方法的行为。 工厂方法那么，如果我们的披萨店规模再大一点呢？比如说它在纽约、芝加哥和加州都有分店而且每间分店生产的披萨不一样呢？这个时候简单工厂显然无法满足这种需求。也许你会说那我就以 SimplePizzaStore 为基类创建三个地方的子工厂 NYPizzaFactory、ChicagoPizzaFactory、CaliforniaPizzaFactory 呢？你可真是个小机灵鬼。但这样有个问题，就是披萨的生产流程的决定权到类具体工厂子类中，这样具体子类有可能可以通过拓展或者重写导致制作方法（如 prepare()、bake()、cut()、box()）不一样。而是事实上，我们所希望的只是具体子类工厂决定具体的披萨种类，而制作工艺应当保持一致，换句话说我们只希望具体工厂子类只是实现 createPizza() 中决定具体披萨种类的代码。因此我们希望有个框架，使得具体工厂在实现的时候局限于这个框架内，又有一定弹性来决定具体披萨种类。这个时候我们就需要运用工厂方法了。 和简单工厂不一样，工厂方法需要将 createPizza() 放回 PizzaStore 中，但要把它设置为抽象方法。这样一来，我们让每家分店都继承自 PizzaStore： 1234567891011121314public abstract class PizzaStore{ public orderPizza(String type){ Pizza pizza; pizza = createPizza(type); pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); } // 工厂方法 abstract Pizza createPizza(String type);} 从上面的代码来看，虽然 orderPizza() 对 Pizza 对象做了很多事情（如准备、烘培、切片、装盒）由于 Pizza 对象是抽象的，因此 orderPizza() 并不知道哪些世实际的具体类参与进来，从而实现了它与具体披萨类型的解耦。 这样一来，决定具体某一种披萨如何做的工作就转移到了具体的披萨店上，披萨店子类在继承 PizzaStore 的时候，只需要自行实现 createPizza() 即可： 123456789101112131415161718public class NYStylePizzaStore extends PizzaStore{ public Pizza createPizza(String type){ Pizza pizza = null; if(type.equals(&quot;cheese&quot;)){ pizza = new NYStyleCheesePizza(); } else if(type.equals(&quot;greek&quot;)){ pizza = new NYStyleGreekPizza(); } else if(type.equals(&quot;Pepperoni&quot;)){ pizza = new NYStylePepperoniPizza(); } else return null; return pizza; }} 抽象工厂那么，解决了每家分店的生产工艺、程序问题，我们也应当对它们的原料进行把关。但每家店又有该区域自己的原料工厂，因此，我们需要为工厂先定义一个抽象接口 PizzaIngredientFactory，要求所有原料工厂实现该接口。 123456789public interface PizzaIngredientFactory{ public Dough createDough(); public Sauce createSauce(); public Cheese createCheese(); public Veggies[] createVeggies(); public Pepperoni createPepperoni(); public Clams createClams();} 然后我们创建纽约原料工厂： 123456789101112131415161718192021public class NYPizzaIngredientFactory implements PizzaIngredientFactory{ public Dough createDough(){ return new ThinCrustDough(); } public Sauce createSauce(){ return new MarinaraSauce(); } public Cheese createCheese(){ return new ReggianoCheese(); } public Veggies[] createVeggies(){ Veggies veggies[] = {new Garlic(), new Onion(), new Mushroom()}; return veggies; } public Pepperoni createPepperoni(){ return new SlicedPepperoni(); } public Clams createClams(){ return new FreshClams(); }} 然后将原料工厂组合进披萨店中： 1234567891011121314151617181920public class NYStylePizzaStore extends PizzaStore{ public Pizza createPizza(String type){ Pizza pizza = null; PizzaIngredientFactory ingredientFactory = new NYIngredientFactory(); // 将原料工厂传递给每一个披萨，以便披萨能从工厂中获得原料 if(type.equals(&quot;cheese&quot;)){ pizza = new NYStyleCheesePizza(ingredientFactory); } else if(type.equals(&quot;greek&quot;)){ pizza = new NYStyleGreekPizza(ingredientFactory); } else if(type.equals(&quot;Pepperoni&quot;)){ pizza = new NYStylePepperoniPizza(ingredientFactory); } else return null; return pizza; }} 这样，我们就成功地使用抽象工厂方法实现了这个披萨店，实现了实现披萨店 PizzaStore 与具体披萨类型的代码解耦合。","link":"/2019/12/20/Design Patterns - Factory/"},{"title":"Design Patterns - Observer","text":"本文将介绍设计模式中的观察者模式（Observer）。 定义定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。 观察者模式 = 出版者/主题（Publisher） + 订阅者/观察者（Subscriber）。当出版者/主题的数据更新时，新的数据可以以出版者主动推送至观察者或者观察者主动请求新数据等方式进行数据更新。 我们看看一个形象的例子： 我们再看看观察者模式的 UML 类图： 观察者模式实现了两个对象之间的松耦合的同时依然可以交互，只是两个对象都不知道彼此的细节。那么观察者模式是如何实现主体和观察者之间的松耦合呢？ 由上面 UML 图可知，主题 ConcreteSubject 只知道观察者 ConcreteObserver 实现了某个借口（比如说 Observer 接口），但主题无需知道观察者具体是谁，又实现了什么。因此，我们可以随时新增或者减少观察者（甚至观察者类型也不重要，只要它实现了Observer 接口），因为主题唯一依赖的东西是一个实现了 Observer 接口的对象列表。因此，只要主题和观察者遵循此前达成的接口，改变主题或观察者其中任意一方，都不会影响另一方。 原则 交互对象之间尽可能采用松耦合设计 实现观察者模式一般有两种类型： 主题主动推送数据 观察者主动拉取数据 通常来说，有两种实现观察者模式的方式： 遵循观察者模式原则自定义 Subject 接口和 Observer 接口 使用 Java 内置观察者模式（支持主题主动推送数据和观察者主动请求数据） 应用实例 观察者模式的代表人物——MVC Java 中的 GUI 中按钮的 Listener 以及其他地方中的各种 Listener 监听器 自定义观察者模式框架——主题主动推送数据下面我们以一个实际例子应用观察者模式： 假设我们要给气象站的三个布告板（当前天气 CurrentConditionDisplay、气象统计 StatisticsDisplay、天气预报 ForecastDisplay）利用数据 API：WeatherData 实时更新数据。 12345678910public class WeatherData { public getTemperature(); public getHumidity(); public getPressure(); /* * 一旦气象测量更新，此方法会被调用 */ public measurementChanged();} WeatherData 中的三个 getter 方法无需我们操心，我们需要设法实现 measurementChanged()，先来看看一个错误示范，即直接在该方法中获取最新天气数据并更新三个布告板： 12345678910111213141516171819public class WeatherData { public getTemperature(); public getHumidity(); public getPressure(); /* * 一旦气象测量更新，此方法会被调用 */ public measurementChanged(){ float temp = getTemperature(); float humidity = getHumidity(); float pressure = getPressure(); // 更新三个布告板数据 currentConditionDisplay.update(temp, humidity, pressure); statisticsDisplay.update(temp, humidity, pressure); forecastDisplay.update(temp, humidity, pressure); }} 这样设计有什么不对呢？measurementChanged()中最后三行针对了具体的布告板进行数据更新，增加了交互的耦合度，万一未来又新增或者减少布告板的时候，就需要对该方法进行修改了。 接下来，我们使用观察者模式实现气象站的三个布告板。 首先使用观察者模式设计的气象站布告板 UML 类图： 我们先实现主体接口类 Subject 和 观察者接口类 Observer 以及布告板显示接口 DisplayElement： 1234567891011121314public interface Subject{ public void registerObserver(Observer o); public void removeObserver(Observer o); public void notifyObservers();}public interface Observer{ public void update(float temp, float humidity, float pressure);}// 当布告板需要显示时，调用此方法public interface DisplayElement{ public void display();} 我们再来让 WeatherData 实现主题接口： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class WeatherData implements Subject { // 订阅该主题的观察者列表 private ArrayList observers; private float temperature; private float humidity; private float pressure; public WeatherData(){ observers = new ArrayList(); } //实现 Subject 接口 public void registerObserver(Observer o){ observers.add(o); } public void removeObserver(Observer o){ int i = observers.indexOf(o); if(i &gt;= 0){ observers.remove(i); } } public void notifyObservers(){ for(int i = 0; i &lt; observers.size(); i++){ Observer observer = (Observer)observers.get(i); observer.update(temperature, humidity, pressure); } } /* * 一旦气象测量更新，此方法会被调用 */ public measurementChanged(){ notifyObservers(); } /* * 气象站通过此方法设置对应数据 */ public void setMeasurements(float temperature, float humidity, float pressure){ this.temperature = temperature; this.humidity = humidity; this.pressure = pressure; measurementsChanged(); }} 我们再来建立布告板代码，这里仅以当前天气布告板 CurrentConditionDisplay 为例： 123456789101112131415161718192021222324public class CurrentConditionDisplay implements Observer, DisplayElement { private float temperature; private float humidity; private Subject weatherData; public CurrentConditionDisplay(Subject weatherData){ this.weatherData = weatherData; // 在主题中注册当前观察者 weatherData.registerObserver(this); } public void update (float temperature, float humidity, float pressure){ this.temperature = temperature; this.humidity = humidity; display(); } public void display(){ System.out.println(&quot;Current conditions: &quot; + temperature + &quot;F degrees and&quot; + humidity + &quot;% humidity&quot;); }} 这样我们就使用观察者模式以主题主动推送的方式实现了一个气象站布告板，实现了数据源（气象站数据源）和客户（布告板）之间的松耦合。 Java 内置观察者模式现在，我们尝试使用 Java 内置的观察者模式—— Observer 接口（观察者）与 Observable 类（主题）——来实现气象站布告板。 我们首先来看看利用 java.util.Observer 和 java.util.Observable 改造后的气象站 UML 类图： 主题继承 Observable 类，而观察者实现 Observer 接口即可。但由于 Java 的单继承机制，这将导致主题无法继承其他类，这限制了程序的拓展性。 那么，主题如何送出通知呢？我们只需先使用观察者的 setChanged()方法，标记状态已改变的事实，然后调用两种 notifyObservers() 中的一个即可。 方法 说明 notifyObservers(Object arg) 主题主动推送数据 notifyObservers() 观察者主动拉取数据 12345678910111213141516setChanged(){ changed = true;}notifyObservers(Object arg){ if(changed){ for (Observer o : Observers){ o.update(this, arg); } changed = false; }}notifyObservers(){ notifyObservers(null);} 而观察者又如何接受通知呢？同以往一样，观察者实现了更新的方法： 1update(Observer o, Object arg) // arg：当传递通知时，可传递任何数据对象给每一个观察者 如果要主题主动推送数据给观察者，则可把数据当作数据对象传送给 notifyObservers(Object arg)；如果希望观察者主动拉取数据，则主题在数据更新时调用 notifyObservers()，再由观察者自行实现的 update() 方法主动拉取主题数据即可。 下面是利用 Java 内置观察者模式编写的气象站（主题）代码： 123456789101112131415161718192021222324252627282930313233343536import java.util.Observable;import java.util.Observer;public class WeatherData extends Observable { private float temperature; private float humidity; private float pressure; public WeatherData(){} /* * 一旦气象测量更新，此方法会被调用 */ public measurementChanged(){ // 首先标记状态已经改变的事实 setChanged(); // 无参形式通知观察者，即观察者主动拉取数据模式 notifyObservers(); } /* * 气象站通过此方法设置对应数据 */ public void setMeasurements(float temperature, float humidity, float pressure){ this.temperature = temperature; this.humidity = humidity; this.pressure = pressure; measurementsChanged(); } public float getTemperature(){ return temperature;} public float getHumidity(){ return humidity;} public float getPressure(){ return pressure;}} 下面是布告板代码，仅以 CurrentConditionDisplay 为例： 1234567891011121314151617181920212223242526272829303132333435import java.util.Observable;import java.util.Observer;public class CurrentConditionDisplay implements Observer, DisplayElement { Observable observable; private float temperature; private float humidity; public CurrentConditionDisplay(Observable observable){ this.observable = observable; // 在主题中注册当前观察者 observable.addObserver(this); } public void update (Observable obs, Object arg){ if(obs instanceof WeatherData){ WeatherData weatherData = (WeatherData)obs; // 观察者主动拉取数据 this.temperature = weatherData.getTemperature(); this.humidity = weatherData.getHumidity(); display(); } } public void display(){ System.out.println(&quot;Current conditions: &quot; + temperature + &quot;F degrees and&quot; + humidity + &quot;% humidity&quot;); }} 这样我们就利用 Java 内置的观察者模式并以观察者主动拉取的方式再次实现了气象站布告板代码。","link":"/2019/12/17/Design Patterns - Observer/"},{"title":"Dynamic_Programming","text":"近期在刷LeetCode算法时遇到几题动态规划(DP, Dynamic Programming)题型，由于先前没有系统学习算法相关知识，导致做题时比较迷茫、吃力。因此，借此机会，在这简要总结一下现阶段我所学习的动态规划相关知识。算法新手，如有纰漏，欢迎指正🙏 概要什么是动态规划我们首先来看一段对话 A: Writes down “1+1+1+1+1+1+1+1 =” on a sheet of paper. B: “What’s that equal to?” A: Counting “Eight!” B: Writes down another “1+” on the left. A: “What about that?” B: “Nine!” “ How’d you know it was nine so fast?” A: “You just added one more!” B: “So you didn’t need to recount because you remembered there were eight! Dynamic Programming is just a fancy way to say remembering stuff to save time later!” 结合这段对话以及上面本文的主题封面图，可以得出动态规划的核心思想——记住已经解决的子问题的的结果。 动态规划的原理 The core idea of Dynamic Programming is to avoid repeated work by remembering partial results and this concept finds it application in a lot of real life situations. 动态规划的核心思想，就是记住部分结果，并且在将来应用它们。为了达到此目的，动态规划以空间换取时间，通常使用一个数组记住子问题的结果，并在将来调用它们。值得注意的是，动态规划问题往往可以使用递归的方式进行解决，但单纯的直接递归会存在一个严重的问题：重复计算过多，耗时过大。我们以经典的Fibonacci numbers问题为例，来解释一下动态规划与直接递归的不同。 Fibonacci numbers计算方法：第n项的值为其前两项的值之和Fibonacci (n) = 1; if n = 0Fibonacci (n) = 1; if n = 1Fibonacci (n) = Fibonacci(n-1) + Fibonacci(n-2)由此算法计算出的序列为：1, 1, 2, 3, 5, 8, 13, 21… 我们首先来看看Fibonacci numbers问题的分解图：下面是本问题分别使用直接纯递归算法和使用动态规划算法的代码：直接纯递归12345int fib (int n) { if (n &lt; 2) return 1; return fib(n-1) + fib(n-2); } 动态规划123456void fib () { fibresult[0] = 1; fibresult[1] = 1; for (int i = 2; i&lt;n; i++) fibresult[i] = fibresult[i-1] + fibresult[i-2]; } 由上述问题分解图我们可以看出，由于存在大量的重复计算（例如上图中fib(2)被计算了5次），浪费了大量的时间。因此，直接纯递归算法的效率是极低的。而使用动态规划算法，则避免了重复计算，节约了大量的时间，显著提升了算法的效率。因此我们可以得出推论：动态规划问题避免了直接纯递归算法的重复计算问题，减少了运算时间，提升了算法效率。 动态规划的两种解决形式动态规划主要有两种实现形式：自顶向下的备忘录法和自底向上法。但是由于自顶向下的备忘录法仍保留了递归运算，而递归运算会产生额外的开销，因此这种方法没有自底向上法高效。 自顶向下的备忘录法这种方法比较容易理解，是直接纯递归算法的改进版本：创建一个数组，用于记录计算结果值。初始时，该数组所有元素为-1（这个没有规定，可以自定其他数值），然后进行递归计算。每一次递归时，首先在该数组中查找是否存在对应的值，若果存在对应的值（不为-1），则直接调用之即可，无须计算；若不存在对应的值（数组该项为-1），则计算该值，并将计算结果存入数组中，以便将来使用。在这，依旧以Fibonacci numbers问题为例，给出其以自顶向下的备忘录法的实现代码：12345678910111213141516171819public static int Fibonacci(int n){ if(n&lt;=0) return n; int []Memo=new int[n+1]; for(int i=0;i&lt;=n;i++) Memo[i]=-1; return fib(n, Memo); } public static int fib(int n,int []Memo) { if(Memo[n]!=-1) return Memo[n]; //如果已经求出了fib（n）的值直接返回，否则将求出的值保存在Memo备忘录中。 if(n&lt;=2) Memo[n]=1; else Memo[n]=fib( n-1,Memo)+fib(n-2,Memo); return Memo[n]; } 自底向上法自顶向下的备忘录法仍然使用了递归解法，就意味每次计算到对应子问题时还需查找数组看判断是否已经计算过，这就意味着存在额外开销。那么，我们为什么不能直接从子问题出发，先计算子问题，再计算其上一级问题呢？自底向上法就利用了这种思想。自底向上方法也是利用数组保存了先计算的值，为后面的调用服务。在这，依旧以Fibonacci numbers问题为例，给出其以自顶向下的备忘录法的实现代码：12345678910111213141516public static int fib(int n) { if(n&lt;=1) return n; int Memo_i_2=0; int Memo_i_1=1; int Memo_i=1; for(int i=2;i&lt;=n;i++) { Memo_i=Memo_i_2+Memo_i_1; Memo_i_2=Memo_i_1; Memo_i_1=Memo_i; } return Memo_i; } 动态规划适用情况那么，我们什么时候会用到动态规划呢？总的来说，在遇到以下两种问题时，可以使用动态规划算法。 最优子结构用动态规划求解最优化问题的第一步就是刻画最优解的结构，如果一个问题的解结构包含其子问题的最优解，就称此问题具有最优子结构性质。因此，某个问题是否适合应用动态规划算法，它是否具有最优子结构性质是一个很好的线索。使用动态规划算法时，用子问题的最优解来构造原问题的最优解。因此必须考查最优解中用到的所有子问题。 重叠子问题如在Fibonacci numbers问题中，如fib（2）被调用了5次等，如果一个问题中存在大量重复的子问题时，即递归算法反复求解相同的子问题，就称为具有重叠子问题（overlapping subproblems）性质。在动态规划算法中使用数组来保存子问题的解，这样子问题多次求解的时候可以直接查表不用调用函数递归。 动态规划的经典模型下面介绍一下动态规划的经典模型。 线性模型线性模型的是动态规划中最常用的模型，这里的线性指的是状态的排布是呈线性的。 区间模型区间模型的状态表示一般为d[i][j]，表示区间[i, j]上的最优解，然后通过状态转移计算出[i+1, j]或者[i, j+1]上的最优解，逐步扩大区间的范围，最终求得[1, len]的最优解。 背包模型有N种物品（每种物品数量见下规定）和一个容量为V的背包。放入第 i 种物品耗费的空间是Ci，得到的价值是Wi。求解将哪些物品装入背包可使价值总和最大。决策第i个物品在前i-1个物品放置完毕后，是选择放还是不放。 f[i][v]表示前i种物品恰好放入一个容量为v的背包可以获得的最大价值 01背包模型N种物品，每种物品数量为1 状态转移方程为：f[i][v] = max{ f[i-1][v], f[i-1][v - Ci] +Wi } 时间复杂度O(VN)，空间复杂度O(VN) （空间复杂度可利用滚动数组进行优化达到O(V)，下文会介绍滚动数组优化）。 完全背包模型N种物品，每种物品数量无限 状态转移方程为：f[i][v] = max{ f[i-1][v], f[i][v - Ci] +Wi } 时间复杂度O(VN)，空间复杂度在用滚动数组优化后可以达到O(V)。 多重背包模型N种物品，每种物品数量为Mi 状态转移方程为：f[i][v] = max{ f[i-1][v - kCi] + kWi | 0 &lt;= k &lt;= Mi } 时间复杂度O(Vsum(Mi))，空间复杂度仍然可以用滚动数组优化后可以达到O(V)。 优化：采用二进制拆分物品，将Mi个物品拆分成容量为1、2、4、8、… 2^k、Mi-( 2^(k+1) - 1 ) 个对应价值为Wi、2Wi、4Wi、8Wi、…、2^kWi、（Mi-( 2^(k+1) - 1 )）Wi的物品，然后采用01背包求解。这样做的时间复杂度降为O(Vsum(logMi))。 动态规划题集 Problem Difficulty Type Solution Maximum Subarray EASY - Maximum Subarray Climbing Stairs EASY 线性模型 Climbing Stairs Best Time to Buy and Sell Stock EASY 线性模型 Best Time to Buy and Sell Stock House Robber EASY 线性模型 House Robber Range Sum Query - Immutable EASY 线性模型 Range Sum Query - Immutable Min Cost Climbing Stairs EASY 线性模型 Min Cost Climbing Stairs 参考文献 [1] 动态规划[2] 算法-动态规划 Dynamic Programming–从菜鸟到老鸟[3] Introduction to Dynamic Programming[4] 2 Dimensional[5] State space reduction[6] Dynamic Programming and Bit Masking[7] 动态规划经典模型-背包模型","link":"/2019/02/23/Dynamic-Programming/"},{"title":"Java 线程池-ThreadPoolExecutor.execute()","text":"最近复习学习Java并发，其中线程池相关问题又是面试热点，因此在此记录一下对ThreadPoolExecutor的execute()方法的源码学习。 线程池的是什么在学习源码之前，我们首先要了解线程池是什么。线程池是一种对线程的使用模式，用于对线程的数量进行控制的一种模式。 线程池的意义多线程的软件设计方法可以最大限度的发挥多核处理器的计算能力，提高CPU的使用率，提高生产系统的吞吐亮和性能。但是，如果不对线程的数量加以控制，却会适得其反。 创建过多的线程会占用大量内存资源，影响系统性能，甚至可能导致OOM问题。 过多的短期任务线程的回收会对GC带来巨大的压力，延长GC停顿时间，影响系统性能。 创建大量的线程也会因线程间的切换带来巨大的开销，影响系统性能。 因此，为了最大的发挥多线程开发的优势，我们需要将线程的数量控制在一个合理的范围之中，并对已经创建的线程进行重复使用，以减少线程回收的开销，降低GC压力，而线程池（ThreadPool）的概念应运而生。 ThreadPoolExecutorJava的线程池支持主要通过ThreadPoolExecutor来实现，我们使用的ExecutorService的各种线程池策略都是基于ThreadPoolExecutor实现的，所以要弄明白各种线程池策略，必须先弄明白ThreadPoolExecutor。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) { /*检查输入参数的合法性*/ if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler; }``` |类型|参数|作用||---|---|---||int|corePoolSize|核心线程数量||int|maximumPoolSize|线程池最大线程数量||long|keepAliveTime|**空闲线程**的最大存活时间||TimeUnit|unit|时间单位||BlockingQueue&lt;Runnable&gt;|workQueue|任务队列，存放待执行的任务||ThreadFactory|threadFactory|创建线程的工厂||RejectedExecutionHandler|handler|拒绝策略| # execute()execute()直接将一个Runnable任务提交到线程池去运行，它无返回结果。 ```java threadPool.execute( new Runnable(){ public void run(){ ...//任务代码 } } )``` # submit()**ThreadPoolExecutor.submit(Runnable task)**方法来向线程池提交任务，该方法会返回一个Futrue类型的结果，通过以下代码便可以判断任务是否执行成功了。 ```java Future&lt;Object&gt; threadFuture = threadPoolExecutor.submit(task); try{ Object result = threadFuture.get(); }catch (InterruptedException e){ // 处理线程中断异常 }catch (ExecutionException e){ // 处理无法执行异常 } finally { threadPoolExecutor.shutdown(); }``` # execute() VS submit()**execute()**方法直接将任务提交到线程池去运行，至于线程池如何实现运行，就不是我们需要考虑的事情了，从而将任务与线程进行了解耦。但它不会返回结果，因此我们也无法得知任务是否执行成功。**submit(Runnable task)**方法来向线程池提交任务，该方法会返回一个Futrue类型的结果，因此我们可以得知任务的执行结果。# execute()实现原理因此，作为Java线程池的核心方法之一，我们在这重点来学习一下execute()的源码，了解它的实现机制。 它的业务流程如下图所示：当它接收到一个新任务后，首先检查线程池中工作线程的数量，如果工作线程的数量小于**corePoolSize**，则它会直接创建一个新的线程执行该任务；但当工作线程的数量大于等于corePoolSize，则它会将任务推给**任务队列（BlockingQueue）**。当任务队列接收到一个新的任务时，首先会检查一下任务队列是否已满，如果任务队列未满，则会将任务加入队列；但若任务队列已经满了，则会检查当前线程池中工作线程数量是否已经达到线程池的最大线程容量**maximumPoolSize**，如果线程池未满，则会创建一个新线程来执行该任务；但若线程池已经满了，则会执行**拒绝策略（RejectedExecutionHandler）**。 ![execute](http://mmbiz.qpic.cn/mmbiz_png/R5ic1icyNBNd5CI6LhDcqwVusDkOFAMDv0zYmVnsI8ltAaqg0XhUaXf3N8ZM1CZMeWp8bibia05P5Y9uEXjHql3NSg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1) ## 实现源码（JDK8） 在此仅展示与execute()业务相关的源码 ### execute() ```java public void execute(Runnable command) { int c = ctl.get(); //获取线程池控制变量ctl if (workerCountOf(c) &lt; corePoolSize) { //step 1: 核心线程数判断 if (addWorker(command, true)) //step 1.1 添加核心线程执行任务 return; c = ctl.get(); //重新获取最新的控制变量ctl（因为可能在上述过程中可能线程池控制变量发生改变） } if (isRunning(c) &amp;&amp; workQueue.offer(command)) { //step 2检查当前线程池是否还在运行状态，并尝试任务加入队列 int recheck = ctl.get(); //重新获取最新的控制变量ctl（因为可能在上述过程中可能线程池控制变量发生改变） if (! isRunning(recheck) &amp;&amp; remove(command)) //step 2.1判断线程池是否运行，防止线程池状态的突变，如果突变，那么执行拒绝策略，reject线程，防止workQueue中增加新线程 reject(command); else if (workerCountOf(recheck) == 0) //step 2.2判断当前工作线程数量如果等于0，直接添加工作线程 addWorker(null, false); } else if (!addWorker(command, false)) //step 3 如果任务无法加入队列，尝试创建线程执行任务 reject(command); } ctlctl是线程池的最重要的控制变量，它该变量是一个AtomicInteger类型的原子变量，记录着线程池的线程总数量workerCount以及线程池的状态runState。这个变量设计的非常巧妙，一方面减少了线程池的变量数量，更重要的一方面是，该变量是原子类型变量，线程池的实现函数中，往往需要同时获取这两个属性，如果将两个属性放入一个原子变量中，根据Atomic类支持线程的重入，线程池也就只需获取一把锁，便可以控制线程池的两个属性，这里实际上变相减少了一把锁的使用。那么ctl是如何将两个属性合并为一个变量的呢？首先AtomicInteger类型变量为32位，workerCount是占据着一个atomic integer的后29位的，而runState占据了前3位，所以，workerCount上限是(2^29)-1。 3 bits 29 bits runState workerCount runState是整个线程池的运行生命周期，有如下取值： 取值（COUNT—BITS == 3时） runState 说明 111 -&gt; -1 RUNNING 可以新加线程，同时可以处理任务队列queue中的任务 000 -&gt; 0 SHUTDOWN 不增加新线程，但是处理任务队列queue中的任务 001 -&gt; 1 STOP 不增加新线程，同时不处理任务队列queue中的任务 010 -&gt; 2 TIDYING 所有的线程都终止了（任务队列queue中），同时workerCount为0，那么此时进入TIDYING 011 -&gt; 3 TERMINATED terminated()方法结束，变为TERMINATED 线程池状态转换图如下所示： 它的相关操作如下所示： 12345678910111213141516171819202122private static final int COUNT_BITS = Integer.SIZE - 3; //workerCount位数private static final int CAPACITY = (1 &lt;&lt; COUNT_BITS) - 1; //workerCount上限是(2^29)-1 /*几个状态，用Integer的高三位表示*/private static final int RUNNING = -1 &lt;&lt; COUNT_BITS; //111private static final int SHUTDOWN = 0 &lt;&lt; COUNT_BITS; //000private static final int STOP = 1 &lt;&lt; COUNT_BITS; //001private static final int TIDYING = 2 &lt;&lt; COUNT_BITS; //010private static final int TERMINATED = 3 &lt;&lt; COUNT_BITS; //011/*获取后COUNT_BITS位数值，即workerCount*/private static int workerCountOf(int c) { return c &amp; CAPACITY; }/*获取前COUNT_BITS位数值runState*/private static int runStateOf(int c) { return c &amp; ~CAPACITY; }/*获取ctl*/private static int ctlOf(int rs, int wc) { return rs | wc; } prestartAllThreads()线程池并不是一开始就创建好coolPoolSize个线程，而是随着任务的添加，来逐步添加工作线程的。当然线程池也提供了线程池的预热功能prestartAllThreads()，该方法线程池会通过addWorker(null, true)函数来创建coolPoolSize个核心线程来等待任务的到来。 123456public int prestartAllCoreThreads() { int n = 0; while (addWorker(null, true)) ++n; return n;} Worker一个Worker对象就是ThreadPoolExecutor中的一个线程，它实现Runnable接口。当一个任务提交时，Worker对象就会使用线程工厂创建一个线程，并将该线程与当前firstTask绑定，Worker对象就像线程池工厂中的劳工一样，会不停的获取新的任务来执行。新创建的Worker线程都会保存在线程池的HashSet成员变量中。 Worker工作线程会尝试在keepAliveTime时间内从workQueue队列中取任务，线程的超时控制依赖于队列取元素的超时控制，也就是说在keepAliveTime时间类，工作线程会阻塞在getTask()方法上，直到线程取到任务或者取任务超时。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889private final class Worker extends AbstractQueuedSynchronizer implements Runnable{ /*Worker类不能被序列化，但我们还是提供一个serialVersionUID以防止Java编译器警告*/ private static final long serialVersionUID = 6138294804551838833L; /*当前Worker所工作的线程，如果线程工厂创建线程失败则会为null*/ final Thread thread; /*初始任务，可能为null*/ Runnable firstTask; /*其他变量成员...... */ /** * 当收到一个新任务时，则创建一个Worker，并从线程工厂创建一个线程将它与该任务绑定 * @param firstTask 初始任务，如果没有则为null */ Worker(Runnable firstTask) { this.firstTask = firstTask; this.thread = getThreadFactory().newThread(this); } /** 委托主循环程序（线程池）运行本线程 */ public void run() { runWorker(this); } /** 获取任务 */ private Runnable getTask() { boolean timedOut = false; // Did the last poll() time out? retry: for (;;) { int c = ctl.get(); int rs = runStateOf(c); /*当前状态为&gt;=STOP时，不处理workQueue中的任务，同时减小worker的数量所以返回null；如果为SHUTDOWN且任务队列workQueue已经empty了，同样减小worker数量并返回null*/ if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) { decrementWorkerCount(); return null; } /**主要是标识着当前Worker（线程）超时是否要退出 * wc &gt; corePoolSize时需要减小空闲的Worker数，那么timed为true； * 但是wc &lt;= corePoolSize时，不能减小核心线程数timed为false。 * * timedOut初始为false， * 如果timed为true那么使用poll取线程。 * 如果正常返回，那么返回取到的task。 * 如果超时，证明worker空闲，同时worker超过了corePoolSize，需要删除，返回r=null。 * 则 timedOut = true。此时循环到 * wc &lt;= maximumPoolSize &amp;&amp; ! (timedOut &amp;&amp; timed)时， * 减小worker数，并返回null，导致worker退出。 * 如果线程数&lt;= corePoolSize，那么此时调用 workQueue.take()， * 没有线程获取到时将一直阻塞，知道获取到线程或者中断，关于中断后面SHUTDOWN的时候会说。 */ boolean timed； for (;;) { int wc = workerCountOf(c); timed = allowCoreThreadTimeOut || wc &gt; corePoolSize; if (wc &lt;= maximumPoolSize &amp;&amp; ! (timedOut &amp;&amp; timed)) break; if (compareAndDecrementWorkerCount(c)) return null; c = ctl.get(); // Re-read ctl if (runStateOf(c) != rs) continue retry; // else CAS failed due to workerCount change; retry inner loop } try { /** * 使用take()函数，如果队列中没有数据，则线程wait()释放CPU;而poll()则不会wait()，而是直接返回null */ Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take(); if (r != null) return r; timedOut = true; } catch (InterruptedException retry) { timedOut = false; } } } /* 其他Worker方法......*/} DefaultThreadFactory默认的线程工厂 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101static class DefaultThreadFactory implements ThreadFactory { public Thread newThread(Runnable r) { Thread t = new Thread(group, r, namePrefix + threadNumber.getAndIncrement(), 0); if (t.isDaemon()) t.setDaemon(false); if (t.getPriority() != Thread.NORM_PRIORITY) t.setPriority(Thread.NORM_PRIORITY); return t; }} ``` ### addWorker(Runnable firstTask, boolean core) addWorker(Runnable firstTask, boolean core)负责创建Worker即线程来执行任务。它有两个参数：firstTask为一个Runnable对象，用来接收创建Worker时的初始任务；core为true时表明创建的线程是一个核心线程，反之为一个普通线程。 ```java private boolean addWorker(Runnable firstTask, boolean core) { retry: /*本循环用于检查线程池状态，并对线程池状态进行更新*/ for (;;) { int c = ctl.get(); //获取线程池最新的控制变量 int rs = runStateOf(c); //获取线程池的状态. /** * rs!=Shutdown || fistTask！=null || workCount.isEmpty * 如果当前的线程池的状态&lt;SHUTDOWN，那么增加Worker； * 如果当前的线程池的状态=SHUTDOWN，那么当且仅当firstTask为null且任务队列workQueue不为空的时候可以增加Worker * 如果当前的线程池的状态&gt;SHUTDOWN，那么拒绝增加Worker；*/ if (rs &gt;= SHUTDOWN &amp;&amp; ! (rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; ! workQueue.isEmpty())) return false; for (;;) { int wc = workerCountOf(c); //获取当前线程池线程总数 /** *检查当前线程池总数是否已经达到或者超过线程池的容量， *如果超过，则返回false表示拒绝增加新线程Worker； *再检查当前线程是普通线程还是核心线程，并检查对应类型的线程总数是否超过corePoolSize或者maximumPoolSize的值； *如果超过了，则也返回false拒绝创建线程Worker */ if (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize)) return false; /*线程计数+1*/ if (compareAndIncrementWorkerCount(c)) break retry; c = ctl.get(); //重新获取关键变量，以防止线程池在上述过程中出现状态突变 if (runStateOf(c) != rs) //如果线程池状发生了改变，则重新进行上述操作 continue retry; // else CAS failed due to workerCount change; retry inner loop } } Worker w = new Worker(firstTask); //创建新的Worker，并将firstTask与之绑定 Thread t = w.thread; //创建新线程，并将新建的Worker的线程与之绑定 final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try { //加锁后重新检查线程池状态 int c = ctl.get(); int rs = runStateOf(c); /** * rs!=SHUTDOWN ||firstTask!=null * * 与上述一样，同样检测当rs&gt;SHUTDOWN时直接拒绝减小Wc，同时Terminate，如果为SHUTDOWN同时firstTask不为null的时候也要Terminate */ if (t == null || (rs &gt;= SHUTDOWN &amp;&amp; ! (rs == SHUTDOWN &amp;&amp; firstTask == null))) { decrementWorkerCount(); tryTerminate(); return false; } workers.add(w); int s = workers.size(); if (s &gt; largestPoolSize) largestPoolSize = s; } finally { mainLock.unlock(); } t.start(); // It is possible (but unlikely) for a thread to have been // added to workers, but not yet started, during transition to // STOP, which could result in a rare missed interrupt, // because Thread.interrupt is not guaranteed to have any effect // on a non-yet-started Thread (see Thread#interrupt). //Stop或线程Interrupt的时候要中止所有的运行的Worker if (runStateOf(ctl.get()) == STOP &amp;&amp; ! t.isInterrupted()) t.interrupt(); return true; } ThreadPoolExecute.runWorker()Worker.run()被调用后,Worker对应的线程会调用ThreadPoolExecute.runWorker()来执行firstTask任务，并循环从任务队列中取任务，getTask()实现了对keepAliveTime参数的维护，控制空闲线程的存活时间。 1234567891011121314151617181920212223242526272829303132333435final void runWorker(Worker w) { Runnable task = w.firstTask; w.firstTask = null; boolean completedAbruptly = true; //标识线程是不是异常终止的 try { /*task不为null情况是初始化worker时，如果task为null，则去队列中取线程---&gt;getTask()*/ while (task != null || (task = getTask()) != null) { w.lock(); //获取woker的锁，防止线程被其他线程中断 clearInterruptsForTaskRun(); //清除所有中断标记 try { beforeExecute(w.thread, task); //线程开始执行之前执行此方法，可以实现Worker未执行退出，本类中未实现 Throwable thrown = null; try { task.run(); //执行任务 } catch (RuntimeException x) { thrown = x; throw x; } catch (Error x) { thrown = x; throw x; } catch (Throwable x) { thrown = x; throw new Error(x); } finally { afterExecute(task, thrown); //线程执行后执行，可以实现标识Worker异常中断的功能，本类中未实现 } } finally { task = null; //运行过的task标null w.completedTasks++; w.unlock(); } } completedAbruptly = false; } finally { //处理worker退出的逻辑 processWorkerExit(w, completedAbruptly); } }","link":"/2019/04/30/ThreadPoolExecutor/"},{"title":"Android 知识体系 - 四大组件 - Activity","text":"本文介绍 Android 四大组件中的 Activity。 Activity 是什么？Activity 是一种可以包含用户界面的组件，主要是用于和用户交互。用户见到的手机 APP 界面即 Activity。 任务栈/返回栈Android 是使用任务（Task）来管理活动的，一个任务就是一组存放在栈里的活动集合。当一个新活动被启动时，它被压入栈顶；当我们按下 Back 键或调用 finish() 方法去销毁一个活动的时候，处于栈顶的活动会出栈，这时，前一个入栈的活动会处于栈顶位置。 Activity 生命周期Activity 4种状态 运行状态 Active：当一个活动处于返回栈栈顶时，这时该活动获得焦点，处于运行状态。 暂停状态 Paused：当一个活动不再处于栈顶时，但依然可见（例如此时弹出对话框），但是焦点却不在它身上，此时的该活动并没有被销毁，内存里面的成员变量，状态信息等仍然存在。 停止状态 Stopped：当一个活动不再处于栈顶，且不可见的时候，它处于停止状态，但是内存里面的成员变量，状态信息等仍然存在，但是也没有被销毁。 销毁状态 Killed：当一个活动从返回栈出栈后即处于销毁状态，此时内存里面的成员变量、状态信息等都会被系统一并回收。 系统回收活动状态的优先级系统最不愿意回收处于运行状态的活动，其次是暂停状态的活动，因为这样会给用户体验造成很不好的影响。当系统会最优先地回收处于销毁状态的活动，其次是停止状态。 系统回收优先即从高到低：销毁状态 &gt; 停止状态 &gt; 暂停状态 &gt; 运行状态 Activity 状态Activity 类定义了7个回调方法，覆盖了活动生命周期的每一个环节。 方法 说明 onCreate() 表示活动正在被创建，这是活动生命周期的第一个方法。通常我们要在此函数中做初始化 的工作，比如：绑定布局，控件，初始化数据等。 onStart() 表示活动正在被启动，这此时活动已经被创建好了，完全过了准备阶段，但是没有出现在 前台，需要执行 onResume()函数才可以进入到前台与用户进行交互。 onResume() 表示活动已经可见了，并且活动处于运行状态，也就是活动不止出现在了前台，而且还可 以让用户点击，滑动等等操作与它进行交互。 onPaused() 表示活动正在暂停，大多数情况下，活动执行完 onPause()函数后会继续执行 onStop()函 数，造成这种函数调用的原因是当前的活动启动了另外一个活动或者回切到上一个活动。 还有一种情况就是 onPause()函数被单独执行了，并没有附带执行 onStop()方法，详细过程见下面”onPause()单独执行情况“。 onStop() 表示活动即将停止，我们应该在此函数中做一些不耗时的轻量级回收操作。 onRestart() 表示活动正在重新启动。一般情况下，一个存在于后台不可见的活动变为可见状态，都会 去执行 onRestart()函数，然后会继续执行 onStart()函数，onResume()函数出现在前台并 且处于运行状态。 onDestroy() 表示活动要被销毁了。这是活动生命中的最后一个阶段，我们可以在 onDestory()函数中 做一些回收工作和资源释放工作等，比如：广播接收器的注销等。 Activity 状态分析 正常情况注：以下序号对应上图对应序号 启动一个活动 Activity，通常是由一个 Intent 完成。当活动启动后首先调用 onCreate()进行初始化操作，包括布局绑定、控件和数据的初始化等。 初始化完成后调用 onStart()使得活动可见，但此时还未出现在前台，尚无法与用户进行交互操作，此时通常表明活动已经在后台准备就绪。 调用 onResume()使得活动出现在前台，此时活动可与用户进行交互。 由于活动执行了onResume()函数，所以活动出现在了前台。也就是活动处于运行状态（Active）。 当处于运行状态的活动因为一个新启动的活动或者用户要返回上一个活动时，就会执行 onPause()，相当于当前活动必须将手头上的工作暂停下来。正常情况下，onPause()不会单独执行，还会继续调用 onStop()。 如上所述，一般情况下调用完 onPause()后还会调用 onStop()，执行完该方法后才真正意味着当前的活动已经退出前台，存在于后台。 若当前活动即将执行 onDestory()函数，则代表着这个活动即将进入生命的终点，这是活动生命周期中的最后一次回调生命周期，我们可以在该函数中，进行一些回收工作和资源的释放工作，比如：广播接收器的注销工作等。 执行完 onDestory()方法后的活动接下来面对的是被 GC 回收，宣告生命终结。 通常情况下生命周期不会执行本路径。但也有特殊情况，详细见下面「只执行 onPause() 而不执行 onStop()」 当用户在其他的活动或者桌面回切到当前活动时，这个活动就会先去执行 onRestart()函数。 被重启的接下来执行 onStart()函数，接着和普通活动一样执行 onResume()函数进入到运行状态。 高优先级的应用急需要内存，此时处于低优先级的此应用就会被 kill 掉，内存回收遵循进行优先级，优先回收空进程，其次是处于后台的活动进程，最后才是可见和前台的活动以降低对用户交互体验的影响。 用户返回原活动。 异常情况资源相关的系统配置发生改变导致活动被杀死并重新创建 首先介绍两个在异常情况下会被调用的系统回调方法： 方法 说明 onSaveInstanceState() 用于保存当前活动状态，包括相关活动数据、当前活动的视图结构等等。它总是在 onStop() 之前被调用，但会发生在 onPause()之前或之后 onRestoreInstanceState() 当活动被重新创建后（且 onStart() 方法执行完成后），系统会调用该方法，并把活动销毁时 onSaveInstanceState()方法所保存的 Bundle 对象作为参数传递给该方法和 onCreate()，以便重启活动时恢复原先活动数据、活动视图结构等 当系统配置发生改变时，活动会被销毁，其 onPause()、onStop()、onDestroy()函数均会被调用，同时由于活动是在异常情况下终止的，系统会调用 onSaveInstanceState()来保存当前活动状态。我们可以通过 onRestoreInstanceState()和 onCreate()方法来判断活动是否被重建了，如果被重建了，那么我们就可以取出之前保存的数据并恢复。 同时，在 onSaveInstanceState()和 onRestoreInstanceState()方法中，系统自动为我们做了一定的恢复工作。当活动在异常情况下需要重新创建时，系统会默认为我们保存当前活动的视图结构。当活动在异常情况下需要重新创建时，系统会默认为我们保存当前活动的视图结构，并且在活动重启后为我们恢复这些数据，比如：文本框中用户输入的数据，ListView 滚动的位置等，这些 View 相关的状态系统都能够默认为我们恢复。具体针对某一个特定的 View 系统 能为我们恢复哪些数据，我们可以查看 View 的源码。和活动一样，每个 View 都有 onSaveInstanceState()和 onRestoreInstanceState()这两个方法，看一下它们的具体实现，就能知道系统能够自动为每个 View 恢复哪些数据。 关于保存和恢复View层次结构，系统的工作流程是这样的： 首先活动被意外终止时，它会调用 onSaveInstanceState()去保存数据，然后活动会委托 Window 去保存数据，接着 Window 在委托它上面的顶级容器去保存数据。顶级容器是一个 ViewGroup，一般来说它很可能是 DecorView。最后顶层容器再去一一通知它的子元素来保存数据，这样整个数据保存过程就完成了。可以发现，这是一个典型的委托思想，上层委托下层，父容器去委托子元素去处理一件事情，这种思想在 Android 中有很多应用，比如：View 的绘制过程，事件分发等都是采用类似的思想。至于数据恢复过程也是类似的，这样就不再重复介绍了。 因此在通常情况下，系统配置改变会导致活动的重建，但是我们可以给活动指定 configChanges 属性使其不被重建，例如活动的横竖屏切换。 资源内存不足导致低优先级的活动被杀死当内存严重不足时，系统就会按照进程优先级去 kill 掉目前活动所在的进程，并在后续通过 onSaveInstanceState() 和 onRestoreInstanceState() 来存储和恢复数据。如果一个进程中没有四大组件的执行，那么这个进程将很快被系统杀死，因此，一些后台工作不适合脱离四大组件独立运行在后台中，这样进程更容易被杀死。比较好的方法就是将后台工作放入 Service 中从而保证进程有一定的优先级，这样就不会轻易地被系统杀死。 特殊情况只执行 onPause() 而不执行 onStop()如果使用两个活动（FirstActivity 和 SecondActivity），并修改 AndroidManifest.xml 中 SecondActivity 的属性： 方案一：添加 android:theme=”@android:style/Theme.Dialog” 。将该活动修改为Dialog样式。 方案二：修改 android:theme=”@android:style/Theme.Translucent” ，将该活动变为一个透明活动 并使用 FirstActivity 调用 SecondActivity，此时 FirstActivity 只会单独执行执行 onPause()，而不会继续执行 onStop()，详细过程见博文《Android什么时候只会调用onPause()而不会调用onStop()完全解析？》 活动的横竖屏切换与横竖屏生命周期函数有关调用的属性是 android:configChanges ，关于它的属性值设置影响如下： 参数 说明 orientation 消除横竖屏的影响 keyboardHidden 消除键盘的影响 screenSize 消除屏幕大小的影响 当我们设置活动的 android:configChanges 属性为 orientation 或者 orientation|keyboardHidden 或者不设置这个属性的时候，它的生命周期会走如下流程： 刚启动活动：onCreate() -&gt; onStart() -&gt; onResume() 由横竖屏互切时：onPause() -&gt; onSaveInstanceState -&gt; onStop() -&gt; onDestroy() -&gt; onCreate() -&gt; onStart() -&gt; onRestoreInstanceState() -&gt; onResume 当我们设置活动的 android:configChanges 属性为 orientation|screenSize 或者orientation|screenSize|keyboardHidden 的时候，它的生命周期会走如下流程： 刚启动活动：onCreate() -&gt; onStart() -&gt; onResume() 由横竖屏互切时：什么都没调用（⚠️ 设置了 orientation|screenSize 属性之后，在进行横竖屏切换的时候调用的方法是onConfigurationChanged()，而不会回调Activity的各个生命周期函数！） 什么时候活动不执行onDestory()？返回栈里面的第一个没有销毁的活动会执行 onDestroy()，其他活动不会执行。 例：从 mainActivity 跳转到 activity-A（或者继续从 activity-A 再跳转到 activity-B），这时候，从后台强杀，只会执行 mainActivity 的 onDestroy()，activity-A（以及activity-B）的onDestroy() 方法都不会执行。 进程优先级 前台：与当前用户正在交互的 Activity 所在的进程。 可见：Activity 可见但是没有在前台所在的进程。 服务：Activity 在后台开启了 Service 服务所在的进程。 后台：Activity 完全处于后台所在的进程。 空：没有任何 Activity 存在的进程，优先级也是最低的。 进程优先级从高到低：前台 &gt; 可见 &gt; 服务 &gt; 后台 &gt; 空 Activity 启动模式返回栈的结构可能导致同一个活动在多次调用的时候被重复创建，造成资源浪费，因此，我们需要先学习活动的启动模式。 standradstandard 是活动的默认启动模式，在 standard 模式下，每当启动一个新的活动，它（新活动）就会在返回栈种入栈，并处于栈顶位置。对于使用该模式的活动，系统不会在乎这个活动是否已经在返回栈中存在，每次启动都会创建一个新的实例。 在这种模式下，被启动的活动（standard 模式）会进入启动它的那个活动的任务栈中。 例如：activityA 启动了 activityB（activityB 为 standard模式），则 activityB 就会进入 activityA 所在的返回栈中。 ⚠️ 当我们用 ApplicationContext 去启动 standard 模式的活动就会报错，这是因为 standard 模式的活动默认会进入启动它的活动所属的返回栈中，但是由于非 Activity 类型的 Context(如 ApplicationContext)并没有所谓的返回栈，所以这就会出现错误。解决这个问题的方法就是为待启动的活动指定 FLAG_ACTIVITY_NEW_TASK 标记位，这样启动的时候就会为它创建一个新的返回栈，这个时候启动活动实际上以 singleTask 模式启动的。 singleTopstandard 模式也有它不合理的地方：活动明明已经在栈顶了，再次启动这个活动时又会创建一个新的活动实例，并把它压入栈顶，造成资源浪费。因此 singleTop 模式就是为解决这个问题而生。 在 singleTop 模式下，在启动时如果发现返回栈的栈顶已经是该活动，则认为可以直接使用它，不会再创建新的活动实例，同时它的 onNewIntent() 被回调，通过此方法的参数我们可以取出当前请求的信息。 例：有4个活动：A、B、C、D，其中 C 为 singleTop 模式，此时返回栈为 [ABCD]： –若此时再启动活动 D： 若 D 为 singleTop 模式：返回栈：[ABCD] 若 D 为 standrad 模式：返回栈：[ABCDD] –若此时再启动活动 C：返回栈：[ABCDC] singleTask如上例所示，如果返回栈中的任务不在栈顶位置，当再次启动它的时候依然会重新创建一个新的实例，因此 singeTask 就是用来解决这个问题的。 在 singleTask 模式下，每次启动活动时，系统首先会在返回栈中检查是否已经存在该活动的实例，如果存在，则直接使用该实例，系统也会回调其 onNewIntent()，并把在这个活动之上的所有活动出栈；如果没有发现则创建一个新的活动实例并入栈。 ⚠️ 如果 singleTask 模式指定不同的 taskAffinity，会启动一个新的返回栈，就如同 singeInstance 模式一样。 例1：有4个活动：A、B、C，有两个返回栈 S1：[ABC] 和 S2：[]（S2 尚未有实例），现在要启动活动 D（singeTask模式）： –若 S1 启动活动 D：返回栈：S1：[ABCD] –若 S2 启动活动 D：先创建返回栈 S2 的实例，再启动活动 D返回栈：S1：[ABC] S2：[D] –若此时返回栈 S1：[ADBC]，要启动活动 D（singeTask模式）返回栈：S1：[AD]活动 D 到栈顶后其 onNewIntent() 会被系统调用 例2：假设目前有2个返回栈，前台返回栈为[AB],而后台返回栈为[CD]，假设活动 C、D 的启动模式均为 singleTask。 若请求启动活动 D，那么整个后台返回栈都会被切换到前台，这个时候整个后台返回栈变成了[ABCD]。当用户按back键的时候，列表中的Activity会一一出栈。 但若请求启动活动 C，则活动 D 会先出栈，然后后台返回栈再被切换到前台，这时整个后台返回栈变成[ABC]，当用户按back键的时候，列表中的Activity会一一出栈。 singleInstance当活动被指定为 singleInstance 模式时被启动，则会启动一个新的返回栈来管理这个活动。这样就实现了不同应用程序启动同一个活动时都共用一个返回栈，实现了共享活动实例。 singleInstance 模式有一下特点： 以 singleInstance 模式启动的活动具有全局唯一性，即整个系统中只会存在一个这样的实例。 以 singleInstance 模式启动的活动在整个系统中是单例的，如果在启动这样的活动时，已经存在了一个实例，那么会把它所在的任务调度到前台，重用这个实例。 以 singleInstance 模式启动的活动具有独占性，即它会独自占用一个任务（返回栈），被他开启的任何活动都会运行在其他任务（返回栈）中。 被 singleInstance 模式的活动开启的其他活动，能够在新的任务（返回栈）中启动，但不一定开启新的任务（返回栈），也可能在已有的一个任务（返回栈）中开启。 Activity 组件之间的通信Activity -&gt; ActivityIntent/Bundle此方式多用于Activity之间传递数据。 //首先创建一个Bundle对象 Bundle bundle = new Bundle(); bundle.putString(&quot;data_string&quot;,&quot;数据&quot;); bundle.putInt(&quot;data_int&quot;,10); bundle.putChar(&quot;da_char&quot;,&apos;a&apos;); //然后创建一个Intent对象 Intent intent = new Intent(FirstActivity.this,SecondActivity.class); intent.putExtras(bundle); startActivity(intent); 类静态变量在活动内部定义静态的变量，这种方式见于少量的数据通信，如果数据过多，还是使用上一种方式。 public class FirstActivity extends AppCompatActivity { //声明为静态 static boolean isFlag = false; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_first); //首先创建一个Bundle对象 Bundle bundle = new Bundle(); bundle.putString(&quot;data_string&quot;,&quot;数据&quot;); bundle.putInt(&quot;data_int&quot;,10); bundle.putChar(&quot;da_char&quot;,&apos;a&apos;); //然后创建一个Intent对象 Intent intent = new Intent(FirstActivity.this,SecondActivity.class); #### intent.putExtras(bundle); startActivity(intent); } } 全局变量创建一个类，里面定义一批静态变量，活动之间通信都可以访问这个类里面的静态变量。 Activity -&gt; Service绑定服务的方式，利用 ServiceConnection 接口首先我们需要在要绑定的服务中声明一个Binder类 public class MyService1 extends Service { public String data = &quot;&quot;; public MyService1() { } @Override public IBinder onBind(Intent intent) { // TODO: Return the communication channel to the service. return new Binder(); } public class Binder extends android.os.Binder{ public void sendData(String data){ MyService1.this.data = data; } } } 然后我们让活动实现 ServiceConnection 这个接口，并且在 onServiceConnected() 方法中获取到 Service 提供给活动的 Binder 实例对象，通过这个对象我们就可以与 Service 进行通信可以通过上述代码的 Binder 类中的 sendData() 方法进行通信。 public class ServiceBindActivity extends AppCompatActivity implements ServiceConnection,View.OnClickListener { private Button bt0,bt1,bt2; public MyService1.Binder binder = null; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_service_bind); bt0 = findViewById(R.id.bt0); bt1 = findViewById(R.id.bt1); bt2 = findViewById(R.id.bt2); bt0.setOnClickListener(this); bt1.setOnClickListener(this); bt2.setOnClickListener(this); } @Override protected void onDestroy() { super.onDestroy(); unbindService(this); } //这个是服务绑定的时候调用 @Override public void onServiceConnected(ComponentName componentName, IBinder iBinder) { binder = (MyService1.Binder) iBinder; } //这个是服务解绑的时候调用 @Override public void onServiceDisconnected(ComponentName componentName) { } @Override public void onClick(View view) { switch (view.getId()){ case R.id.bt0: //绑定服务 Intent intent = new Intent(ServiceBindActivity.this,MyService1.class); bindService(intent,this, Context.BIND_AUTO_CREATE); break; case R.id.bt1: //通过binder对象来和Service进行通信 if(binder != null) binder.sendData(&quot;bt1&quot;); break; case R.id.bt2: //通过binder对象来和Service进行通信 if(binder != null) binder.sendData(&quot;bt2&quot;); break; } } Intent这种方式很简单，我们在启动和停止 Service 时所调用的方法都需要传入一个 Intent 实例对象，通过这个传入的 Intent 对象，就可以与 Service 进行通信。但这种通信方式的缺点显而易见，那就是只能传递少量的数据 // Activity public class ServiceStartActivity extends AppCompatActivity implements View.OnClickListener { private Button bt0,bt1; private Intent intent ; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_service_start); intent = new Intent(this, MyService2.class); bt0 = findViewById(R.id.bt0); bt1 = findViewById(R.id.bt1); bt0.setOnClickListener(this); bt1.setOnClickListener(this); } @Override public void onClick(View view) { switch (view.getId()){ case R.id.bt0: //开启服务并且传递数据 intent.putExtra(&quot;data_stirng&quot;,&quot;string数据&quot;); startActivity(intent); break; case R.id.bt1: //结束服务 stopService(intent); break; } } } // Service public class MyService2 extends Service { public String data = &quot;&quot;; public MyService2() { } @Override public IBinder onBind(Intent intent) { // TODO: Return the communication channel to the service. return null; } @Override public int onStartCommand(Intent intent, int flags, int startId) { //得到Activity传递过来的数据 data = intent.getStringExtra(&quot;data_string&quot;); return super.onStartCommand(intent, flags, startId); } } CallBack + Handler 监听服务的进程变化当 ServiceBind2Activity 去绑定服务 MyService3 的时候,那么在活动中的 onServiceConnected()方法被调用，此时位于 MyService3 的 CallBack 接口引用被实例化，并且 onDataChange()方法被实现，可以看到里面是一段 Handler 通信的代码，这个方法是为 MyService3 做耗时操作调用的，也印证了标题：监听服务的进程变化。 // Service public class MyService3 extends Service { //在Service中如果要进行耗时任务，可以通过CallBack接口提供的方法与Activity进行通信 public Callback callback; public MyService3() { } @Override public IBinder onBind(Intent intent) { // TODO: Return the communication channel to the service. return new Binder(); } public void setCallBack(CallBack callBack){ this.callback = callback; } public Callback getCallback() { return callback; } public interface CallBack{ void onDataChange(String data); } public class Binder extends android.os.Binder{ public MyService3 getMyService3(){ return MyService3.this; } } } // Activity public class ServiceBind2Activity extends AppCompatActivity implements ServiceConnection{ public MyService3.Binder binder = null; private Handler handler = new Handler(){ @Override public void handleMessage(Message msg) { super.handleMessage(msg); Bundle bundle = msg.getData(); String data_string = bundle.getString(&quot;data_string&quot;); //接下来就是更新ui } }; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_service_bind2); } @Override public void onServiceConnected(ComponentName componentName, IBinder iBinder) { binder = (MyService3.Binder) iBinder; binder.getMyService3().setCallBack(new MyService3.CallBack() { //此方法提供给MyService3在子线程中调用 @Override public void onDataChange(String data) { Message message = new Message(); Bundle bundle = new Bundle(); bundle.putString(&quot;data_string&quot;,&quot;String数据&quot;); message.setData(bundle); //通过Handler进行异步通信，不过耗时操作放在MyService3中 handler.sendMessage(message); } }); } @Override public void onServiceDisconnected(ComponentName componentName) { } } Activity -&gt; FragmentBundle在创建 Fragment 实例的时候，调用方法 setArguments()将一个 Bundle 对象传递给 Fragment，然后在 Fragment 中先去判断是否和当前活动绑定上了，如果绑定上了，就可以拿出这个 Bundle 中的数据。 // Activity 中代码 // 首先创建一个Bundle对象 Bundle bundle = new Bundle(); bundle.putString(&quot;data_string&quot;,&quot;数据&quot;); bundle.putInt(&quot;data_int&quot;,10); bundle.putChar(&quot;da_char&quot;,&apos;a&apos;); Fragment fragment = new MyFragment1(); fragment.setArguments(bundle); // MyFragment1中代码 if(isAdded()){//这里判断是否 Fragment 和活动进行了绑定，如果这个 Fragment 没有和活动绑定的话，那么那个 Bundle 对象是无法从活动传递给 Fragment 的，因此这种写法是必须的。 Bundle bundle = getArguments(); String data_string = bundle.getString(&quot;data_string&quot;); String data_int = bundle.getInt(&quot;data_int&quot;); String data_char = bundle.getChar(&quot;data_char&quot;); 直接进行方法调用在Activity里通过Fragment的引用，可以直接调用 Fragment 中的定义的任何方法。 MyFragment1 myFragment1 = new MyFragment1(); myFragment.toString(&quot;传送的string数据&quot;); scheme 跳转协议Android 中的 scheme 是一种页面内跳转协议，通过自定义 scheme 协议，可以非常方便的跳转到 APP 中的各个页面，通过 scheme 协议，服务器可以定制化告诉 APP 跳转到哪个页面，可以通过通知栏消息定制化跳转页面，可以通过 H5 页面跳转到相应页面等等。详细请看博文《Android产品研发（十一）–&gt;应用内跳转Scheme协议》 源码解析：startActivity()参见博文《Android Activity的启动流程源码解析(8.0) | 小王君》 参考 Android面试系列文章2018之Android部分Activity篇 ｜ ClAndEllen （遵循 CC 4.0 BY-SA 版权协议） Java中的回调方法 Android什么时候只会调用onPause()而不会调用onStop()完全解析？ | 娃哈哈19910206（遵循 CC 4.0 BY-SA 版权协议） Android产品研发（十一）–&gt;应用内跳转Scheme协议 | 一片枫叶_刘超（遵循 CC 4.0 BY-SA 版权协议） Android Activity的启动流程源码解析(8.0) | 小王君（遵循 CC 4.0 BY-SA 版权协议）","link":"/2019/12/14/Android 知识体系 - 四大组件 - Activity/"},{"title":"10种经典排序算法总结","text":"最近复习数据结构与算法，先从基本的排序算法开始。在此，对10种经典的排序算法进行总结，加深自己对相关算法的理解与掌握，其中也参考了维基百科以及部分网上优秀博客的总结。 本文所有代码参见：Github 算法概述排序算法是数据结构中的重中之重，也是面试中基本必考的项目。排序的是将一组“无序”的记录序列调整为“有序”的记录序列。所有排序算法基本上都遵循两大原则： 输出结果为递增序列（递增是针对所需的排序顺序而言） 输出结果是原输入的一种排列、或是重组 在计算机科学中，排序算法有很多，本文在此仅仅总结其中的10种经典的排序算法。 算法性能评价基本上，大部分的算法都需要通过计算其时间复杂度和空间复杂度来对其性能进行评价，对于排序算法亦如此。而对于排序算法来说，还需要从其排序所产生的结构的稳定性对其进行评价，分为稳定的和不稳定的。 时间复杂度指对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。 非线性时间比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此称为非线性时间比较类排序。线性时间非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此称为线性时间非比较类排序。 空间复杂度指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。 稳定性指是否让原本有相等键值的纪录维持相对次序。 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。 10种经典算法的性能总结： 算法描述接下来将详细描述本人对各算法的实现原理的理解。所有实现将统一采用Java语言。 冒泡排序 Bubble Sort如果你是新入坑的程序猿，会许你可能会疑惑：为什么它要叫冒泡排序？根据生活常识我们可知，在水中，较大的气泡将会逐渐向上浮，直到浮出水面。而冒泡排序的实现过程则与这个气泡过程极其相似，当然，我们所说的气泡大小是相对的，并不是说比较完后得出的序列中元素越大越靠前，结果序列是升序降序其实问题不大。 冒泡排序是一种简单的排序方式。它重复遍历待排序的序列，依次比较相邻的两个元素的大小，如果他们的大小不符合要求，则进行交换顺序。此过程一直重复，知道所有元素排列有序化。 工作过程在这里，我们以将序列升序化，即较大的元素放在后面。 STEP1: 在每一轮中，比较相邻的两个元素，如果前面的元素比后面的元素大，则交换它们的顺序。这样做的结果是本轮最大的元素会”浮”到序列末尾，这样意味着本轮成功有序化至少一个元素STEP2: 将待有序化的元素个数减STEP3: 对除了最后一个的所有元素重复STEP1和STEP2，直至所有排序完成 动画演示 Java代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271 public void coreSort() { for (int i = 0; i &lt; arr.length - 1; ++i) for (int j = 0; j &lt; arr.length - i - 1; ++j) if (arr[j] &gt; arr[j + 1]) swap(j, j + 1); } ``` &gt; **[查看完整代码](https://github.com/LeeYatSan/Algorithms/tree/master/Sorting%20Algorithms)** ## 选择排序 Selection Sort 选择排序是一种非常简单、直观的排序方式。它将整个序列分为两部分，有序部分和无序部分。以将无序序列升序化为例，整个序列前面部分为有序部分（初始长度为0），后面部分为无序部分（完成有序化后长度为0）。为什么要叫选择排序呢？因为它每次遍历整个无序序列，选择出数值最小的元素，将其提到有序部分的最末尾。不断重复次过程，直到无序部分长度减为0。 ### 工作过程 n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下： &gt; **初始:** 初始状态：序列前面部分为有序区，此时为空；序列后面部分为无序区，当前范围为R[1..n]&gt; **STEP1:** 第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中选出关键字最小的记录R[k]，将它与无序区的*第1个记录R*交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区&gt; **STEP2:** 重复STEP1，直至无序区长度为0，完成排序 ### 动画演示 ![selection sort](http://louiszhai.github.io/docImages/sort06.gif) ### Java代码 ```java public void coreSort() { int unsorted_min = 0, sorted_last; //the former is the index of the min value of unsorted part, and the later is the index of the last element in the sorted part for(sorted_last = 0; sorted_last &lt; arr.length-1; ++sorted_last){ for(int j = sorted_last+1; j &lt; arr.length; ++j)//find the min value within the unsorted part if(arr[j] &lt; arr[unsorted_min]) unsorted_min = j; swap(sorted_last, unsorted_min); } } ``` &gt; **[查看完整代码](https://github.com/LeeYatSan/Algorithms/tree/master/Sorting%20Algorithms)** ## 直接插入排序 Direct Insertion Sort 直接插入排序是插入排序的一种方式，也是一种简单直观的排序方式。它也将序列分为两个部分，前面部分为有序化区，后面部分为未排序区。每次取出未排序区中的第一个元素，从一排序区中的最后一个元素开始向前遍历，直到找到一个比当前元素小的元素，将当前元素插入到所寻找到的元素的下一个位置，而该位置后面直到未排序区的第一个元素（即进行插入的元素）向前顺移一位。 ### 工作过程 n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下： &gt; **初始:** 序列前面部分为有序区，默认首元素为有序区初始元素；序列后部分为无序区，当前范围为R[2..n] &gt; **STEP1:** 取出下一个元素，在已经排序的元素序列中从后向前扫描 &gt; **STEP2:** 如果该元素（已排序）大于新元素，将该元素移到下一位置 &gt; **STEP3:** 重复STEP2，直到找到已排序的元素小于或者等于新元素的位置 &gt; **STEP4:** 将新元素插入到该位置后 &gt; **STEP5:** 重复STEP1-STEP4，直到完成排序 ### 动画演示 ![direct insertion sort](http://louiszhai.github.io/docImages/sort07.gif) ### Java代码 ```java public void coreSort(){ int unsorted_first = 1;//the index of the first element of the unsorted part for(; unsorted_first &lt; arr.length; ++unsorted_first){ int curr = arr[unsorted_first];//keep the value of the first element in the unsorted part int i = unsorted_first - 1; for(; i &gt; -1 &amp;&amp; arr[i] &gt; curr; --i){//move ahead to the first element from the last element of the sorted part, and exchange the value if current value is larger than the current value of the first element in the unsorted part. This process will loop until find a value is smaller than the current first element of the unsorted part. arr[i+1] = arr[i]; } arr[i+1] = curr; } } ``` &gt; **[查看完整代码](https://github.com/LeeYatSan/Algorithms/tree/master/Sorting%20Algorithms)** ## 希尔排序 Shell Sort 希尔排序是Donald Shell在1959年公布的一种对直接插入排序算法进行改进的一种插入排序算法，它突破了直接插入排序算法时间复杂度O(n^2)的限制。传统的直接插入排序每次只能移动一格，最坏情况有n^2次，而希尔排序则可以大跨步的移动，加快了排序效率。 一个更好理解的希尔排序实现：将数组列在一个表中并对列排序（用插入排序）。重复这过程，不过每次用更长的列来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身仅仅对原数组进行排序（通过增加索引的步长，例如是用i += step_size而不是i++） ### 增量序列 由上述描述可以得知，希尔排序依赖于一个增量序列，而这个增量序列也成为希尔增量。下面列举常用的希尔增量，其中已知的最好步长序列是由Sedgewick提出的。 &gt; **希尔增量：** ht = N / 2, h[k] = h[k+1] / 2，即{N/2, (N / 2)/2, ..., 1} &gt; **Hibbard增量：**{1, 3, ..., 2^k-1} &gt; **Sedgewick增量：**{1, 5, 19, 41, 109...}，由9\\*4^i - 9\\*2^i + 1或者是4^i - 3*2^i + 1得出 ### 工作过程 &gt; **初始:** 确定一个单调递减的序列，t1，t2，…，tk，其中ti&gt;tj，tk=1。其中包含k个元素，即意味着要进行k轮排序。该序列中的每个元素代表这该轮排序的跨度（即两个待比较的元素之间相隔多少个元素） &gt; **STEP1:** 第i趟排序中，根据初始确定的序列，每隔i个元素取为一个子序列，对该子序列进行直接插入排序 &gt; **STEP2:** 重复STEP1，直到完成k趟排序 ### 动画演示 ![shell sort](https://img2018.cnblogs.com/blog/751560/201812/751560-20181204164005988-481309690.gif) ### Java代码 ```java public void coreSort(){ int gap = arr.length/2;//To simplify, we used Shell Increment while(gap &gt; 0){ for(int unsorted_first = gap; unsorted_first &lt; arr.length; ++unsorted_first){ int curr = arr[unsorted_first]; int i = unsorted_first-gap; for(; i &gt; -1 &amp;&amp; arr[i] &gt; curr; i-=gap){ arr[i+gap] = arr[i]; } arr[i+gap]=curr; } gap/=2; } } ``` &gt; **[查看完整代码](https://github.com/LeeYatSan/Algorithms/tree/master/Sorting%20Algorithms)** ## 归并排序 Merge Sort 归并采用分而治之，并行操作以及递归的思想。将一个长为n的序列分为两个n/2的子序列，然后对每个子序列进行归并排序，直至最终的子序列长度不超过2为止。对于每个子序列，最终实现排序，然后再到子序列之间的排序，最终实现整个序列的排序。 ### 工作过程 &gt; **STEP1:** 每一趟，若当前序列长度大于2，则先将当前序列平分为两部分；若无法再分，则进入STEP4&gt; **STEP2:** 对平分后产生的两个子序列分别调用归并排序&gt; **STEP3:** 重复执行STEP1和STEP2 &gt; **STEP4:** 对每个子序列进行排序&gt; **STEP5:** 同级每相邻两子序列分别完成排序后，两子序列之间再次进行排序，形成更大一级子序列&gt; **STEP6:** 重复STEP6直至完成排序 ### 动画演示 ![merge sort](http://louiszhai.github.io/docImages/sort08.gif) ### Java代码 #### 数组形式 ```java public class MergeSort extends Sort{ MergeSort(int[] arr){ super(arr); } public void coreSort(){ mergeSort(0, arr.length-1); } private void merge(int start, int end){ int mid = (start+end)/2; int[] temp = new int[end-start+1]; int index = 0; int left = start, right = mid+1; while(left &lt;= mid &amp;&amp; right &lt;= end) temp[index++] = arr[left] &lt;= arr[right] ? arr[left++] : arr[right++]; while(left &lt;= mid) temp[index++] = arr[left++]; while(right &lt;= end) temp[index++] = arr[right++]; for(int k = 0; k &lt; temp.length; ++k) arr[start+k] = temp[k]; } private void mergeSort(int start, int end){ if(end - start &lt; 1) return; int mid = (start+end)/2; mergeSort(start, mid); mergeSort(mid+1, end); merge(start, end); }} ``` &gt; **[查看完整代码](https://github.com/LeeYatSan/Algorithms/tree/master/Sorting%20Algorithms)** #### 链表形式 链表形式关键在于利用快慢指针（快指针的速度是慢指针的1倍）来确定中间节点 ```java class Solution { public ListNode sortList(ListNode head) { if(head == null || head.next == null) return head; return mergeSort(head); } private ListNode mergeSort(ListNode head){ if(head == null || head.next == null) return head; ListNode fast = head, slow = head; while(fast.next != null &amp;&amp; fast.next.next != null){//use fast &amp; slow pointer to find the middle node fast = fast.next.next; slow = slow.next; } ListNode mid = slow.next; slow.next = null;//cut the linked list into two sub linked list return merge(mergeSort(head), mergeSort(mid)); } private ListNode merge(ListNode left, ListNode right){ ListNode head = left.val &lt; right.val ? left : right; ListNode currLeft = head == left ? left.next : left; ListNode currRight = head == right ? right.next : right; ListNode curr = head; while(currLeft != null &amp;&amp; currRight != null){ curr.next = currLeft.val &lt; currRight.val ? currLeft : currRight; curr = curr.next; if(curr == currLeft) currLeft = currLeft.next; else currRight = currRight.next; } curr.next = currLeft == null ? currRight : currLeft; return head; }} ``` &gt; **[查看完整代码](https://github.com/LeeYatSan/Algorithms/tree/master/Sorting%20Algorithms)** ## 快速排序 Quick Sort 快速排序是通过把一个序列分隔为两个字串，且其中一个字串的所有元素都比另一个字串小。然后对每个字串分别进行快速排序，实现递归，最终实现排序。 ### 工作过程 &gt; **STEP1:** 从当前字串中选取一个元素作为基值&gt; **STEP2:** 当前字符串剩余所有元素与基值比较，比基值小或等于的元素放入左子串，比基值大的元素放入右子串&gt; **STEP3:** 对每个子串重复STEP1和STEP2，直至所有子串不可再分（通常长度为1），完成排序 ### 动画演示 ![quick sort](http://louiszhai.github.io/docImages/sort09.gif) ### Java代码 ```java public class QuickSort extends Sort { QuickSort(int[] arr){ super(arr); } public void coreSort(){ quickSort(0, arr.length-1); } private void quickSort(int start, int end){ if(start &gt;= end) return; int privot_index = partition(start, end); quickSort(start, privot_index); quickSort(privot_index+1, end); } private int partition(int start, int end){ int pivot = arr[start];//we select the first element of the sequence as the pivot, which means we need to traverse the sequence from the last firstly while(start &lt; end){ while(start &lt; end &amp;&amp; pivot &lt;= arr[end])//traverse the sequence until we find an element which value is smaller than the pivot's value --end; if(start &lt; end)//if we find an element which value is smaller than the pivot's value, then swap them swap(start++, end); while(start &lt; end &amp;&amp; pivot &gt;= arr[start])//traverse the sequence from the head until we find an element which value is larger than the pivot's value start++; if(start &lt; end) swap(start, end--);//if we find an element which value is larger than the pivot's value, then swap them } return start; }} 查看完整代码 堆排序 Heap Sort在讨论堆排序之前，我们先了解一下堆这种数据结构。堆分为大、小顶堆，具有子结点的键值或索引总是小于（或者大于）它的父节点的性质。堆排序是一种树形选择排序，在排序过程中可以把元素看成是一颗完全二叉树，根据堆的性质可得：每个节点都大（小）于它的两个子节点。 这里以长度为n大顶堆为例。 堆排序性能 不稳定排序 时间复杂度： 最好情况：O(nlgn) 平均情况：O(nlgn) 最差情况：O(nlgn) 工作过程在构造有序堆时，我们开始只需要扫描一半的元素[0, n/2-1]即可，为什么?因为根据完全二叉树的性质，只有序号为[0, n/2-1]的节点才有子节点，如下图所示，n=8,(n/2-1) = 3 即3 2 1 0这个四个节点才有子节点。 我们需要注意的是，假设当前节点的序号为k，则其父母节点的序号为k/2向下取整的值，而其左子节点的序号为2k+1，其右节点的序号为2k+2。如上图所示，3号节点的父母节点为3/2向下取整即为1号节点，其左子节点为3*2+1=7号节点，其右节点为3*2+2=8号节点。 一个共有 n 个结点的堆在第 h 层最多的结点数为： heapify()：堆化操作：它的时间复杂度等于当前元素的层数k = lgn ， 即 O(lgn).buildMaxHeap()：建堆操作：O(n). STEP1: 先将长度为n的待排序数组建立一个大顶堆STEP2: 交换堆顶与结尾的元素，即将大顶堆的顶（即最大的元素）放在数组最后Rn，此时产生了一个R[1…n-1]的无序序列与一个Rn的有序序列STEP3: 由于交换可能导致失序，因此重新对对进行”堆化”STEP4: 对无序序列重复STEP1，STEP2，STEP3，完成排序 动画演示 Java代码1234567891011121314151617181920212223242526272829303132 public class HeapSort extends Sort { HeapSort(int[] arr){ super(arr); } public void coreSort(){ buildMaxHeap(); for(int i = arr.length -1; i &gt;= 1; --i){//loop until the length of the sequence is less than 2 swap(0, i); heapify(0, i); } } private void buildMaxHeap(){//build a max heap for(int i = arr.length/2-1; i&gt;=0; i--)//build max heap for all non-leaf nodes heapify(i, arr.length); } private void heapify(int curr_index, int size){//to adjust the heap to a max heap int left_index = 2*curr_index+1, right_index = 2*curr_index+2; int largest_index = curr_index; if(left_index &lt; size &amp;&amp; arr[left_index ] &gt; arr[largest_index])//to find the largest one among current node and its child nodes largest_index = left_index; if(right_index &lt;size &amp;&amp; arr[right_index] &gt; arr[largest_index]) largest_index = right_index; if(largest_index != curr_index){//if current node is not the largest one, then exchange them swap(largest_index, curr_index);//exchange the value of current node and the largest node only, which means that the index of largest node is not changed but its value is not the largest one but current node one instead. In other words, the current node's index is changed to the ex-largest node's index. heapify(largest_index, size);//because of the exchange leading to the change of the current node's index, the max heap may be broken, which means we need to re-heapify a new one. } }} 查看完整代码 计数排序 Counting Sort计数排序是一种以空间换取时间的排序方式。它通过设立额外的计数数组C，统计待排序数组中每个值的出现的次数，最后再由计数数组生成有序数组。 工作过程 初始: 开辟一个新的计数数组C，其下标值对应待排序数组的每种数组的元素值，数组内元素记录的是待排序每种数值对应的出现次数STEP1: 找出待排序的数组中最大和最小的元素STEP2: 统计待排序数组的每种元素出现的次数，计数值根据元素值填入对应统计数组C对应下标的元素中，即统计数组中每个值为i的元素出现的次数，存入数组C的第i项STEP3: 对所有计数进行累加STEP4: 反向填充数组，得出有序化的数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1 动画演示 Java代码 public class CountingSort extends Sort { CountingSort(int[] arr){ super(arr); } public void coreSort(){ int min = arr[0], max = arr[0];//to keep the min and max value in unsorted array for(int i : arr){ if(i &gt; max) max = i; if(i &lt; min) min = i; } int bias = 0-min;//the min value may not equals to 0 int[] couting_arr = new int[max-min+1];//temp-counting array for (int i : arr) {//counting the number of each value in unsorted array couting_arr[i+bias]++;//i+bias makes sure that the first non-zero element's index is 0 } int i = 0, j = 0; while(i &lt; couting_arr.length){ if(couting_arr[i] != 0){ arr[j] = i - bias; --couting_arr[i]; ++j; } else i++; } } } 查看完整代码 桶排序 Bucket Sort桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序）。这里以递归使用桶排序为例。 工作过程 STEP1: 人为设置一个BucketSize，作为每个桶所能放置多少个不同数值（例如当BucketSize==5时，该桶可以存放｛1,2,3,4,5｝这几种数字，但是容量不限，即可以存放100个3）STEP2: 遍历输入数据，并且把数据一个一个放到对应的桶里去STEP3: 对每个不是空的桶进行排序，可以使用其它排序方法，也可以递归使用桶排序。注意，如果递归使用桶排序为各个桶排序，则当桶数量为1时要手动减小BucketSize增加下一循环桶的数量，否则会陷入死循环，导致内存溢出。STEP4: 从不是空的桶子里把项目再放回原来的序列中 动画演示 Java代码 查看完整代码 基数排序 Radix Sort基数排序也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn),为数组长度，k为数组中的数的最大的位数；基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。 工作过程 STEP1: 查找待排序数组中最大的数，并计算其位数STEP2: arr为原始数组，从最低位开始取每个位组成radix数组STEP3: 对radix进行计数排序（利用计数排序适用于小范围数的特点） 动画演示 Java代码 import java.util.ArrayList; public class RadixSort extends Sort { RadixSort(int[] arr){ super(arr); } public void coreSort(){ int max = arr[0]; for(int i : arr){//find the max value in the array if(max &lt; i) max = i; } int mod = 10, div = 1, max_digit = 0; while(max != 0){//calculate the digits of the max value max/=10; ++max_digit; } ArrayList&lt;ArrayList&lt;Integer&gt;&gt;buckets = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; 10; i++) buckets.add(new ArrayList&lt;&gt;()); for(int i = 0; i &lt; max_digit; mod*=10, div*=10, ++i){ for(int elem : arr) buckets.get((elem%mod)/div).add(elem); int index = 0; for(int k = 0; k &lt; buckets.size(); ++k){ ArrayList&lt;Integer&gt; curr = buckets.get(k); for(int j = 0; j &lt; curr.size(); ++j) arr[index++] = curr.get(j); curr.clear(); } } } } 查看完整代码 参考文献 [1] Sorting algorithm[2] 十大经典排序算法（动图演示）[3] 面试中的 10 大排序算法总结[4] 堆排序算法[5] 十大经典排序算法最强总结（含Java代码实现）[6] 排序算法图解（插入、选择、冒泡、快速、合并、希尔等等）","link":"/2019/03/03/排序算法总结/"},{"title":"面试总结","text":"本文档收录了在面试期间对Java及其他计算机知识的总结，希望秋招能斩获一个好OFFER！ Java基础谈谈你对Java的理解/Java有哪些优点？ 纯面向对象语言 平台无关性 Java提供了许多内置类库 Java提供了对Web应用开发的支持 具有较好的安全性和健壮性 去除了C/C++语言中难以理解、容易混淆的特性：如头文件、指针、结构体、单元运算符、虚拟基础类、多重继承等 Java与C++有什么异同? 都是是一门纯面向对象语言 Java没有C++中的指针、结构体、文件、单元运算、虚拟基础类、多重继承等概念。 由于没有指针等概念，Java的内存管理将由JVM自动完成，使得开发人员从中解放出来。 Java是一门平台无关的解释型语言，Java可以一次编译，然后在不同平台的JVM上运行。而C++与平台有关，是编译型语言，跨平台运行需要重新编译。 Java不支持自动强制类型转换，需要开发人员显示声明。 解释一下面向对象的三个特性？ 封装：即将客观事物封装成抽象类，它有一组数据变量以及方法，并可以对它们的访问性进行控制，可以将对不可信信息进行隐藏。在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。 继承：是指使得一种对象获得另一种对象的数据和方法，它支持按级分类的概念。它是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。 通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。继承的过程，就是从一般到特殊的过程。要实现继承，可以通过 “继承”（Inheritance）和“组合”（Composition）来实现。继承概念的实现方式有二类：实现继承与接口继承。实现继承是指直接使用 基类的属性和方法而无需额外编码的能力；接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力。 多态：通常是指同名方法中有多种实现方式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。 面向对象的五大基本原则？ 单一职责原则SRP(Single Responsibility Principle)：指一个类的功能尽可能单一，不要保罗万象，否则效率不高。 开放封闭原则OCP(Open－Close Principle)：指模块设计的时候应该对拓展开放，对修改内部代码封闭。 里式替换原则LSP(the Liskov Substitution Principle LSP)：指子类对象应该可以替换父类对象，并可以出现在任何父类对象可以出现的地方。 依赖倒置原则DIP(the Dependency Inversion Principle DIP)：指具体依赖抽象，上层依赖下层。假设B模块（下层）依赖于A模块（上层），但B需要使用到A的功能，这个时候，B不应当直接使用A中的具体类： 而应当由B定义一抽象接口，并由A来实现这个抽象接口，B只使用这个抽象接口：这样就达到了依赖倒置的目的，B也解除了对A的依赖，反过来是A依赖于B定义的抽象接口。通过上层模块难以避免依赖下层模块，假如B也直接依赖A的实现，那么就可能 造成循环依赖。一个常见的问题就是编译A模块时需要直接包含到B模块的cpp文件，而编译B时同样要直接包含到A的cpp文件。 接口分离原则ISP(the Interface Segregation Principle ISP)：模块间要通过抽象接口隔离开，而不是通过具体的类强耦合起来。 说说你对面向对象编程的理解？ 面向对象编程，是指将现实世界的事物通过封装抽象成为一个个对象，它们可以有自己的数据与方法操作，并对不可信信息进行隐藏，从而达到模拟现实世界的效果。面向对象可以理解成对待每一个问题，都是首先要确定这个问题由几个部分组成，而每一个部分其实就是一个对象。然后再分别设计这些对象，最后得到整个程序。 介绍一下Java多态？ 多态的优点？ 消除类型之间的耦合关系 可替换性 可扩充性 接口性 灵活性 简化性 多态的必要条件？ 继承 重写 父类引用指向子类：E.g. p 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157#### Java多态的实现方式？ &gt; 1. 重写&gt; 2. 接口实现&gt; 3. 抽象类和抽象方法 ### 介绍一下Java基本数据类型及其长度？ &gt; | TYPE | BITS | Maximum | Minimum | NOTE |&gt; | :----: | :----: | :----: | :----: | :----: |&gt; | boolean | 1 | - | - | - |&gt; | byte | 8 | -128 | 127 | 首位符号位 |&gt; | char | 16 | Unicode 0 | Unicode 2^(16)-1 | - |&gt; | short | 16 | -2^15 | 2^(15)-1 | 首位符号位 |&gt; | int | 32 | -2^31 | 2^(31)-1 | 首位符号位 |&gt; | float | 32 | IEEE754```\\u0000 ```| IEEE754```\\uffff```| 单精度、不能表示精确值 |&gt; | double | 64 | IEEE754 | IEEE754 | 双精度、不能表示精确值 |&gt; | long | 64 | -2^65 | 2^(65)-1 | 首位符号位 | ### 基本类型和包装类型哪个占用资源多？为什么？ &gt; 基本类型的值就是一个数字，一个字符，或者一个布尔值，存放在栈空间中。 &gt; 包装类型是一个对象的引用，值是指向内存空间的引用，就是地址。所指向的内存中保存着变量所表示的一个值或一组值，存放在堆空间中。 &gt; 由于包装类型中还有一组方法函数，因此包装类型所占的资源多。 ### 介绍一下Java装箱和拆箱机制？ &gt; **装箱**：将基本类型用它们对应的引用类型包装起来。&gt; **拆箱**：将包装类型转换为基本数据类型。&gt; &gt; 在装箱过程中，注意Java会对一定范围内（例如int 在[-128，128]）会有缓存机制，在缓存范围内的装箱不会创建新的对象，而是直接引用相同对象。 &gt; 装箱操作会创建对象，频繁的装箱操作会消耗许多内存，影响性能，所以可以避免装箱的时候应该尽量避免。 ### Integer有符号吗？&gt; Java没有无符号类型，都是有符号类型的数据类型。 ### 0.1\\*3 == 0.3 结果是什么？1\\*0.3 == 0.3结果是什么？为什么？ &gt; 3\\*0.1 == 0.3 返回值 false&gt; 1\\*0.3 == 0.3 返回值 true&gt; &gt; 因为对于十进制数值系统（就是我们现实中使用的），它只能表示以进制数的质因子为分母的分数。10 的质因子有 2 和 5。因此 1/2、1/4、1/5、1/8和 1/10 都可以精确表示，因为这些分母只使用了10的质因子。相反，1/3、1/6 和 1/7 都是循环小数，因为它们的分母使用了质因子 3 或者 7。二进制下（进制数为2），只有一个质因子，即2。因此只能精确表示分母质因子是2的分数。 &gt; 二进制中，1/2、1/4 和 1/8 都可以被精确表示。但是，1/5 或者 1/10 就变成了循环小数。所以，在十进制中能够精确表示的 0.1 与 0.2（1/10 与 1/5），到了计算机所使用的二进制数值系统中，就变成了循环小数。当你对这些循环小数进行数学运算时，并将二进制数据转换成人类可读的十进制数据时，会对小数尾部进行截断处理。 ### Java中如何精确表示浮点数？&gt; Java通过Decimal和BigDecimal类来精确表示浮点数。 ### Java ```char``` 编码?&gt; Java 中 ```char``` 是16位 UTF16 编码的 ### 实例方法和静态方法加载区别？&gt; 首先解类编译的class文件中字节码的方法调用指令&gt; &gt; 1. invokestatic：调用静态方法&gt; 2. invokespecial：调用实例构造器方法，私有方法。&gt; 3. invokevirtual：调用所有的虚方法，说明运行期间会到方法表中去调用真实指向的方法。&gt; 4. invokeinterface：调用接口方法，会在运行时再确定一个实现此接口的对象。&gt; 5. invokedynamic：先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法。 &gt; &gt; 对于**实例方法**，在编译阶段会调用invokevirtual指令，它会根据实例的具体类型查找对应的方法表并进行方法绑定（方法重写发生在此时）； &gt; 对于**静态方法**，在编译阶段会调用invokestatic指令，它不会查找方法表，而是直接绑定方法，即静态方法的执行只看静态类型，而与实际类型无关，这也是为什么静态方法不能被重写。 ### 重写和重载区别 &gt; **重写**：发生在父子类中，方法名、参数列表必须相同，子类同名同参函数的返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为 private 则子类就不能重写该方法。**只有实例方法可以被重写，静态方法不能被重写！**因为静态方法的调用的是通过在编译器静态绑定的，而实例方法的调用是在运行时动态绑定的，2者的调用的方式不同，所以二者只能存在其一，否则会存在歧义！但当父类和子类都存在同名同惨函数时，因为调用方式一致，不会像上面造成歧义，虽然父类和子类都定义了同样的函数，但是编译器会根据对象的静态类型激活对应的静态方法的引用，造成了重写的假象，实则不是重写！ &gt; **重载**：放生在同一个类中，方法名相同，但参数类型、个数、顺序不同的函数，同时，它们的返回值类型和访问控制符可以不同。**重载发生在编译阶段。** ### super与this异同 &gt; **super**：指向当前对象的父类，它是一个引用但是却没办法输出。 &gt; **super()**：父类构造方法。如果子类构造方法没有显示地调用父类的构造方法，那么编译器会自动为它加上一个默认的super()方法调用。如果父类由没有默认的无参构造方法，编译器就会报错。super()语句必须在构造方法第一行调用，否则编译器会报错。 &gt; **this**：this是一个引用类型， 在堆中的每一个Java对象上都有this，this保存内存地址指向自身。 &gt; **this()**：当前类构造方法。通过this()调用其他构造方法时,必须放在第一行，否则编译器会报错。且在构造方法中，只能通过this()调用一次其他构造方法。 &gt; &gt; **注意**：&gt; &gt; 1. super()和this()不能共存。&gt; 2. super();调用了父类中的构造方法，虚拟机会创建父类对象，但不是new 出来的，而是虚拟机在执行字节码时在初始化方法 init（该方法在字节码中）中创建的对象！&gt; 3. 在Java语言中只要是创建Java对象，那么Object中的无参数构造方法一定会执行。 ### 匿名内部类有构造器吗？ &gt; 1. **匿名内部类是唯一一种没有构造器的类**。&gt; 2. 一般使用匿名内部类的方法来编写事件监听代码。&gt; 3. 匿名内部类不能有访问修饰符和static修饰符。&gt; 4. 匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。 ### 介绍一下 Error 和 Exception ？ &gt; Error 和 Exception 都共同继承于 Throwable 类。 &gt; &gt; **异常和错误的区别:异常能被程序本身可以处理，错误是无法处理。**&gt; #### Throwable 类常用方法？&gt; 1. ```public string getMessage()```：返回异常发生时的详细信息&gt; 2. ```public string toString()```：返回异常发生时的简要描述&gt; 3. ```public string getLocalizedMessage()```：返回异常对象的本地化信息。使用Throwable的子类覆盖这个方法，可以声称本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与getMessage()返回的结果相同&gt; 4. ```public void printStackTrace()```：在控制台上打印Throwable 对象封装的异常信息&gt; #### Error &gt; **是程序无法处理的错误**，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM 出现的问题。例如，Java虚拟机运行错误(Virtual MachineError)，当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机(JVM)一般会选择线程终止。 **这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时**，如Java虚拟机运行错误(Virtual MachineError)、类定义错误(NoClassDefFoundError)等。**这些错误是不可查的，因为它们在应用程序的控制和处理能力之外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。**在 Java中，错误通过Error的子类描述。#### Exception&gt; **是程序本身可以处理的异常**。Exception 类有一个重要的子类 RuntimeException。 RuntimeException 异常由Java虚拟机抛出。&gt; &gt; 在异常处理的时候应该注意：&gt; &gt; 1. **不要在finally代码块中处理返回值**：按照我们的惯性认知：当遇到return语句的时候，执行函数会立刻返回。但是，在Java语言中，如果存在finally就会有例外。除了return语句，try代码块中的break或continue语句也可能使控制权进入finally代码块。尽量不要在try代码块中调用return、break或continue语句，否则就要确保finally不会改变函数的返回值。 &gt; &gt; 2. **当一个try后跟多个catch需要先捕获小异常在捕获大异常**&gt; 3. finally中的代码始终是执行的，目的是为了清理资源（除非线程或者程序被中断）。 ### 说出几种常见的错误和运行时异常？ &gt;#### 错误 &gt; 1. **StackOverFlowError**：当前栈深度超过最大JVM栈深度，常常由无限递归造成。&gt; 2. **OutOfMemoryError**：没有足够的内存进行分配，一是改JVM内存大小（JVM使用```-XX:PermSize```设置非堆内存初始值，默认是物理内存的1/64；用```-XX:MaxPermSize```设置最大非堆内存的大小，默认是物理内存的1/4）。&gt; 3. **VirtualMachineError**：JVM运行时错误。&gt; 4. **NoClassDefFoundError**：类定义错误。发生在类加载的**初始阶段**，通常是如类依赖的class文件或者jar不存在、类文件存在，但存在不同的域中或者大小写问题（javac编译时是无视大小写的，很有可能编译出来的class文件与想要的不一样）。&gt; #### 运行时异常&gt; 1. **NullPointerException**：空指针异常。&gt; 2. **ClassNotFoundException**：找不到类异常。找不到指定的class，发生在**加载阶段**。常见的场景：调用class的forName方法，找不到指定的类、ClassLoader 中 findSystemClass，找不到指定的类、ClassLoader中loadClass，找不到指定的类等。&gt; 3. **ArithmeticException**：算术异常。如除0。&gt; 4. **ArrayIndexOutOfBoundsException**：数组下标越界异常。&gt; 5. **RuntimeException**：运行时异常。由JVM抛出。&gt; 6. **InterruptedException**：当线程处于阻塞状态时，调用了 interrupted() 方法。&gt; 7. **IllegalMonitorStateException**：在同步语块以外调用 wait()、notify() 和 notifyAll() 方法引起。 ### 说一下final finally finalize有什么不同？ &gt; &gt; #### final&gt; final关键字主要用在三个地方：变量、方法、类。&gt; &gt; 对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。&gt; &gt; 当用final修饰一个类时，表明这个类不能被继承。final类中的所有成员方法都会被隐式地指定为 final方法。此外，**对于一个类中所有的private方法，都会被隐式地指定为final**。&gt; &gt; 使用 final 方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率：在早期的Java实现版本中，会将 final 方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升(现在的Java版本已经不需要使用final方法进行这些优化了)。&gt; &gt; #### finally&gt; finally块用于try{...}catch{...}语块后，无论是否捕获或处理异常，finally块里的语句都会被执行。当在try块或catch块中遇到return语句 时，finally语句块将在方法返回之前被执行。**finally中的代码始终是执行的，目的是为了清理资源（除非线程或者程序被中断）**。&gt; &gt; #### finalize&gt; finalize用于在GC回收内存前，给予即将被回收的对象一次”复活“的机会。对于GC可达性分析法中被认定为不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程：&gt; 1. 可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。 &gt; &gt; 2. 被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。&gt; ### String 底层实现的 char[] 为什么要用 final 修饰？&gt; Java 将 String 设成不可变最大的原因是**效率**和**安全**：&gt; &gt; 1. **不可变的 String 可以提高 String Pool(字符串常量池)的效率和安全性**。在拷贝的 String 对象的内容时，用于它时不可变的，因此不用复制它本身，而只需要复制它的地址，而复制地址(通常一个指针的大小)只需要很小的内存，且效率也很好。对于其他引用同一个对象的其他变量也不会造成影响。&gt; &gt; 2. 可不变的 String 对于多线程是安全的，因为在多线程并发进行的情况下，一个可变对象的值很可能被其他线程改变这样会造成不可预期的结果，使用不可变对象就可以避免这种情况出现。 ### 说一下 String 添加字符实现机制? &gt; 由于 String 是不可变类型，因此对 String 添加字符实际上是创建一个新的字符对象，并将当前变量引用指向新创建的对象上。其底层过程如下：&gt; ```.String a = &quot;abd&quot;;a = a + &quot;d&quot;; 对于 Java 8 有： 首先调用1&gt; 2. 创建一个StringBuilder对象```StringBuilder sb = new StringBuilder(String.valueOf(a)) 将要拼接的字符通过调用StringBuilder的1234567891011&gt; 4. 调用StringBuilder的```toString()```方法返回结果。&gt; &gt; 因此，会出现如下现象：&gt; ```.String a = null;a = a + &quot;d&quot;;System.out.println(a);// Output: nulld 值得注意的是，通过比较使用```+``` 拼接也会导致产生大量无引用的对象，会引发 GC 。因此为了执行效率考虑，字符串拼接的时候，建议使用```StringBuilder```进行拼接。12345678910111213141516171819202122232425262728&gt; &gt; Java 9 开始使用了```invokeDynamic```指令，可以动态指定要调用的方法，而不是一开始就编译好的。JDK9以拼接会创建新的对象，JDK9之后拼接静态字符串则不会。 ### 介绍一下Java 9 中 String 的改动？&gt; Java 8 中数组底层是用 ```char[]``` 来存储的。而在 Java 9 中，则是改由 ```byte[] + coder``` 来存储的。&gt; &gt; 但 Java 中 char 是16位UTF16 编码的，那么 ```byte[]``` 是如何存储 ```char[]``` 的呢？&gt; &gt; ![Java 9 中 String 的改动1](面经/16.png) &gt; &gt; 这里是通过 ```StringUTF16.compress(value, off, len)``` 来判断，如果 char[] 存在 value &gt; 0xFF 的值时，就返回null。&gt; &gt; ![Java 9 中 String 的改动1](面经/17.png) &gt; &gt; 如果 char[] 所有的字符都是小于 0xFF ，那么正好让一个 byte 对应一个 char，String 构造到此结束。&gt; &gt; 只要存在一个 char &gt; 0xFF，那么将会把byte数组的长度改为两倍char数组的长度，用两个字节存放一个 char&gt; &gt; ![Java 9 中 String 的改动1](面经/18.png) &gt; &gt; 由于实现机制的变动，所有的String方法都重新实现了一遍，但对外的接口还是保持一致的。重构带来的最大好处就是在字符串中所有的字符都小于 0xFF 的情况下，会节省一半的内存。 ### StringBuilder 与 StringBuffer 的区别 &gt; 两者都是用于字符串拼接的。但 StringBuilder 是线程不安全的， StringBuffer 是线程安全的。但由此也导致 StringBuilder 的效率要高于 StringBuffer。 ### ```==``` 与 ```equals()```的区别？ &gt;&gt; #### ```== 它的作用是判断两个对象的地址是不是相等，即判断两个对象是不是同一个对象。(基本数据类型 == 比较的是值，引用数据类型==比较的是内存地址) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798&gt; 它的作用也是**判断两个对象是否相等**。但它一般有两种使用情况:&gt; &gt; 1. 类没有重写 ```equals()``` 方法。则通过 ```equals()``` 比较该类的两个对象时，等价于通过 ```==``` 比较这两个对象。 &gt; 2. 类重写了 ```equals()``` 方法。一般，我们都重写 ```equals()``` 方法来两个对象的内容相等，若它们的内容相 等，则返回 true (即，认为这两个对象相等)。 ### 为什么 ```equals()``` 和 ```hashCode()``` 要一起重写？&gt; 1. 如果两个对象相等，则 hashcode 一定也是相同的&gt; 2. 两个对象相等,对两个对象分别调用 ```equals()``` 方法都返回 true&gt; 3. 两个对象有相同的 hashcode 值，它们也不一定是相等的&gt; 4. 如果 ```equals()``` 方法不重写，则它与 ```==``` 的效果相同，即判断两个对象是不是同一个对象，因此需要重写该方法。因此```equals()``` 方法被重写过，则 ```hashCode()``` 方法也必须被重写&gt; 5. **```hashCode()``` 的默认行为是对堆上的对象产生独特值。**如果没有重写 ```hashCode()``` ，则该 class 的两个对象无论如何都不会相等(即使这两个对象指向相同的数据) ### 为什么两个对象有相同的 hashcode 值,它们也不一定是相等的?&gt; 因为 ```hashCode()``` 所使用的杂凑算法可能刚好会让多个对象传回相同的杂凑值。越糟糕的杂凑算法越容易碰撞，但这也与数据值域分布的特性有关（所谓碰撞也就是指的是不同的对象得到相同的 hashCode ）。&gt; &gt; 如同 HashMap ,如果 HashMap 在对比的时候，同样的 hashcode 有多个对象，它会使用 ```equals()``` 来判断是否真的相同。也就是说 **hashcode 只是用来缩小查找成本，而不是唯一标记一个对象**。 ### 什么是 Java 浅拷贝与深拷贝？ &gt;#### 浅拷贝&gt; 1. 对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象。因为是两份不同的数据，所以对其中一个对象的该成员变量值进行修改，不会影响另一个对象拷贝得到的数据。&gt; &gt; 2. 对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数组、某个类的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用值（内存地址）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值。&gt; &gt; 具体模型如图所示：可以看到基本数据类型的成员变量，对其值创建了新的拷贝。而引用数据类型的成员变量的实例仍然是只有一份，两个对象的该成员变量都指向同一个实例。&gt; &gt; ![浅拷贝](面经/19.png)&gt; &gt; 浅拷贝的主要实现方式：&gt; &gt; 1. **通过拷贝构造方法实现浅拷贝**：拷贝构造方法指的是该类的构造方法参数为该类的对象。使用拷贝构造方法可以很好地完成浅拷贝，直接通过一个现有的对象创建出与该对象属性相同的新的对象。&gt; &gt; 2. **通过重写 clone() 方法进行浅拷贝**：Object 类是类结构的根类，其中有一个方法为 ```protected Object clone() throws CloneNotSupportedException``` ，这个方法就是进行的浅拷贝。有了这个浅拷贝模板，我们可以通过调用 clone() 方法来实现对象的浅拷贝。但是需要注意：1、Object 类虽然有这个方法，但是这个方法是受保护的（被 protected 修饰），所以我们无法直接使用。2、使用 clone() 方法的类必须实现 Cloneable 接口，否则会抛出异常 CloneNotSupportedException。对于这两点，我们的解决方法是，在要使用 clone() 方法的类中重写 clone() 方法，通过 super.clone() 调用 Object 类中的原 clone() 方法。&gt; #### 深拷贝&gt; 对于深拷贝来说，不仅要复制对象的所有基本数据类型的成员变量值，还要为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象。也就是说，对象进行深拷贝要对整个对象图进行拷贝！&gt; 简单地说，深拷贝对引用数据类型的成员变量的对象图中所有的对象都开辟了内存空间；而浅拷贝只是传递地址指向，新的对象并没有对引用数据类型创建内存空间。&gt; 深拷贝模型如图所示：可以看到所有的成员变量都进行了复制。 &gt; &gt; ![深拷贝](面经/20.png) &gt; &gt; 深拷贝的主要实现方式：&gt; &gt; 1. **通过重写clone方法来实现深拷贝**：与通过重写 clone() 方法实现浅拷贝的基本思路一样，只需要为对象图的每一层的每一个对象都实现 Cloneable 接口并重写 clone() 方法，最后在最顶层的类的重写的clone() 方法中调用所有的 clone() 方法即可实现深拷贝。简单的说就是：**每一层的每个对象都进行浅拷贝=深拷贝**。&gt; &gt; 2. **通过对象序列化实现深拷贝**：虽然层次调用 clone() 方法可以实现深拷贝，但是显然代码量实在太大。特别对于属性数量比较多、层次比较深的类而言，每个类都要重写 clone() 方法太过繁琐。将对象序列化为字节序列后，默认会将该对象的整个对象图进行序列化，再通过反序列即可完美地实现深拷贝。 ### 介绍一下内存泄露？&gt; 如果忘记“释放”先前分配的内存，就可能造成内存泄漏。如果程序保留对永远不再使用的对象的引用，这些对象将会占用并耗尽内存，这是因为自动化的垃圾收集器无法证明这些对象将不再使用。如果存在一个对对象的引用，对象就被定义为活动的，因此不能删除。概括地说，内存泄漏产生的主要原因：**保留下来却永远不再使用的对象引用。**&gt; &gt; 为了确保能回收对象占用的内存，编程人员必须确保该对象不能到达。这通常是通过将对象字段设置为 null 或者从集合(collection)中移除对象而完成的。但是，注意，当局部变量不再使用时，没有必要将其显式地设置为 null。对这些变量的引用将随着方法的退出而自动清除。&gt; #### 内存泄露例子？&gt; 1. **全局集合**：在大的应用程序中有某种全局的数据储存库是很常见的，例如一个JNDI树或一个会话表。在这些情况下，必须注意管理储存库的大小。必须有某种机制从储存库中移除不再需要的数据。这可能有多种方法，但是最常见的一种是周期性运行的某种清除任务。该任务将验证储存库中的数据，并移除任何不再需要的数据。另一种管理储存库的方法是使用反向链接(referrer)计数。然后集合负责统计集合中每个入口的反向链接的数目。这要求反向链接告诉集合何时会退出入口。当反向链接数目为零时，该元素就可以从集合中移除了。&gt; 2. **缓存**：没有正确地选用合适的缓存过期淘汰算法。最好的办法是对缓存的大小进行限制。&gt; 3. **HashMap 元素没有重写 equals() 或者 hashCode() 方法导致插入大量重复元素**。&gt; 4. **ThreadLocal 在线程池中没有及时清除**：在不使用 ThreadLocal 后，要手动设为 null 并在 ```finally{...}``` 语句中调用 remove() 方法清除。&gt; 5. **数据库连接没有及时关闭**。&gt; #### 内存泄露检测工具？&gt; 1. **详细输出**：有许多监控垃圾收集器活动的方法。而其中使用最广泛的可能是使用 ```-Xverbose:gc``` 选项启动 JVM，并观察输出，观察垃圾收集所使用的堆的容量。&gt; 2. **JRockit Management Console 控制台**：JRockit Management Console 可以显示堆使用量的图示。借助于该图，可以很容易地**看出堆使用量是否随时间增加**。&gt; 3. **JRockit Memory Leak Detector**：JRockit Memory Leak Detector 可以用来查看内存泄漏，并可以更深入地查出泄漏的根源。这个强大的工具是紧密集成到 JRockit JVM 中的，其开销非常小，对虚拟机的堆的访问也很容易。JRockit Memory Leak Detector 是通过在每次垃圾收集时计算每个类的现有对象的数目来实现这一步的。**如果特定类的对象数目随时间而增长（“增长率”），就可能发生了内存泄漏。** ### 列举 Object 类方法？```.public final native Class&lt;?&gt; getClass()//native方法，用于返回当前运行时对象的Class对象，使用了 final 关键字修饰，故不允许子类重写。 public native int hashCode() //native方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的 HashMap。public boolean equals(Object obj)//用于比较2个对象的内存地址是否相等，String 类对该方法进行了重写用户 比较字符串的值是否相等。protected native Object clone() throws CloneNotSupportedException// naitive 方法，用于创建并返回 当前对象的一份拷贝。一般情况下，对于任何对象 x，表达式 x.clone() != x 为true，x.clone().getClass() == x.getClass() 为 true 。 Object 本身没有实现 Cloneable 接口，所以不重写 clone 方法并且进行调用的话会发生 CloneNotSupportedException 异常。public String toString()//返回类的名字@实例的哈希码的16进制的字符串。建议 Object 所有的子类都重写这个方法。public final native void notify()// native方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视 器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。public final native void notifyAll()// native方法，并且不能重写。跟notify一样，唯一的区别就是会唤醒 在此对象监视器上等待的所有线程，而不是一个线程。public final native void wait(long timeout) throws InterruptedException// native 方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait() 方法释放了锁。timeout 是等待时间。public final void wait(long timeout, int nanos) throws InterruptedException//多了 nanos 参数， 这个参数表示额外时间(以毫微秒为单位，范围是 0-999999)。 所以超时的时间还需要加上 nanos 毫秒。public final void wait() throws InterruptedException//跟之前的2个 wait 方法一样，只不过该方法一直等待，没有超时时间这个概念。protected void finalize() throws Throwable { }//实例被垃圾回收器回收的时候触发的操作 接口和抽象类的区别是什么？ 接口的方法默认是 public，所有方法在接口中不能有实现（Java 8 开始接口方法可以用 关键字修饰进行默认实现），抽象类可以有非抽象的方法1234567891011121314151617181920212223242526272829303132333435&gt; 2. 接口中的实例变量默认是 final 类型的，而抽象类中则不一定&gt; 3. 一个类可以实现多个接口，但最多只能实现一个抽象类&gt; 4. 一个类实现接口的话要实现接口的所有方法，而抽象类不一定&gt; 5. 接口不能用 new 实例化，但可以声明，但是必须引用一个实现该接口的对象从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。&gt; &gt; 备注:在 Java 8 中，接口也可以定义静态方法，可以直接用接口名调用。实现类和实现是不可以调用的。如果同时实现 两个接口，接口中定义了一样的默认方法，必须重写，不然会报错。 ### 什么是反射？&gt; JAVA 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种**动态获取信息以及动态调用对象方法的功能称为 Java 语言的反射机制。**&gt; #### 反射的用途&gt; 在日常的第三方应用开发过程中，经常会遇到某个类的某个成员变量、方法或是属性是私有的或是只对系统应用开放，这时候就可以利用 Java 的反射机制通过反射来获取所需的私有成员或是方法。当然，也不是所有的都适合反射，之前就遇到一个案例，通过反射得到的结果与预期不符。阅读源码发现，经过层层调用后在最终返回结果的地方对应用的权限进行了校验，对于没有权限的应用返回值是没有意义的缺省值，否则返回实际值起到保护用户的隐私目的。&gt; #### 反射相关的类&gt; |类|用途|&gt; |:---:|---|&gt; |Class|代表类的实体，在运行的Java应用程序中表示类和接口。Class 对象是在加载类时由 Java 虚拟机自动构造的。也就是说我们不需要创建，JVM已经帮我们创建了。|&gt; |Field|代表类的成员变量（成员变量也称为类的属性）|&gt; |Method|代表类的方法|&gt; |Constructor|代表类的构造方法| ### 数据库驱动为什么使用反射调用不直接 new &gt; JDBC 只是 JDK 提出的一种 Java 连接数据库的规范，它提供了一些接口和抽象方法，并没有提供到某个具体数据库的实现，而是由各个数据库厂家来实现 JDBC ，比如上面提到的 mysql.Driver 就是一种具体实现。&gt; &gt; 因为反射是运行时根据全类名动态生成的 Class 对象，完全可以把这个全类名写在 xml 或者 properties 中去，不仅**从代码上解耦和**，而且需要**更换数据库时，不需要进行代码的重新编译**，只需要在配置文件中，更改相应的驱动和 URL 即可。 ### JDBC 连接查询过程&gt; 数据库连接过程： ```.Class.forName(&quot;com.mysql.jdbc.Driver&quot;);String url=&quot;jdbc:mysql://localhost/test&quot;;Stirng user=&apos;root&apos;;String password=&apos;root&apos;;Connection conn = DriverManager.getConnection(url,user,password); 1、Driver 类，Driver 通过静态代码块把自己注册到 DriverManager 中，这也是下一步``` Connection conn 123456789101112131415161718192021222324&gt; &gt; **JDBC 的 DriverManager 是一个工厂类，我们通过它来创建数据库连接。**当 JDBC 的 Driver 类被加载进来时，它会自己注册到DriverManager 类里面。然后我们会把数据库配置信息传成DriverManager.getConnection() 方法， DriverManager 会使用注册到它里面的驱动来获取数据库连接，并返回给调用的程序。&gt; &gt; 在实际的使用过程中，我们完全可以用 ```java.sql.DriverManager.registerDriver(new Driver())``` 这一句代码替换以反射加载驱动的方式，但这样会对具体的类产生依赖，导致后续更改不便。 ```.static { try { // 放入到一个CopyOnWriteArrayList中 java.sql.DriverManager.registerDriver(new Driver()); } catch (SQLException E) { throw new RuntimeException(&quot;Can&apos;t register driver!&quot;); }}/** * Construct a new driver and register it with DriverManager * * @throws SQLException * if a database error occurs. */public Driver() throws SQLException { // Required for Class.forName().newInstance()} 在加载完成后，一般还要调用 Class 下的静态方法来实例化对象以便操作。因为仅使用 ```Class.forName()``` 是动态加载类是没有用的，其最终目的是为了实例化对象。1234567891011&gt; &gt; 这里有必要提一下就是 Class 下的 ```newInstance()``` 和 ```new``` 有什么区别？，首先，```newInstance()``` 是一个方法，而```new``` 是一个关键字，其次，Class 下的 ```newInstance()``` 的使用有局限，因为它生成对象只能调用无参的构造函数，而使用 ```new``` 关键字生成对象没有这个限制。 &gt; &gt; 那为什么在加载数据库驱动包的时候有的却没有调用```newInstance()``` 方法呢？即有的 JDBC 连接数据库的写法里是```Class.forName(xxx.xx.xx)```；而有一 些：```Class.forName(xxx.xx.xx).newInstance()```？刚才提到，**```Class.forName()```的作用是要求 JVM 查找并加载（查找 -&gt; 加载 -&gt; 连接（验证 -&gt; 准备 -&gt; 解析） -&gt; 初始化）指定的类，如果在类中有静态初始化代码的话，JVM 必然会执行该类的静态代码段。**而在 JDBC 规范中明确要求这个 Driver 类必须向 DriverManager 注册自己，即任何一个 JDBC Driver 的 Driver 类的代码都必须类似如下： ```. public class MyJDBCDriver implements Driver { static { DriverManager.registerDriver(new MyJDBCDriver()); }} 既然在静态初始化器的中已经进行了注册，所以我们在使用 JDBC 时只需要12345678910111213141516171819202122232425262728&gt; &gt; JDBC 4.0以后新增了新特性：JDBC 4.0不再需要显式调用```Class.forName()```注册驱动，DriverManager 初始化中会通过 ServiceLoader 类，在我们 classpath 中 jar（数据库驱动包）中查找，使用 ```META-INF\\services\\java.sql.Driver```文本中的类名称去注册。也就说，在启动的时候，通过 jar 包下面的 ```java.sql.Driver```里的文本内容，帮你把驱动给加载了。&gt; &gt; 2、通过 DriverManager，使用 URL，用户名和密码建立连接(Connection)。本质上是调用了 mysql.Driver 的 connect方法，通过建立到数据库的socket连接，来完成接下来 SQL 的执行。 ```.for(DriverInfo aDriver : registeredDrivers) {// If the caller does not have permission to load the driver then skip it. if(isDriverAllowed(aDriver.driver, callerCL)) { try { System.out.println(&quot;trying &quot; + aDriver.driver.getClass().getName()); // 通过具体注册的driver的connect方法获取连接 Connection con = aDriver.driver.connect(url, info); if (con != null) { // Success! System.out.println(&quot;getConnection returning &quot; + aDriver.driver.getClass().getName()); return (con); } } catch (SQLException ex) { if (reason == null) { reason = ex; } } } else { System.out.println(&quot;skipping: &quot; + aDriver.getClass().getName()); }} 3、通过 Connection，使用 SQL 语句打开 Statement 对象。4、执行语句，将结果返回 resultSet。5、对结果 resultSet 进行处理。6、倒序释放资源 resultSet -&gt; preparedStatement -&gt; connection。 JNI底层实现 JNI 是 Java Native Interface 的缩写，通过使用 Java 本地接口书写程序，可以确保代码在不同的平台上方便移植。JNI 一开始是为了本地已编译语言，尤其是 C 和 C++ 而设计的，但是它并不妨碍你使用其他编程语言，只要调用约定受支持就可以了。使用 Java 与本地已编译的代码交互，通常会丧失平台可移植性。但是，有些情况下这样做是可以接受的，甚至是必须的。例如，使用一些旧的库，与硬件、操作系统进行交互，或者为了提高程序的性能。JNI 标准至少要保证本地代码能工作在任何 Java 虚拟机环境。 本地代码与 Java 虚拟机之间是通过 JNI 函数实现相互操作的。JNI 函数通过接口指针来获得，本地方法将 JNI 接口指针当作参数来接受。虚拟机保证在从相同的 Java 线程中对本地方法进行多次调用时，传递给本地方法的接口指针是相同的，本地方法被不同的 Java 线程调用时，它接受不同的 JNI 接口指针。 创建 native 方法步骤： 1、编写java程序，声明native方法：如果你想将一个方法做为一个本地方法的话，那么你就**必须声明该方法为 的，并且不能实现**。其中方法的参数和返回值在后面讲述。 **Load动态库**：```System.loadLibrary(\"hello\");```加载动态库（我们可以这样理解：我们的方法 displayHelloWorld()没有实现，但是我们在下面就直接使用了，所以必须在使用之前对它进行初始化）这里一般是以static块进行加载的。同时需要注意的是System.loadLibrary();的参数“hello”是动态库的名字。1234567891011```.public class HelloWorld { public native void displayHelloWorld();//所有native关键词修饰的都是对本地的声明 static { System.loadLibrary(&quot;hello&quot;);//载入本地库 } public static void main(String[] args) { new HelloWorld().displayHelloWorld(); }} 2、编译：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&gt; 3、**生成扩展名为h的头文件**：新版 jdk-10.0.2已经移除了```javah```命令工具，使用 ```javac HelloWorld.java -h JniH ```代替 ```javah HelloWorld ```命令生成扩展名为h的头文件。&gt; 4、**编写本地方法实现和由 javah 命令生成的头文件里面声明的方法名相同的方法**。&gt; 5、**生成动态库**。&gt; 6、**运行程序**。 ### 泛型 &gt; (...) ### 协程&gt; 协程，又称微线程，纤程。协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。注意，在一个子程序中中断，去执行其他子程序，不是函数调用，有点类似CPU的中断。**协程的特点在于是一个线程执行**。&gt; &gt; 那么，协程的优势在哪？&gt; &gt; 最大的优势就是**协程极高的执行效率**。因为子程序切换不是线程切换，而是由程序自身控制，因此，**没有线程切换的开销**，和多线程比，线程数量越多，协程的性能优势就越明显。&gt; 第二大优势就是**不需要多线程的锁机制**，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。&gt; &gt; 因为协程是一个线程执行，那怎么利用多核CPU呢？最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。### [Java 8 的新特性？](https://www.cnblogs.com/onetwo/p/8526374.html)&gt; 1. Lambda表达式和函数式接口&gt; 2. 接口的默认方法 ```default``` 和静态方法&gt; 3. 方法引用&gt; 4. 重复注解 ```@Repeatable``` &gt; 5. 更好的类型推断：Java 8编译器在类型推断方面有很大的提升，在很多场景下编译器可以推导出某个参数的数据类型，从而使得代码更为简洁。&gt; 6. 拓宽注解的应用场景：Java 8拓宽了注解的应用场景。现在，注解几乎可以使用在任何元素上：局部变量、接口类型、超类和接口实现类，甚至可以用在函数的异常定义上。&gt; 7. 引入 Optional：解决NullPointerException，从而避免源码被各种null检查污染，以便开发者写出更加整洁的代码。Optional仅仅是一个容易：存放T类型的值或者null。它提供了一些有用的接口来避免显式的null检查。&gt; 8. 新增的 Stream API（java.util.stream）将生成环境的函数式编程引入了Java库中。这是目前为止最大的一次对Java库的完善，以便开发者能够写出更加有效、更加简洁和紧凑的代码。&gt; 9. Java 8引入了新的Date-Time API(JSR 310)来改进时间、日期的处理。&gt; 10. 还有其他更多特性...... ### [Java 9 的新特性？](https://www.runoob.com/java/java9-new-features.html) &gt; 1. HTTP 2 客户端：HTTP/2标准是HTTP协议的最新版本，新的 HTTPClient API 支持 WebSocket 和 HTTP2 流以及服务器推送特性。&gt; 2. 多版本兼容 JAR 包：多版本兼容 JAR 功能能让你创建仅在特定版本的 Java 环境中运行库程序时选择使用的 class 版本。&gt; 3. 私有接口方法：在接口中使用private私有方法。我们可以使用 private 访问修饰符在接口中编写私有方法。&gt; 4. 集合工厂方法：List，Set 和 Map 接口中，新的静态工厂方法可以创建这些集合的不可变实例。&gt; 5. 模块系统：模块是一个包的容器，Java 9 最大的变化之一是引入了模块系统（Jigsaw 项目）。&gt; 6. 还有其他更多特性...... ### 最新的 Java 版本是多少？&gt; 截至2019年9月，最新版本为 Java 12&gt; &gt; #### [Java 12 的新特性？](https://blog.csdn.net/oldshaui/article/details/88684158)&gt; 1. Switch 表达式&gt; 2. G1的可中断 mixed GC&gt; 3. G1归还不使用的内存&gt; 4. 还有其他更多特性...... # Java集合类 ### 讲讲Java集合框架，把你知道的都讲出来 ### Collections用过什么 ### Collections.sort()底层用的什么排序方法（归并排序） ### Comparator和Comparable ### List遍历方式的选择 ### String的底层hashcode怎么写的 ### treemap底层数据结构，扩容，插入删除效率？ ### 介绍一下HashMap？&gt; #### 结构上 &gt; 在JDK 1.8之前底层是**数组+链表**形式实现的。HashMap的key的hashCode经过扰动函数处理后得到hash值，然后通过**(n-1) &amp; hash**（n指数组长度）判断当前元素的存放的下标位置。如果当前位置上已经存放了元素了，则先判断已经存放的元素的hash值与key值是否与将要插入的元素的相等，如果不相等，则通过拉链发（用链表）解决冲突；如果一样则直接覆盖。 从JDK 1.8开始，HashMap在解决hash冲突时放生了变化。当链表长度大于阈值（默认是8）时，将会自动将链表转换为**红黑树**进行存储。 #### hash()函数实现上 &gt; JDK 1.8 的 hash方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。&gt; &gt; JDK 1.8之前： static int hash(int h) { // This function ensures that hashCodes that differ only by // constant multiples at each bit position have a bounded // number of collisions (approximately 8 at default load factor). h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);}12 &gt; JDK 1.8开始： static final int hash(Object key) { int h;// key.hashCode():返回散列值也就是hashcode// ^ :按位异或// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);}123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362 ### HashMap链表转红黑树是怎么实现的 &gt; (...) ### HashMap内存溢出处理? &gt; HashMap内存溢出，说明插入了过多的Entry。HashMap中判断key是否相同是根据```e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))```判断的。引发内存溢出问题的原因一般是插入Entry的Key类的equals()和hashCode()方法没有重写，导致插入了大量重复的元素，进而导致内存泄露、内存溢出问题。解决方法就是重写equals()和hashCode()方法。 ### HashMap的key可以是基本类型吗？如果一定要定义为基本类型怎么做？ &gt; 不可以，因为HashMap中判断key是否相同是根据```e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))```判断的，在计算hash值的时候需要调用hashCode()方法，而基本类型不存在此方法，因此不可以使用基本类型。 &gt; 如果一定要使用基本类型作为key，那就需要重写HashMap。 ### HashMap的长度为什么2的幂次？ &gt; 因为虽然Hash值的 范围值-2147483648到2147483647，前后加起来大概40亿的映射空间，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个40亿长度的数组，内存是放不下的。所以这个散列值是不能直接拿来用的，用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。因此Entry在插入HashMap之前需要通过**(n-1) &amp; hash**计算下标。 &gt; **取余(%)操作中如果除数是2的幂次则等价于与其除数减一的与(&amp;)操作(也就是说```hash%length==hash&amp;(length-1)```的前提是length 是2的 n 次方)。**并且采用二进制位操作“&amp;“，相对于”%“能够提高运算效率，这就解释了HashMap的长度为什么是2的幂次方。 ### HashMap的扩容，HashMap并发操作下会有什么问题 ### HashMap怎么使用才是线程安全的 ### HashMap的链表为什么将长度为8是转化为红黑色的临界点？ ### 手写hashmap的get方法/set方法？### ConcurrentHashMap介绍？ ### ConcurrentHashMap怎么实现线程安全的？&gt; JDK 1.7分段锁，JDK 1.8 CAS + 链表/红黑树### List集合中有哪些线程安全的类？ # Java并发 ### 多线程三大特性？&gt; **原子性**：即一个或多个操作要么全部不做，要么全部都做。&gt; &gt; **可见性**：即多线程访问一个变量时，当一个线程改变了该变量值后，其他线程能立刻获得最新值。&gt; &gt; **有序性**：即结果顺序符合程序代码逻辑执行顺序。一般来说处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。 ### 线程的生命周期？（手画！！！）![线程的生命周期](面经/21.png) ### 阻塞状态和等待状态区别？&gt; **阻塞状态**：当一个线程试图获取一个**内部的对象锁**（不是 JUC 库中的 Lock），而该锁又被其他线程所持有，则该线程进入阻塞状态。通常会在 synchronized 同步语块中出现这种情况。&gt; &gt; **等待状态**：当线程等待另一线程通知调度器一个条件时，它自己进入等待状态。通常在调用 Object.wait() 和 Thread.join() 方法时，或者 JUC 库中的 Lock 或 Condition 时，就会出现这种情况。 ### 什么是上下文切换？&gt; 当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换会这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。 ### 说说并发与并行的区别？&gt; **并发**：指宏观上多个线程是同时在工作的，实际上可能是多个线程真的在同时工作；也可能是多个线程快速切换运行，在同一时间只有一个线程在工作，但只是因为切换较快，感觉上就是多个线程在同时工作。即**同一时间段，多个任务都在执行 (单位时间内不一定同时执行)。** &gt; &gt; **并行**：指在微观上同时有多个线程在同时工作，这就要求必须有至少两个 CPU 在运行线程。即**单位时间内，多个任务同时执行。** ### 为什么要使用多线程呢？ &gt; 1. **从计算机底层来说**： 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。&gt; &gt; 2. **从当代互联网发展趋势来说**： 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。&gt; &gt; 3. 单核时代： 在单核时代多线程主要是为了提高 CPU 和 IO 设备的综合利用率；多核时代: 多核时代多线程主要是为了提高 CPU 利用率。 ### 使用多线程可能带来什么问题？&gt; 脏读、死锁、内存泄漏、OOM ### 单CPU的情况下适合用多线程吗？&gt; 单核开多线程只是为了编程方便，属于类似语法糖的范畴。它在特定领域可以提供较大的编程便利。 ### JDK 中消费者生产者应用场景? &gt; Java 实现的经典的方法是使用 ```wait()``` 和 ```notify()``` 方法来协调生产者消费者的同步合作，实现生产者消费者模式最方便的方法是使用 JUC 中的阻塞队列（ BlockingQueue ），因为它结构更简单，更容易编程控制。 只需要编写业务代码，而同步的问题，扔给了阻塞队列来管理。 &gt; &gt; 当队列满的时候生产者调用的 ```put()```方法将阻塞，同理当队列为空的时候消费者 ```take()``` 方法将阻塞，等待生产者生产。 &gt; ```.import java.util.concurrent.BlockingQueue;import java.util.concurrent.LinkedBlockingDeque;import java.util.logging.Level;import java.util.logging.Logger;public class Main { public static void main(String[] args){ BlockingQueue&lt;String&gt; blockingQueue = new LinkedBlockingDeque&lt;&gt;(); Thread producerThread = new Thread(new Producer(blockingQueue)); Thread consumerThread = new Thread(new Consumer(blockingQueue)); producerThread.start(); consumerThread.start(); }}class Producer implements Runnable{ private BlockingQueue&lt;String&gt; bufQueue; public Producer(BlockingQueue&lt;String&gt; bufQueue){ this.bufQueue = bufQueue; } @Override public void run(){ try{ for(int i = 0; i &lt; 10; i++){ bufQueue.put(String.valueOf(i)); System.out.println(&quot;Producer: &quot; + i); } bufQueue.put(&quot;OVER&quot;); } catch (Exception e){ Logger.getLogger(Producer.class.getName()).log(Level.SEVERE, null, e); } }}class Consumer implements Runnable{ private BlockingQueue&lt;String&gt; bufQueue; public Consumer(BlockingQueue&lt;String&gt; bufQueue){ this.bufQueue = bufQueue; } @Override public void run(){ try{ String curr = null; while(!(curr = bufQueue.take()).equals(&quot;OVER&quot;)){ System.out.println(&quot;Consumer: &quot; + curr); } } catch (Exception e){ Logger.getLogger(Consumer.class.getName()).log(Level.SEVERE, null, e); } }}``` &gt; 但现实中生产者和消费者的数量通常不是1:1的，因此，可以通过使用AtomicInteger对生产者和消费者数量进行记录。&gt; ```.import java.util.concurrent.BlockingQueue;import java.util.concurrent.LinkedBlockingDeque;import java.util.concurrent.atomic.AtomicBoolean;import java.util.concurrent.atomic.AtomicInteger;import java.util.logging.Level;import java.util.logging.Logger;public class Main { public static void main(String[] args){ BlockingQueue&lt;String&gt; blockingQueue = new LinkedBlockingDeque&lt;&gt;(); final int PRODUCT_TARGET_NUM = 50; final int PROCUER_NUM = 2; final int CONSUMER_NUM = 10; AtomicInteger producerCount = new AtomicInteger(PROCUER_NUM); AtomicInteger productCount = new AtomicInteger(0); AtomicBoolean soldOut = new AtomicBoolean(false); for(int i = 0; i &lt; PROCUER_NUM; i++){ Thread producerThread = new Thread(new Producer(blockingQueue, producerCount, productCount, PRODUCT_TARGET_NUM, i, soldOut)); producerThread.start(); } for(int i = 0; i &lt; CONSUMER_NUM; i++){ Thread consumerThread = new Thread(new Consumer(blockingQueue, producerCount, i, soldOut)); consumerThread.start(); } }}class Producer implements Runnable{ private BlockingQueue&lt;String&gt; bufQueue; private AtomicInteger producerCount; private AtomicInteger productCount; private AtomicBoolean soldOut; private int targetNum; private int num; public Producer(BlockingQueue&lt;String&gt; bufQueue, AtomicInteger producerCount, AtomicInteger productCount, int targetNum, int num, AtomicBoolean soldOut){ this.bufQueue = bufQueue; this.producerCount = producerCount; this.productCount = productCount; this.targetNum = targetNum; this.num = num; this.soldOut = soldOut; } @Override public void run(){ if(!soldOut.get()){ try{ int i = productCount.getAndIncrement(); while (i &lt; targetNum){ bufQueue.put(String.valueOf(i)); System.out.println(&quot;Producer&quot; + num + &quot;: &quot; + i); i = productCount.getAndIncrement(); } soldOut.set(true); } catch (Exception e){ Logger.getLogger(Producer.class.getName()).log(Level.SEVERE, null, e); } finally { producerCount.getAndDecrement(); } } }}class Consumer implements Runnable{ private BlockingQueue&lt;String&gt; bufQueue; private AtomicInteger producerCount; private AtomicBoolean soldOut; private int num; public Consumer(BlockingQueue&lt;String&gt; bufQueue, AtomicInteger producerCount, int num, AtomicBoolean soldOut){ this.bufQueue = bufQueue; this.producerCount = producerCount; this.num = num; this.soldOut = soldOut; } @Override public void run(){ try{ while(!soldOut.get() || !bufQueue.isEmpty()){ if(!bufQueue.isEmpty()){ System.out.println(&quot;Consumer&quot; + num + &quot;: &quot; + bufQueue.take()); } else { try{ System.out.println(&quot;Consumer&quot; + num + &quot;: WAITING 50ms&quot;); Thread.sleep(50); } catch (Exception e){ Logger.getLogger(Consumer.class.getName()).log(Level.SEVERE, null, e); } } } } catch (Exception e){ Logger.getLogger(Consumer.class.getName()).log(Level.SEVERE, null, e); } }}=========================================================================OUTPUT:Producer0: 0Producer1: 1Producer0: 2Producer1: 3Producer0: 4Producer1: 5Producer0: 6Producer1: 7Producer1: 9Consumer0: 0Producer0: 8Consumer0: 2Consumer2: 3Producer1: 10Consumer1: 1Consumer4: 7Producer1: 12Consumer3: 6Consumer2: 5Consumer0: 4Producer0: 11Consumer7: WAITING 50msConsumer0: WAITING 50msConsumer6: 13Consumer2: 12Consumer5: 11Consumer3: 10Consumer3: WAITING 50msProducer1: 13Producer1: 15Consumer4: 9Consumer4: 15Consumer1: 8Consumer1: WAITING 50msConsumer4: 16Producer1: 16Producer1: 17Producer1: 18Consumer5: WAITING 50msConsumer2: WAITING 50msConsumer9: WAITING 50msConsumer6: WAITING 50msConsumer8: 14Consumer8: 17Consumer8: 18Consumer8: 19Producer0: 14Consumer8: WAITING 50msProducer1: 19Producer1: 21Consumer4: WAITING 50msProducer1: 22Producer0: 20Producer1: 23Producer0: 24Producer1: 25Producer0: 26Producer1: 27Producer0: 28Producer0: 30Producer1: 29Producer1: 32Producer1: 33Producer0: 31Producer1: 34Producer0: 35Producer1: 36Producer0: 37Producer1: 38Producer0: 39Producer1: 40Producer1: 42Producer1: 43Producer0: 41Producer0: 45Producer1: 44Producer0: 46Producer1: 47Producer0: 48Producer1: 49Consumer3: 21Consumer7: 20Consumer7: 23Consumer3: 22Consumer7: 24Consumer3: 25Consumer7: 26Consumer3: 27Consumer5: 28Consumer3: 29Consumer5: 30Consumer2: 34Consumer6: 35Consumer0: 33Consumer8: 41Consumer3: 32Consumer1: 31Consumer3: 44Consumer1: 45Consumer8: 43Consumer0: 42Consumer7: 40Consumer9: 38Consumer6: 39Consumer5: 37Consumer2: 36Consumer8: 49Consumer1: 48Consumer3: 47Consumer4: 46 如何保证线程执行顺序？ 使用 方法等待当前线程执行完毕再执行下一个线程。123456789101112131415161718192021222324252627282930313233343536&gt; 2. 使用最大工作线程为1的线程池来执行线程。&gt; &gt; #### 两个线程如何顺序输出0-100？ ```. public class Main{ static int num = 0; static int max = 100; static volatile boolean isOdd = false; public static void main(String[] args){ Thread t1 = new Thread(() -&gt; { while(num &lt; max){ if(!isOdd &amp;&amp; (num == 0 || ++num % 2 == 0)){ System.out.println(Thread.currentThread().getName() + &quot; : &quot; + num); isOdd = true; } } }, &quot;Even&quot;); Thread t2 = new Thread(() -&gt; { while(num &lt; max){ if(isOdd &amp;&amp; ++num % 2 != 0){ System.out.println(Thread.currentThread().getName() + &quot; : &quot; + num); isOdd = false; } } }, &quot; Odd&quot;); t1.start(); t2.start(); }} Java 实现了线程的调度吗？ 实现了，Java 是抢占式调度，线程调度具有一定的随机性，可以通过 setPriority() 方法对线程设置优先级进行调度，但优先级并不是很靠谱，因为Java线程是通过映射到系统的原生线程上来实现的，所以线程调度最终还是取决于操作系统。 Java 里为什么有线程安全问题？如何解决？ 因为 JVM 内存中的堆、方法区两个区域是多线程主要的数据共享区域，有数据共享就意味着有可能出现脏读和死锁等线程安全问题。可以通过对线程加锁或使用 synchronized 关键字以及避免共享变量进行解决。 多线程的实现方式？ 继承 Thread 类 实例化之后调用 start() 方法 实现 Runnable 接口 实例化一个 Thread 传入该类实例，重写并运行 run() 实现 Callable 接口，重写并调用 call()，通过 FutureTask 包装器来创建线程 使用 ExecutorService、Callable、Future实现有返回结果的线程 Thread、Runnable 和 Callable 区别？哪一种比较好，哪一种比较安全？ Thread 是类，需要继承，而 Java 只允许但继承，因此通过继承 Thread 类来创建线程的方式降低了类的可拓展性。 Runnable 是接口，Java 允许实现多个接口，因此使用 Runnable 可以保证程序的可拓展性。同时，它增加了程序的健壮性，代码可以被多个线程共享，代码和数据独立，线程安全，适合于多个有相同代码的线程区处理同一个资源。它没有返回值。 Callable 是接口，与 Runnable 相比，Callable 有一个 call() 方法有返回值。同时， call() 方法可抛出异常，而 run() 方法是不能抛出异常的。运行 Callable 任务可拿到一个 Future 对象， Future 表示异步计算的结果。通过 Future 对象可了解任务执行情况，可取消任务的执行，还可获取任务执行的结果。 线程在 JVM 中 start() 一定会启动吗？ 不一定， start() 方法只是使得新建的线程进入就绪状态（READY），只有当当前线程被系统分配了时间片后，才会通过系统调用进入运行状态（RUNNAING）。 为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？ new 一个 Thread，线程进入了新建状态；调用 start() 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。 而直接执行 run() 方法，会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。 总结： 调用 start() 方法方可启动线程并使线程进入就绪状态，而 run() 方法只是 thread 的一个普通方法调用，还是在主线程里执行。 wait() 与 sleep() 与 yield() 的区别？ wait()：是 Object 类中的方法，他可以选传一个毫秒时间参数。它不是随便可以调用的，必须包含在对应的 synchronized 同步语块中。在它工作时，首先必须获得目标对象的一个监视器（锁），而 wait() 方法执行后，会释放这个监视器（锁）。这样做的目的是使得其他等待同一个对象的线程不会因为当前线程的休眠二全部无法执行。 sleep()：是 Thread 类中的方法，它需要传入一个毫秒参数，指定线程“睡眠”时间。它可以在任何地方调用，调用后会使得当前工作线程立刻进入 TIMED-WAITING 状态，并且不会释放当前线程所持有的锁。 yield()：是 Thread 类中的方法，用来暂停当前执行的线程并使之回到就绪（READY）状态，此时所有线程（包括当前线程）将会根据优先级（如果设了）来进行调用。因此有可能当前线程刚进入就绪（READY）状态，又立刻被调用，回到运行（RUNNING）状态。 notifyAll()怎么个全部法，全部唤醒都开始执行不就不安全了吗？ 调用 notifyAll() 方法能够唤醒所有正在等待这个对象的 monitor （监视器，即锁）的线程。 如何安全地停止线程 1、 使用共享变量：之所以引入共享变量，是因为该变量可以被多个执行相同任务的线程用来作为是否中断的信号，通知中断线程的执行。 12345678910111213141516private volatile Thread blinker; public void stop() { blinker = null; } public void run() { Thread thisThread = Thread.currentThread(); while (blinker == thisThread) { try { thisThread.sleep(interval); } catch (InterruptedException e){ } repaint(); } } 2、 使用 Thread.interrupted() 方法：如果一个线程由于等待某些事件的发生而被阻塞，又该怎样停止该线程呢？这种情况经常会发生，比如当一个线程由于需要等候键盘输入而被阻塞，或者调用 Thread.join() 方法，或者 Thread.sleep() 方法，在网络中调用 ServerSocket.accept() 方法，或者调用了 DatagramSocket.receive() 方法时，都有可能导致线程阻塞，使线程处于处于不可运行状态时，即使主程序中将该线程的共享变量设置为 true ，但该线程此时根本无法检查循环标志，当然也就无法立即中断。我们可以使用 Thread.interrupt() 方法，因为该方法虽然不会中断一个正在运行的线程，但是它可以使一个被阻塞的线程抛出一个中断异常 InterruptedExeception ，从而使线程提前结束阻塞状态，退出堵塞代码。 interrupt() 和 isInterrupted() 的区别？interrupt()：是一个静态方法，它用于检测当前线程是否被中断。isInterrupted()：是一个实例方法，可以用来检测是否有线程被中断，调用这个方法不会改变中断状态。 为什么stop()不安全？ stop() 方法在结束线程时，会直接终止线程，并立刻释放这个线程所持有的锁，可能线程数据写到一半的时候被强行终止，导致数据不一致，对象被写坏 怎么让一个线程等另一个线程执行结束？ Thread 的 join()：thread 结束后再继续执行。 join()让线程存活的原理是：不断检查调用 join() 的线程是否存活，如果调用 join() 的线程存活，则让当前线程永远等待，其中，wait(0) 表示永远等待下去。直到调用 join() 的线程结束，JVM 会调用 this.notifyAll() （这段代码在 JVM 源码里，因此 JDK 里面看不见）使得当前线程恢复运行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114&gt; &gt; 2. **JUC 的 CountDownLatch 类**：CountDownLatch 构造函数接收一个 int 参数 N ，表示计数器。当调用 CountDownLatch.countDown() 时，计数减1，直至减到0为止。这里的 N 个点，可以是 N 个线程，也可以是 N 个执行步骤。&gt; &gt; 3. **JUC 的 CyclicBarrier 类**：它的作用是让一组线程到达一个“屏障”（一个同步点）时被阻塞，直到本组最后一个线程到达“屏障”时，所有被拦截的线程才会继续运行。 ### 说一下Java 线程间通信方式？ / Java 线程之间如何互操作？&gt; 1. **wait()、notify()、notifyAll()** ：每次交互是都需要握手。同时，通常 wait() 操作还要用一个 while(){} 循环包围，因为有可能多个任务出于相同原因在等待一个锁，而第一个被唤醒的任务会改变这种状况。因此，当有任务改变这种状况时，当前任务应该再次被挂起，直到其感兴趣的条件发生变化。 &gt;&gt; 2. **Lock 和 Condition 对象**：Condition.await() 、Condition.signal() 和 Condition.signalAll() 方法。&gt; &gt; 3. **阻塞队列 / 同步队列（BlockingQueue）**：阻塞队列任何时候都只允许一个任务插入或者移除元素。当队列为空时，当任务试图从中获取元素对象时，那么这个队列可以把这个任务挂起，并且当用更多元素可用时恢复该任务。队列的自动挂起和恢复任务的机制，将显示调用 wait()、notify()、notifyAll() 时类和类之间的耦合消除，因为每个类只喝它的阻塞队列通信。 &gt;&gt; 4. **任务间使用管道进行输入/输出**：PipedWriter、PipedReader 类（允许不同任务从同一个管道中读取）。实际上，管道基本上就是一个阻塞队列。在 shutdownNow() 被调用时， PipedReader 与普通的 I/O 之间最重要的差异就是前者可以被中断（ interrupted() ），而后者不可以。 ### JDK 同步机制是怎样？ &gt; 1. **synchronized** 关键字。&gt; &gt; 2. **Lock** 接口及其实现类。&gt; &gt; 3. **信号量（Semaphore）**：是一种计数器，用来保护一个或者多个共享资源的访问，它是并发编程的一种基础工具，大多数编程语言都提供这个机制，这也是操作系统中经常提到的。&gt; &gt; 4. **CountDownLatch**：Java 语言提供的同步辅助类，在完成一组正在其他线程中执行的操作之前，他允许线程一直等待。&gt; &gt; 5. **CyclicBarrier**：Java 语言提供的同步辅助类，它允许多个线程在某一个集合点处进行相互等待。&gt; &gt; 6. **Phaser**：Java 语言提供的同步辅助类，它把并发任务分成多个阶段运行，在开始下一阶段之前，当前阶段中所有的线程都必须执行完成，JAVA7 才有的特性。&gt; &gt; 7. **Exchanger**：他提供了两个线程之间的数据交换点。 ### Java多线程会占满CPU吗？&gt; 一个线程死循环的情况下会占满一个CPU核 ### 死锁的4个必要条件？&gt; 1. **互斥资源**：即一个资源在任何一个时刻只能被一个线程所拥有。**（这个条件是无法被破坏的）**&gt; 2. **请求与保持**：即一个线程一旦获得一个资源后，即使当前线程被阻塞，也不会释放资源。&gt; 3. **不可剥夺**：即一个线程一旦获得一个资源后，其他线程不能从这个线程上抢夺这个资源。&gt; 4. **循环等待**：即多个线程互相等待对方释放资源才能继续完成自己的任务。 ### 如何避免死锁？如何打破死锁的条件？&gt; 死锁预防是计算机操作系统，在设计时确定资源分配算法，为保证不发生死锁，而破坏产生死锁的必要条件的行为过程。&gt; &gt; 1. **破坏请求与保持条件**：一次性申请所有的资源。&gt; 2. **破坏不可剥夺条件**：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。&gt; 3. **破坏循环等待条件**：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。 ### 写个死锁算法？```.import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.TimeUnit;public class Main { public static int[] resource = {0, 0}; public static void main(String[] args){ ExecutorService exec = Executors.newCachedThreadPool(); exec.execute(new Runner(resource, 1)); exec.execute(new Runner(resource, 2)); try{ TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e){ e.printStackTrace(); } exec.shutdownNow(); }}class Runner implements Runnable{ private int[] resourse; private int id; Runner(int[] resourse, int id){ this.resourse = resourse; this.id = id; } @Override public void run(){ try{ while (!Thread.interrupted()){ synchronized (resourse) { while (resourse[0] != 0 || resourse[1] != 0) { System.out.println(&quot;Thread &quot; + id + &quot; is waiting for resources!&quot;); resourse.wait(); } resourse[0] = id; } Thread.currentThread().sleep(10); synchronized (resourse){ while (resourse[0] != 0 || resourse[1] != 0) { System.out.println(&quot;Thread &quot; + id + &quot; is waiting for resources!&quot;); resourse.wait(); } resourse[1] = id; System.out.println(&quot;Thread &quot; + id + &quot; gets all resources!&quot;); resourse[0] = 0; resourse[1] = 0; System.out.println(&quot;Thread &quot; + id + &quot; releases all resources!&quot;); resourse.notifyAll(); Thread.currentThread().interrupt(); } } } catch (InterruptedException e){ e.printStackTrace(); } }} 不用锁如何实现线程同步 基于 Happens-Before（HB）规则，可以实现不使用 volatile 和锁实现共享变量的同步操作。 该规则定义了 Java 多线程操作的有序性和可见性，防止了编译器重排序对程序结果的影响。当一个变量被多个线程读取并且至少被一个线程写入时，如果读操作和写操作没有 HB 关系，则会产生数据竞争问题。要想保证操作 B 的线程看到操作 A 的结果（无论 A 和 B 是否在一个线程），那么在 A 和 B 之间必须满足 HB 原则，如果没有，将有可能导致重排序。 Happens-Before 原则是 JMM 的核心所在，只有满足了 HB 原则才能保证有序性和可见性，否则编译器将会对代码重排序。HB 甚至为 lock 和 volatile 也定义了规则。 HB 规则： 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作。 锁定规则：在监视器锁上的解锁操作必须在同一个监视器上的加锁操作之前执行。 volatile 变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作。 传递规则：如果操作 A 先行发生于操作 B ，而操作B又先行发生于操作 C ，则可以得出操作 A 先行发生于操作 C 。 线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作。 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生。 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过 Thread.join()方法结束、Thread.isAlive() 的返回值手段检测到线程已经终止执行。 对象终结规则：一个对象的初始化完成先行发生于他的 finalize() 方法的开始。 实例：一、 程序次序规则 + volatile 变量规则 + 传递规则 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163/* 两个线程交替打印 0-100 */public class Main{ static int num = 0; static int max = 100; static volatile boolean isOdd = false; public static void main(String[] args){ Thread t1 = new Thread(() -&gt; { while(num &lt; max){ if(!isOdd &amp;&amp; (num == 0 || ++num % 2 == 0)){ System.out.println(Thread.currentThread().getName() + &quot; : &quot; + num); isOdd = true; } } }, &quot;Even&quot;); Thread t2 = new Thread(() -&gt; { while(num &lt; max){ if(isOdd &amp;&amp; ++num % 2 != 0){ System.out.println(Thread.currentThread().getName() + &quot; : &quot; + num); isOdd = false; } } }, &quot; Odd&quot;); t1.start(); t2.start(); }}``` &gt; 二、线程终结规则```.static int a = 1; public static void main(String[] args) { Thread tb = new Thread(() -&gt; { a = 2; }); Thread ta = new Thread(() -&gt; { try { tb.join(); } catch (InterruptedException e) { //NO } System.out.println(a); }); ta.start(); tb.start(); }``` &gt; 三、线程启动规则 ```.static int a = 1; public static void main(String[] args) { Thread tb = new Thread(() -&gt; { System.out.println(a); }); Thread ta = new Thread(() -&gt; { a = 2; tb.start(); }); ta.start(); }``` ### 介绍一下线程池？ &gt;#### 线程池的意义？&gt; 多线程的软件设计方法可以最大限度的发挥多核处理器的计算能力，提高CPU的使用率，提高生产系统的吞吐亮和性能。但是，如果不对线程的数量加以控制，却会适得其反。 &gt; &gt; 1. **降低资源消耗**：创建过多的线程会占用大量内存资源，影响系统性能，甚至可能导致 OOM 问题。 &gt; 2. **提高响应速度**：过多的短期任务线程的回收会对 GC 带来巨大的压力，延长 GC 停顿时间，影响系统性能。&gt; 3. **提高线程的可管理性**：创建大量的线程也会因线程间的切换带来巨大的开销，影响系统性能。 &gt; &gt; 因此，为了最大的发挥多线程开发的优势，我们需要将线程的数量控制在一个合理的范围之中，并对已经创建的线程进行重复使用，以减少线程回收的开销，降低GC压力，而**线程池（ThreadPool）**的概念应运而生。&gt; #### 线程池构造方法的参数，具体介绍一下？&gt; |类型|参数|作用||:---:|:---:|---||int|corePoolSize|核心线程数量||int|maximumPoolSize|线程池最大线程数量||long|keepAliveTime|**空闲线程**的最大存活时间||TimeUnit|unit|时间单位||BlockingQueue&lt;Runnable&gt;|workQueue|任务队列，存放待执行的任务||ThreadFactory|threadFactory|创建线程的工厂||RejectedExecutionHandler|handler|拒绝策略| &gt; #### 线程池类型？&gt;|线程池类型|说明||:---:|---||SingleThreadExecutor|适用于需要保证顺序地执行各个任务；并且在任意时间点，不会有多个线程是工作的应用场景||FixedThreadPool|适用于未来满足资源管理的需求，而需限制当前线程数量的应用场景，适用于负载比较重的服务器||CacheThreadPool|这是一个会根据需要创建新线程的、大小无界的线程池，适用于执行很多短期异步任务的小程序，或者负载比较轻的服务器||ScheduledThreadPoolExecutor|适用于需要多个后台线程执行周期任务，同时为里满足资源管理的需求而需要限制后台线程数量的应用场景||SingleThreadScheduledExecutor|适用于需要单个后台线程执行周期任务，同时需要保证顺序地执行各个任务的的应用场景|&gt;#### 线程池拒绝策略？&gt;&gt;|拒绝策略|说明||:---:|---||AbortPolicy|直接抛出异常||CallerRunsPolicy|由调用者所在线程来运行任务||DiscardOldestPolicy|丢弃任务队列里最近一个任务，并执行当前任务||DiscardPolicy|不处理当前任务，直接丢弃||Other|其他实现 RejectedExecutionHandler 接口的自定义拒绝策略|&gt; #### 线程池实现原理？&gt; 当一个任务提交到线程池后，线程池流程如下：&gt; &gt; 1. 线程池判断核心线程池里的线程是否都在工作，如果不是，则创建一个新的工作线程执行任务；如果是，则进入下一步。&gt; 2. 线程池判断当前任务队列是否已经满了，如果没有满，则将任务加入任务队列中，等待被执行；如果满了，则进入下一步。&gt; 3. 线程池检查当前工作线程数量是否超过最大线程数量，如果没有超过，则创建一个新的工作线程来执行任务；如果满了，则进入下一步。&gt; 4. 线程池基于拒绝策略拒绝执行任务。 &gt; ![线程池实现原理](面经/22.png)&gt;#### 线程池里如何知道线程执行完了没有？&gt; 1. 使用线程池的原生函数 ```isTerminated()```。&gt; 2. 使用 CountDownLatch。&gt; 3. 维持一个公共计数。&gt; #### 假设你的 CPU 是 2 核或者是 4 核的，如果采用固定大小的线程池，那你会固定多少个线程？&gt; **线程等待时间所占比例越高，需要越多线程。线程CPU时间所占比例越高，需要越少线程。**&gt; &gt; N 代表 CPU 的核数。 &gt; &gt; 1. 如果是 IO 密集型应用，则线程池大小设置为 **2N+1**，IO密集型任务CPU使用率并不高，因此可以让CPU在等待IO的时候去处理别的任务，充分利用CPU时间。&gt; &gt; 2. 如果是 CPU 密集型应用，则线程池大小设置为 **N+1**，因为CPU密集型任务使得CPU使用率很高，若开过多的线程数，只能增加上下文切换的次数，因此会带来额外的开销。&gt; #### 线程池执行任务的方法？##### Execute()&gt; execute()直接将一个Runnable任务提交到线程池去运行，它无返回结果。它的内部执行流程遵循上述线程池实现原理。 ```. public void execute(Runnable command) { int c = ctl.get(); //获取线程池控制变量 ctl if (workerCountOf(c) &lt; corePoolSize) { //step 1: 核心线程数判断 if (addWorker(command, true)) //step 1.1 添加核心线程执行任务 return; c = ctl.get(); //重新获取最新的控制变量 ctl（因为可能在上述过程中可能线程池控制变量发生改变） } if (isRunning(c) &amp;&amp; workQueue.offer(command)) { //step 2检查当前线程池是否还在运行状态，并尝试任务加入队列 int recheck = ctl.get(); //重新获取最新的控制变量 ctl（因为可能在上述过程中可能线程池控制变量发生改变） if (! isRunning(recheck) &amp;&amp; remove(command)) //step 2.1判断线程池是否运行，防止线程池状态的突变，如果突变，那么执行拒绝策略，reject线程，防止 workQueue 中增加新线程 reject(command); else if (workerCountOf(recheck) == 0) //step 2.2判断当前工作线程数量如果等于0，直接添加工作线程 addWorker(null, false); } else if (!addWorker(command, false)) //step 3 如果任务无法加入队列，尝试创建线程执行任务 reject(command); } ctlctl 是线程池的最重要的控制变量，它该变量是一个 AtomicInteger 类型的原子变量，记录着线程池的线程总数量 workerCount 以及线程池的状态 runState 。这个变量设计的非常巧妙，一方面减少了线程池的变量数量，更重要的一方面是，该变量是原子类型变量，线程池的实现函数中，往往需要同时获取这两个属性，如果将两个属性放入一个原子变量中，根据 Atomic 类支持线程的重入，线程池也就只需获取一把锁，便可以控制线程池的两个属性，这里实际上变相减少了一把锁的使用。那么 ctl 是如何将两个属性合并为一个变量的呢？首先AtomicInteger类型变量为32位，workerCount 是占据着一个 atomic integer 的后29位的，而runState占据了前3位，所以，workerCount 上限是(2^29)-1。 3 bits 29 bits runState workerCount runState 是整个线程池的运行生命周期，有如下取值： 取值（COUNT—BITS == 3时） runState 说明 111 -&gt; -1 RUNNING 可以新加线程，同时可以处理任务队列 queue 中的任务 000 -&gt; 0 SHUTDOWN 不增加新线程，但是处理任务队列 queue 中的任务 001 -&gt; 1 STOP 不增加新线程，同时不处理任务队列 queue 中的任务 010 -&gt; 2 TIDYING 所有的线程都终止了（任务队列 queue 中），同时 workerCount 为0，那么此时进入TIDYING 011 -&gt; 3 TERMINATED terminated()方法结束，变为 TERMINATED 线程池状态转换图如下所示： 它的相关操作如下所示： 12345678910111213141516171819202122private static final int COUNT_BITS = Integer.SIZE - 3; //workerCount 位数private static final int CAPACITY = (1 &lt;&lt; COUNT_BITS) - 1; //workerCount 上限是(2^29)-1 /*几个状态，用 Integer 的高三位表示*/private static final int RUNNING = -1 &lt;&lt; COUNT_BITS; //111private static final int SHUTDOWN = 0 &lt;&lt; COUNT_BITS; //000private static final int STOP = 1 &lt;&lt; COUNT_BITS; //001private static final int TIDYING = 2 &lt;&lt; COUNT_BITS; //010private static final int TERMINATED = 3 &lt;&lt; COUNT_BITS; //011/*获取后COUNT_BITS位数值，即 workerCount */private static int workerCountOf(int c) { return c &amp; CAPACITY; }/*获取前COUNT_BITS位数值 runState */private static int runStateOf(int c) { return c &amp; ~CAPACITY; }/*获取 ctl */private static int ctlOf(int rs, int wc) { return rs | wc; } Submit() 用 ThreadPoolExecutor.submit(Runnable task) 方法来向线程池提交任务，该方法会返回一个Futrue 类型的结果，通过以下代码便可以判断任务是否执行成功了。 1234567891011Future&lt;Object&gt; threadFuture = threadPoolExecutor.submit(task); try{ Object result = threadFuture.get(); }catch (InterruptedException e){ // 处理线程中断异常 }catch (ExecutionException e){ // 处理无法执行异常 } finally { threadPoolExecutor.shutdown(); } scheduled() 与scheduledAtFixedRate() 与 scheduledWithFixedDelay 区别？ 方法 说明 scheduled() 到达指定时间后执行任务 scheduledAtFixedRate() 每隔一段时间 Rate 启动执行一个任务 scheduledWithFixedDelay 当一个任务完成后过 Delay 时间，再启动一个新任务 多线程 Future 接口，里面有什么方法12345678910111213public interface Future&lt;V&gt; { //尝试取消此次任务 mayInterruptIfRunning - true如果执行该任务的线程应该被中断; 否则，正在进行的任务被允许完成 boolean cancel(boolean mayInterruptIfRunning); //如果此任务在正常完成之前被取消，则返回 true 。 boolean isCancelled(); //返回true如果任务已完成。 完成可能是由于正常终止，异常或取消 - 在所有这些情况下，此方法将返回true 。 boolean isDone(); //等待计算完成然后返回结果 V get() throws InterruptedException, ExecutionException; //在指定的时间之内进行等待，超时不等待 V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;} 锁的四种状态？ 注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。 无锁 即没有任何锁的状态。 偏向锁 引入偏向锁的目的和引入轻量级锁的目的很像，他们都是为了没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。但是不同是：轻量级锁在无竞争的情况下使用 CAS 操作去代替使用互斥量。而偏向锁在无竞争的情况下会把整个同步都消除掉。 偏向锁的“偏”就是偏心的偏，它的意思是会偏向于第一个获得它的线程，如果在接下来的执行中，该锁没有被其他线程获取，那么持有偏向锁的线程就不需要进行同步！ 在 Java 6 和 Java 7 里面，偏向锁时默认启动的。 但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。 轻量级锁 倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段(JDK 1.6之后加入的)。轻量级锁不是为了代替重量级锁，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗，因为使用轻量级锁时，不需要申请互斥量。另外，轻量级锁的加锁和解锁都用到了CAS操作。 轻量级锁能够提升程序同步性能的依据是“对于绝大部分锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据。如果没有竞争，轻量级锁使用 CAS 操作避免了使用互斥操作的开销。但如果存在锁竞争，除了互斥量开销外，还会额外发生CAS操作，因此在有锁竞争的情况下，轻量级锁比传统的重量级锁更慢！如果锁竞争激烈，那么轻量级将很快膨胀为重量级锁！ 重量级锁即类似于 synchronized 关键字这种，依赖于依赖于底层的操作系统的 Mutex Lock 来实现。Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。 自旋锁的底层实现？ 轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。 一般线程持有锁的时间都不是太长，所以仅仅为了这一点时间去挂起线程/恢复线程是得不偿失的。 所以，虚拟机的开发团队就这样去考虑：“我们能不能让后面来的请求获取锁的线程等待一会而不被挂起呢？看看持有锁的线程是否很快就会释放锁”。为了让一个线程等待，我们只需要让线程执行一个忙循环（自旋），这项技术就叫做自旋。 何谓自旋锁？它是为实现保护共享资源而提出一种锁机制。其实，自旋锁与互斥锁比较类似，它们都是为了解决对某项资源的互斥使用。无论是互斥锁，还是自旋锁，在任何时刻，最多只能有一个保持者，也就说，在任何时刻最多只能有一个执行单元获得锁。但是两者在调度机制上略有不同。对于互斥锁，如果资源已经被占用，资源申请者只能进入睡眠状态。但是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，”自旋”一词就是因此而得名。 自旋锁在 JDK1.6 之前其实就已经引入了，不过是默认关闭的，需要通过 参数来开启。JDK1.6 及 1.6 之后，就改为默认开启的了。需要注意的是：自旋等待不能完全替代阻塞，因为它还是要占用处理器时间。如果锁被占用的时间短，那么效果当然就很好了！反之，相反！自旋等待的时间必须要有限度。如果自旋超过了限定次数任然没有获得锁，就应该挂起线程。自旋次数的默认值是10次，用户可以修改 ```--XX:PreBlockSpin``` 来更改。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&gt; &gt; 另外,在 JDK1.6 中引入了自适应的自旋锁。自适应的自旋锁带来的改进就是：自旋的时间不在固定了，而是和前一次同一个锁上的自旋时间以及锁的拥有者的状态来决定，虚拟机变得越来越“聪明”了。 ### 什么是锁消除？&gt; 锁消除理解起来很简单，它指的就是虚拟机即使编译器在运行时，如果检测到那些共享数据不可能存在竞争，那么就执行锁消除。锁消除可以节省毫无意义的请求锁的时间。### 什么是锁粗化？&gt; 原则上，我们再编写代码的时候，总是推荐将同步快的作用范围限制得尽量小——只在共享数据的实际作用域才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待线程也能尽快拿到锁。&gt; 大部分情况下，上面的原则都是没有问题的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，那么会带来很多不必要的性能消耗。 ### 乐观锁和悲观锁？&gt; (先说两者概念，引出synchronized和CAS，谈下锁升级和详细CAS过程及Java中的应用)&gt; #### 乐观锁&gt; 总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以**使用版本号机制和 CAS 算法实现**。**乐观锁适用于多读的应用类型，这样可以提高吞吐量**，像数据库提供的类似于 write_condition 机制，其实都是提供的乐观锁。在 Java 中 java.util.concurrent.atomic 包下面的原子变量类就是使用了乐观锁的一种实现方式 CAS 实现的。&gt; #### 悲观锁&gt; 总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java 中 synchronized 和 ReentrantLock 等独占锁就是悲观锁思想的实现。**悲观锁适合于写多的情况。** ### CAS ？&gt; 即 compare and swap（比较与交换），是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。CAS算法涉及到三个操作数&gt; &gt; 需要读写的内存值 V&gt; 进行比较的值 A&gt; 拟写入的新值 B&gt; &gt; 当且仅当 V 的值等于 A 时，CAS 通过原子方式用新值 B 来更新 V 的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。 ### Java CAS 如何解决ABA问题？&gt; 使用版本号机制。 ### 介绍一下 volatile ？&gt; volatile 可以说是轻量级的 synchronized ，它可以在不引发线程上下文切换的条件下**保证共享变量的可见性**。因此如果 volatile 使用恰当的话，成本比 synchronized 低。同时，它还可以**防止 JVM 对指令的重排**，保证执行顺序。但是，**volatile 不保证操作的原子性。**&gt; &gt; 那么它是如何保证可见性的呢？通过 JIT 查看汇编代码可以看出， volatile 变量在进行**写操作**的时候会多出一行 ```Lock``` 前缀指令，它的作用是：&gt; &gt; 1. 将当前处理器缓存行（这是 CPU cache 可以分配的最小存储单位）的数据写回到系统内存。因为```Lock``` 前缀指令会在执行的时候声言```LOCK#```信号，这个信号会锁住总线，导致其他 CPU 不能访问总线，从而确保声言期间当前 CPU 可以独占任何共享内存。&gt; &gt; 2. 这个写回内存的操作会使其他 CPU 里缓存了该内存地址的数据无效。这里用的是处理器的嗅探技术，在此不过多介绍。&gt;### 说一说自己对于 synchronized 关键字的了解？ &gt; synchronized 关键字可以保证被修饰对象或操作的原子性和可见性，保证被修饰对象或操作任何时候只能有一个线程对其进行操作。 &gt; &gt; **synchronized 是悲观锁。**&gt; &gt; 在 Java 早期版本中，synchronized 属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的 synchronized 效率低的原因。&gt; &gt; 庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对 synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK 1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。&gt; #### synchronized 既可修饰非静态方法，也可修饰静态方法，还可修饰代码块，有何区别？ &gt; 当 synchronized 修饰静态方法或变量时，其实是获得被修饰方法或者变量所在的类的锁，即对类进行加锁。&gt; &gt; 当 synchronized 修饰非静态方法或者变量时，实际上是获得对应对象的锁。&gt; &gt; **尽量不要使用 synchronized(String a) 因为 JVM 中，字符串常量池具有缓存功能！**&gt; #### synchronized底层实现？ &gt;##### 当 synchronized 修饰同步语块时：```.public class SynchronizedDemo { public void method() { synchronized (this) { System.out.println(&quot;synchronized 代码块&quot;); } }} 通过 JDK 自带的 命令查看 SynchronizedDemo 类的相关字节码信息：首先切换到类的对应目录执行 ```javac SynchronizedDemo.java``` 命令生成编译后的 .class 文件，然后执行```javap -c -s -v -l SynchronizedDemo.class``12345678910111213&gt;&gt; ![synchronized 修饰同步语块](面经/24.png)&gt; &gt; synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。 当执行 monitorenter 指令时，线程试图获取锁也就是获取 monitor ( monitor 对象存在于每个 Java 对象的对象头中，synchronized 锁便是通过这种方式获取锁的，也是为什么 Java 中任意对象可以作为锁的原因) 的持有权。当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1。相应的在执行 monitorexit 指令后，将锁计数器设为0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。&gt; ##### 当 synchronized 修饰方法时```.public class SynchronizedDemo2 { public synchronized void method() { System.out.println(&quot;synchronized 方法&quot;); }} synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。 synchronized 和锁与 volatile区别？ synchronized 和锁需要通过操作系统来仲裁谁获得锁，开销比较高，而 volatile 开销小很多,因此 volatile 的效果更好。 volatile 本质是在告诉 JVM 当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取；synchronized 则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。 volatile 仅能使用在变量级别。synchronized 则可以使用在变量、方法、和类级别的。 volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。 volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。 volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。 介绍一下各种锁 (…) Lock 和 synchronized 区别，哪种性能更好以及原因？ 首先 synchronized 是 Java 内置关键字，在 JVM 层面，Lock 是个 Java类。 synchronized 无法判断是否获取锁的状态，Lock 可以判断是否获取到锁。（123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&gt; 3. synchronized 会自动释放锁(a 线程执行完同步代码会释放锁 。b 线程执行过程中发生异常会释放锁)，Lock 需在 ```finally{...}``` 中手工释放锁（ ```unlock()``` 方法释放锁），否则容易造成线程死锁。&gt; 4. 用 synchronized 关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去。而 Lock 锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了。(```lock.lockInterruptibly()```)&gt; 5. synchronized 的锁可重入、不可中断、非公平，而 Lock 锁可重入、可判断、可公平（两者皆可）&gt; 6. Lock 锁适合大量同步的代码的同步问题，synchronized 锁适合代码少量的同步问题。 ### ReentrantLock 与 synchronized 的异同？性能差异？&gt; 相同点：两者都是可重入锁。即一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。&gt; &gt; 不同点：除了上述*Lock 和 synchronized 区别*所列举的不同点外， ReenTrantLock 比 synchronized 增加了一些高级功能：&gt; &gt; 1. **ReenTrantLock 可以指定是公平锁还是非公平锁。而 synchronized 只能是非公平锁。**所谓的公平锁就是先等待的线程先获得锁。 ReenTrantLock 默认情况是非公平的，可以通过 ReenTrantLock 类的 ```ReentrantLock(boolean fair)``` 构造方法来制定是否是公平的。&gt; &gt; 2. synchronized 关键字与 wait() 和 notify() / notifyAll() 方法相结合可以实现等待/通知机制，ReentrantLock 类当然也可以实现，但是需要借助于 Condition 接口与 newCondition() 方法。Condition 是 JDK1.5 之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个Lock对象中可以创建多个 Condition 实例（即对象监视器），线程对象可以注册在指定的Condition 中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用 notify() / notifyAll() 方法进行通知时，被通知的线程是由 JVM 选择的，用 ReentrantLock 类结合 Condition 实例可以实现“选择性通知” ，这个功能非常重要，而且是 Condition 接口默认提供的。而 synchronized 关键字就相当于整个 Lock 对象中只有一个 Condition 实例，所有的线程都注册在它一个身上。如果执行 notifyAll() 方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而 Condition 实例的 signalAll() 方法 只会唤醒注册在该 Condition 实例中的所有等待线程。&gt; &gt; 在性能上：在JDK1.6之前，synchronized 的性能是比 ReenTrantLock 差很多。具体表示为：synchronized 关键字吞吐量岁线程数的增加，下降得非常严重。而ReenTrantLock 基本保持一个比较稳定的水平。我觉得这也侧面反映了， synchronized 关键字还有非常大的优化余地。后续的技术发展也证明了这一点，我们上面也讲了在 JDK1.6 之后 JVM 团队对 synchronized 关键字做了很多优化。JDK1.6 之后，synchronized 和 ReenTrantLock 的性能基本是持平了。所以网上那些说因为性能才选择 ReenTrantLock 的文章都是错的！JDK1.6之后，性能已经不是选择 synchronized 和 ReenTrantLock 的影响因素了！而且虚拟机在未来的性能改进中会更偏向于原生的 synchronized，所以还是提倡在 synchronized 能满足你的需求的情况下，优先考虑使用 synchronized 关键字来进行同步！优化后的 synchronized 和 ReenTrantLock 一样，在很多地方都是用到了 CAS 操作。### 锁和 synchronized 是否保证可见性？如何保证？&gt; 根据 JDK 中对 concurrent 包的说明，一个线程的写结果保证对另外线程的读操作可见，只要该写操作可以由 happen-before 原则推断出在读操作之前发生，因此锁和 synchronized 通过保证同一时间只有一个线程执行目标代码段来实现的。 ### 锁和 synchronized 可以保证原子性，为什么又需要AutomaticInteger来保证原子操作？&gt; 锁和 synchronized 需要通过操作系统来仲裁谁获得锁，开销比较高，而 AtomicInteger 是通过 CPU 级的 CAS 操作来保证原子性，开销比较小。 ### 如何判断一个对象是否有锁？&gt; ```java.lang.Thread.holdsLock()```，它是一个由native修饰的非java代码实现的方法。 ### Unsafe 类详解一下？&gt; 封装了一些不安全的操作，例如类似指针的 CAS 操作：compareAndSwapObject() 等，一旦操作不慎，指针偏移量设置错误，就可能导致系统崩溃等灾难性后果。Unsafe 实例需要调用其工厂 getUnsafe() 来获得，但 JDK 开发人员不希望开发者使用这个类，因此 getUnsafe() 内部实现中会判断调用者的类的类加载器是否为空，不为空则说明是应用程序类的 App Loader，为空的则为系统核心类如 Bootstrap 类的类加载器。只用为空的情况即调用类是系统核心类才能获得 Unsafe 类的实例，因此一般开发者开发时不能直接调用 Unsafe 类。 ### CAS 中 Unsafe 调的哪个方法？&gt; ```UNSAFE.compareAndSwapObject()``` ### 讲讲并发包（JUC）下面的类&gt; atomic、CyclicBarrier、CountDownLatch、CopyOnWriteArrayList、CopyOnWriteArraySet、ConcurrentSkipListSet、ConcurrentHashMap、ConcurrentSkipListMap、ArrayBlockingQueue, LinkedBlockingQueue、LinkedBlockingDeque、ConcurrentLinkedQueue、ConcurrentLinkedDeque … ### Atomic包？ &gt; AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。&gt; CAS 的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。UnSafe 类的 objectFieldOffset() 方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址，返回值是 valueOffset。另外 value 是一个 volatile 变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。```. // setup to use Unsafe.compareAndSwapInt for updates（更新操作时提供“比较并替换”的作用） private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final long valueOffset; static { try { valueOffset = unsafe.objectFieldOffset (AtomicInteger.class.getDeclaredField(&quot;value&quot;)); } catch (Exception ex) { throw new Error(ex); } } private volatile int value; AtomicInteger 常用方法1234567public final int get() //获取当前的值public final int getAndSet(int newValue)//获取当前的值，并设置新的值public final int getAndIncrement()//获取当前的值，并自增public final int getAndDecrement() //获取当前的值，并自减public final int getAndAdd(int delta) //获取当前的值，并加上预期的值boolean compareAndSet(int expect, int update) //如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）public final void lazySet(int newValue)//最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段 Threadlocal？ 通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。如果想实现每一个线程都有自己的专属本地变量该如何解决呢？ JDK 中提供的 ThreadLocal 类正是为了解决这样的问题。 ThreadLocal 类主要解决的就是让每个线程绑定自己的值，可以将 ThreadLocal 类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。 如果创建了一个 ThreadLocal 变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是ThreadLocal 变量名的由来。他们可以使用 get（） 和 set（） 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。 每个线程内部有一个 ThreadLocalMap （相当于 HashMap ），然后在存储变量的时候，最终的变量是放在了当前线程的 ThreadLocalMap 中，并且以 ThreadLocal 作为 key 值，并不是存在 ThreadLocal 上，ThreadLocal 可以理解为只是ThreadLocalMap的封装，传递了变量值。 ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用，而 value 是强引用。所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候会 key 会被清理掉，而 value 不会被清理掉。这样一来，ThreadLocalMap 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap 实现中已经考虑了这种情况，在调用 set()、get()、remove() 方法的时候，会清理掉 key 为 null 的记录。使用完 ThreadLocal方法后 最好手动调用 remove() 方法。 AQS？RPC调用？ 多个线程对同一个资源调用，如何区分每个线程 I/OJVM静态变量可以序列化吗？ 静态成员属于类级别的，所以不能序列化，序列化只是序列化了对象而已，这里“不能序列化”的意思是序列化信息中不包含这个静态成员域。 什么是 Java 虚拟机？ Java 虚拟机是一个可以执行Java字节码的虚拟机进程。Java 源文件被编译成能被 Java 虚拟机执行的字节码文件。 为什么 Java 被称作是“平台无关的编程语言”？ 因为 JVM 不和包括 Java 在内的任何语言绑定，它只和“文件”这种特殊的二进制文件绑定，```.class``` 文件包含了 JVM 指令集和符号表以及若干其他辅助信息；JVM 屏蔽了底层硬件平台的指令长度和其他特性，Java 程序都运行在 JVM 上而无需考虑计算机底层硬件平台的指令长度及其他特性。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596 ### JVM 作用？&gt; 1. 屏蔽底层硬件平台的指令长度及其他特性，实现 Java 平台无关性，增加 Java 的可移植性。&gt; 2. 提供 GC 内存回收机制，使得开发者可以让他们摆脱繁琐的内存管理工作，让开发更有效率。&gt; 3. 提供 Java 类加载机制。 ### JVM 调优？&gt;（详细到参数） ### JVM 内存结构？&gt; Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。JDK. 1.8 和之前的版本略有不同，下面会介绍到。&gt; &gt; **JDK 1.8之前**：&gt; ![JVM 内存结构1](面经/26.png)&gt; &gt; **JDK 1.8开始**：&gt; ![JVM 内存结构2](面经/27.png)&gt; &gt; |共享情况|区域|&gt; |:---:|---|&gt; |线程私有|程序计数器、虚拟机栈、本地方法栈|&gt; |线程共享|堆、方法区、运行时常量池、直接内存、元空间|&gt; #### 哪些是运行时数据区？&gt; 程序计数器、虚拟机栈、本地方法栈、堆、方法区、运行时常量池&gt;#### 程序计数器&gt; **用于记录当前线程执行的字节码的行号。**字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称**程序计数器为“线程私有”的内存。**&gt; &gt; **程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。**&gt; #### 虚拟机栈&gt; **Java 虚拟机栈是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。**&gt; &gt; 实际上，Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。Java 栈可用类比数据结构中栈，Java 栈中保存的主要内容是栈帧，每一次函数调用都会有一个对应的栈帧被压入 Java 栈，每一个函数调用结束（return 语句或抛出异常）后，都会有一个栈帧被弹出。&gt; &gt; 局部变量表主要存放了编译器可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。&gt; &gt; **Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。**&gt; &gt; 1. **StackOverFlowError**：若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 异常。&gt; &gt; 2. **OutOfMemoryError**：若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出 OutOfMemoryError 异常。 &gt; #### 本地方法栈&gt; 本地方法栈用途与 Java 虚拟机栈一样，只是服务于 Native 本地方法。它会出现 StackOverFlowError 和 OutOfMemoryError 两种异常。在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。&gt;#### 堆&gt; Java 虚拟机所管理的内存中最大的一块，**Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建**。此内存区域的**唯一目的就是存放对象实例**，几乎所有的对象实例以及数组都在这里分配内存。&gt; &gt; Java 堆是垃圾收集器管理的主要区域，因此也被称作 GC 堆（Garbage Collected Heap）.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。进一步划分的目的是更好地回收内存，或者更快地分配内存。&gt; &gt; ![堆](面经/28.png) &gt; &gt; 上图所示的 eden 区、s0 区、s1 区都属于新生代，tentired 区属于老年代。大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区-&gt; Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数``` -XX:MaxTenuringThreshold``` 来设置。&gt; #### 方法区&gt; 方法区与 Java 堆一样，**是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据**。虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。但在 JDK 1.8 开始，方法区被取消，取而代之的是在直接内存中划分了一片区域称为元空间。&gt; &gt; **方法区常用参数**：&gt; |参数|功能|&gt; |:---:|---|&gt; |```-XX:PermSize=N ```|方法区 (永久代) 初始大小|&gt; |```-XX:MaxPermSize=N```|方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen|&gt;#### 元空间&gt; JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，**元空间使用的是直接内存**。与方法区（永久代）很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。整个方法区（永久代）有一个 JVM 本身设置固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，并且永远不会得到 ```java.lang.OutOfMemoryError```。&gt; &gt; **元空间常用参数**：&gt; &gt; |参数|功能|&gt; |:---:|---|&gt; |```-XX:MetaspaceSize=N ```|元空间初始大小|&gt; |```-XX:MaxMetaspaceSize=N```|元空间最大大小|&gt; #### 运行时常量池&gt; **运行时常量池是方法区的一部分。** .class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用）。既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，**当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常**。&gt; &gt; JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。&gt; #### 直接内存&gt; 直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 异常出现。&gt; &gt; JDK1.4 中新加入的 NIO(New Input/Output) 类，引入了一种基于通道（Channel） 与缓存区（Buffer） 的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据。&gt; &gt; 本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。 ### JDK1.7 对 JVM 内存结构 / Java 虚拟机运行时数据区有何改变？&gt; JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。 ### JDK1.8 对 JVM 内存结构/ Java 虚拟机运行时数据区有何改变？&gt; 取消了方法区，取而代之的是在直接内存中设置了元空间，代替其作用 ### 对象晋升到老年代的年龄阈值参数&gt; ```-XX:MaxTenuringThreshold 方法区和永久代的关系 方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。 也就是说，永久代是 HotSpot 的概念，方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久带这一说法。 为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢? 除了一些底层原因外，还有整个永久代有一个 JVM 本身设置固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，并且永远不会得到 ```-XX：MaxMetaspaceSize``` 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。```-XX：MetaspaceSize``` 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182 ### JVM 内存分配的方法？&gt; **选择那种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。**&gt; &gt; ![JVM 存放变量的位置](面经/29.png) ### JVM 内存分配时的并发问题&gt; 由于创建对象是非常频繁的操作，因此 JVM 通过两种方式创建对象：&gt; &gt; 1. **CAS 失败重试**： CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。**虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。**&gt; 2. **TLAB**：为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配。 ### 如何设置堆的大小？&gt; JVM 初始分配的内存由 ```-Xms``` 指定，默认是物理内存的1/64；JVM 最大分配的内存由 ```-Xmx``` 指定，默认是物理内存的1/4。默认空余堆内存小于40%时，JVM 就会增大堆到 ```-Xmx``` 的最大限制；空余堆内存大于70%时，JVM 会减少堆直到 ```-Xms``` 的最小限制。因此服务器一般设置 ```-Xms```、 ```-Xmx``` 相等以避免在每次GC后调整堆的大小。 ### 如何设置非堆（方法区）内存的大小？&gt; JVM 使用 ```-XX:PermSize``` 设置非堆内存初始值，默认是物理内存的1/64；由 ```-XX:MaxPermSize``` 设置最大非堆内存的大小，默认是物理内存的1/4。### JVM 最大内存限制多少？&gt; 首先 JVM 内存限制于实际的最大物理内存，假设物理内存无限大的话，JVM 内存的最大值跟操作系统有很大的关系。简单的说就32位处理器虽然可控内存空间有4GB,但是具体的操作系统会给一个限制，这个限制一般是2GB-3GB（一般来说 Windows 系统下为1.5G-2G，Linux系 统下为2G-3G），而64bit以上的处理器就不会有限制了。### OOM出现&gt; 虚拟机栈或本地方法栈堆动态扩容不足，Java 堆中引用无法正确释放等。 ### JVM 存放变量的位置 &gt; 对于局部方法变量，存放在 Java 虚拟机栈中的局部变量表中；&gt; 对于本地（Native）方法的变量，存放在本地方法栈中的响应区域中；&gt; 对于静态变量，存放在方法区（或元空间）中；&gt; 对于实例变量，存放在堆中。 ### Java 创建对象过程？&gt; ![Java 创建对象过程](面经/30.png) &gt; &gt; 1. **类加载检查**：虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。&gt; &gt; 2. **分配内存**：在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java **堆**中划分出来。分配方式有 “**指针碰撞**” 和 “**空闲列表**” 两种，**选择那种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定**。&gt; &gt; 3. **初始化零值**：内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。 &gt; &gt; 4. **设置对象头**：初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。&gt; &gt; 5. **执行 &lt;init&gt; 方法**：在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，```&lt;init&gt;``` 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 ```&lt;init&gt;``` 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。### JVM 是如何实现线程的？&gt; 在JVM规范里是没有规定线程要以哪种形式创建——具体实现用1:1（内核线程）、N:1（用户态线程）、M:N（混合）模型的任何一种都可以。Java并不暴露出不同线程模型的区别，上层应用是感知不到差异的（只是性能特性会不太一样…）。其中用户线程在内核之上支持，并在用户层通过线程库来实现。不需要用户态/核心态切换，速度快。操作系统内核不知道多线程的存在，因此一个线程阻塞将使得整个进程（包括它的所有线程）阻塞。由于这里的处理器时间片分配是以进程为基本单位，所以每个线程执行的时间相对减少。内核线程由操作系统直接支持。由操作系统内核创建、调度和管理。内核维护进程及线程的上下文信息以及线程切换。一个内核线程由于I/O操作而阻塞，不会影响其它线程的运行。### Java 对象结构 / Java 对象内存布局 &gt; Java 对象的内存分配在堆中，其中，在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：**对象头**、**实例数据**和**对齐填充**。&gt; &gt; Hotspot 虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的自身运行时数据（哈希码、GC 分代年龄、锁状态标志等等），另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。&gt; &gt; 实例数据部分是对象真正存储的有效信息，也是在程序中所定义的各种类型的字段内容。&gt; &gt; 对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。### Java 对象访问方式&gt; 建立对象就是为了使用对象，Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有两种：&gt; &gt; 1. **句柄**：如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，reference 本身不需要修改。&gt; ![Java 对象访问方式1](面经/31.png)&gt; &gt; 2. **直接指针**： 如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。&gt; ![Java 对象访问方式2](面经/32.png) ### String 对象的两种创建方式```.String str1 = &quot;abcd&quot;;//先检查字符串常量池中有没有&quot;abcd&quot;，如果字符串常量池中没有，则创建一个，然后 str1 指向字符串常量池中的对象，如果有，则直接将 str1 指向&quot;abcd&quot;&quot;；String str2 = new String(&quot;abcd&quot;);//堆中创建一个新的对象String str3 = new String(&quot;abcd&quot;);//堆中创建一个新的对象System.out.println(str1==str2);//falseSystem.out.println(str2==str3);//false``` &gt; 1. **在常量池中拿对象**：直接使用双引号声明出来的 String 对象会直接存储在常量池中。如果不是用双引号声明的 String 对象，可以使用 String 提供的 ```intern()``` 方法。```String.intern()``` 是一个 Native 方法，它的作用是：如果运行时常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用；如果没有，在 JDK1.6 中，```intern()``` 方法会把首次遇到的字符串实例复制到永久代（运行时常量池）中，返回的也是永久代中这个字符串的引用；而在 JDK1.7 中，```intern()``` 则不会再复制实例，只是在常量池中记录首次出现的实例的引用。&gt; 2. **直接在堆内存空间创建一个新的对象**：**只要使用 new 方法，便需要创建新的对象**。 ### ```String s1 = new String(&quot;abc&quot;);``` 这句话创建了几个字符串对象？ ```.String s1 = new String(&quot;abc&quot;);// 堆内存的地址值String s2 = &quot;abc&quot;;System.out.println(s1 == s2);// 输出 false,因为一个是堆内存，一个是常量池的内存，故两者是不同的。System.out.println(s1.equals(s2));// 输出 true 如果运行时常量池中已经存在了“abc”字符串，则只会在 new 时创建一个对象；如果运行时常量池不存在“abc” ，则会先在运行时常量池中创建一个“abc”字符串对象，然后再在 new 的时候创建一个对象，一共创建两个对象。 线程什么时候创建在 JVM ？ (…) JVM 是否一定会创建线程？ (…) 类的唯一性决定条件 类本身和加载这个类的类加载器。只有两个类是同一类加载器加载的前提下，两个类才可能相等。否则，即使两个类源自同一个 .class文件，被同一个 JVM 加载，只要加载它们的类加载器不相同，这两个类必定不相等。 Java 类加载过程？ 加载：1. 通过全类名获取定义此类的二进制字节流。 2。 将字节流所代表的静态存储结构转换为方法区的运行时数据结构。 3. 在内存中生成一个代表该类的 Class 对象,作为方法区这些数据的访问入口。一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的 方法）。**数组类型不通过类加载器创建，它由 Java 虚拟机直接创建**。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109&gt; &gt; 2. **验证**：&gt; ![验证](面经/34.png) &gt; &gt; 3. **准备**：**准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配**。对于该阶段有以下几点需要注意：1. 这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在 Java 堆中。2. 这里所设置的初始值&quot;通常情况&quot;下是数据类型默认的零值（如0、0L、null、false等），比如我们定义了public static int value=111 ，那么 value 变量在准备阶段的初始值就是 0 而不是111（初始化阶段才会复制）。特殊情况：比如给 value 变量加上了 fianl 关键字public static final int value=111 ，那么准备阶段 value 的值就被复制为 111。&gt; &gt; 4. **解析**：**解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程**。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符7类符号引用进行。Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方发表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。综上，解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。&gt; &gt; 5. **初始化**：初始化是类加载的最后一步，也是真正执行类中定义的 Java 程序代码(字节码)，初始化阶段是执行类构造器 ```&lt;clinit&gt;()``` 方法的过程。对于 ```&lt;clinit&gt;()``` 方法的调用，虚拟机会自己确保其在多线程环境中的安全性。因为 ```&lt;clinit&gt;()``` 方法是带锁线程安全，所以在多线程环境下进行类初始化的话可能会引起死锁，并且这种死锁很难被发现。 ### 必须立即对类进行初始化的情况？/ 主动引用的情况？&gt; 除了一下情况下，其他都是被动引用。&gt; &gt; 1. 当遇到 ```new``` 、 ```getstatic```、```putstatic``` 或 ```invokestatic``` 这4条直接码指令时，比如 new 一个类，读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法时。&gt; 2. 使用 java.lang.reflect 包的方法对类进行反射调用时 ，如果类没初始化，需要触发其初始化。&gt; 3. 初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。&gt; 4. 当虚拟机启动时，用户需要定义一个要执行的主类 (包含 main 方法的那个类)，虚拟机会先初始化这个类。&gt; 5. 当使用 JDK1.7 的动态动态语言时，如果一个 MethodHandle 实例的最后解析结构为 REF_getStatic、REF_putStatic、REF_invokeStatic、的方法句柄，并且这个句柄没有初始化，则需要先触发器初始化。 ### 什么是符号引用？什么是直接引用？&gt; **符号引用**与虚拟机实现的布局无关，引用的目标并不一定要已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在 Java 虚拟机规范的 .class 文件格式中。&gt; &gt; **直接引用**可以是指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。如果有了直接引用，那引用的目标必定已经在内存中存在。 ### 类加载器的种类？&gt; 从 JVM 的角度看有两种：&gt; &gt; 1. 启动类加载器（C++语言实现，是 JVM 的一部分）&gt; 2. 其他类加载器（Java 语言实现，独立于 JVM，全部都是继承自抽象类 ```java.lang.ClassLoader``` ）。&gt; &gt; 从 Java 开发人员来看有三种：&gt; &gt; 1. 启动类加载器（负责加载 ```JAVA_HOME\\lib``` 目录中的，或通过 ```-Xbootclasspath``` 参数指定路径中的，且被虚拟机认可（按文件名识别，如 rt.jar）的类，它无法被Java程序直接引用）&gt; 2. 扩展类加载器（负责加载 ```JAVA_HOME\\lib\\ext``` 目录中的，或通过 ```java.ext.dirs``` 系统变量指定路径中的类库，开发者可以直接使用）&gt; 3. 应用程序类加载器（负责加载用户路径（classpath）上的类库，开发者可以直接使用）） ### 什么是双亲委派模型？它有什么作用？&gt; 当一个类加载器收到类加载任务，会先交给其父类加载器去完成，因此最终加载任务都会传递到顶层的启动类加载器，只有当父类加载器无法完成加载任务时，才会尝试执行加载任务。采用双亲委派的一个好处是**保证 Java 核心库的安全性**。比如加载位于 ```.rt.jar``` 包中的类 ```java.lang.Object```，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个 Object 对象。 ### 什么时候会用户加载器会直接加载类不向上传递？/ 如何避免双亲委派模型？&gt; 为了避免双亲委托机制，我们可以自己定义一个类加载器，然后重载 ```loadClass()``` 即可。 ### GC基本原理&gt; 对于 GC 来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。通常，GC 采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是”可达的”，哪些对象是”不可达的”。当 GC 确定一些对象为”不可达”时，GC 就有责任回收这些内存空间。可以。程序员可以手动执行 ```System.gc()``` ，通知 GC 运行，但是 Java 语言规范并不保证GC一定会执行。### GC算法？&gt; 1. 标记-清除算法&gt; 2. 复制算法&gt; 3. 标记-整理算法&gt; 4. 分代收集算法 ### STW &gt; STW 即 Stop The World 的简称，指 JVM 在 进行 Full GC 时将所有工作线程暂停、挂起来进行垃圾回收。过多的 STW 会影响程序性能。 ### Full GC 发生的条件？&gt; 1. **调用 ```System.gc()```**&gt; 2. **老年代空间不足**：老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等，当执行 Full GC 后空间仍然不足，则抛出 ```Java.lang.OutOfMemoryError```。为避免以上原因引起的 Full GC，调优时应尽量做到让对象在 Minor GC 阶段被回收、让对象在新生代多存活一段时间以及不要创建过大的对象及数组。&gt; 3. **空间内存担保失败**&gt; 4. **Concurrent Mode Failure**：执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（有时候“空间不足”是 CMS GC 时当前的浮动垃圾过多导致暂时性的空间不足触发 Full GC），便会报 Concurrent Mode Failure 错误，并触发 Full GC。 ### 怎么减少 Full GC？ &gt; 1. 方法区空间增大&gt; 2. 老年代空间增大&gt; 3. 新生代空间减小&gt; 4. 禁止使用 ```System.gc()``` 方法（或者少使用）&gt; 5. 使用标记-整理算法，尽量让连续空间保持最大&gt; 6. 排查代码中的无用大对象(内存泄漏) ### 你使用的 Java JDK 版本，该版本有哪些 GC，其运行机制是怎样的？&gt; （从 堆的分区 + 关注堆和元空间（注意JDK 1.8 已经没有方法区了！） + GC算法 + GC 回收器 等方面来谈） ### GC 中如何判断对象是否需要被回收？&gt; 1. 引用计数法&gt; 2. 可达性分析算法 ### JVM GC Root 以及为什么它们可以是 GC Root？&gt; JVM 栈中局部变量表中的引用对象、方法区中类静态属性引用的对象、方法区中常量引用的对象、本地方法栈中 JNI 引用的对象。因为这些节点主要在全局性的引用或者执行上下文中，不会被轻易回收。 ### 不可达的对象是否“非死不可”？&gt; 即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize() 方法。当对象没有重写 finalize() 方法，或 finalize() 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。&gt; &gt; 被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。### 如何判断一个常量是一个废弃的常量？ &gt; **运行时常量池主要回收的是废弃的常量**。假如在常量池中存在字符串 &quot;abc&quot;，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 &quot;abc&quot; 就是废弃常量，如果这时发生内存回收的话而且有必要的话，&quot;abc&quot; 就会被系统清理出常量池。 ### 如何判断一个类是无用的类&gt; **方法区主要回收的是无用的类**。判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 “无用的类” ：&gt; &gt; 1. 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。&gt; 2. 加载该类的 ClassLoader 已经被回收。&gt; 3. 该类对应的 ```java.lang.Class``` 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。&gt; &gt; 虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。### 四种引用？软引用和弱引用的区别？软引用和强引用的区别？&gt; 1. **强引用**：大部分对象是强引用的。强引用是指必要的引用，是 GC 不会回收的引用。&gt; 2. **软引用**：软引用是指可有可无的引用，只有内存不够时 GC 才会回收。&gt; 3. **弱引用**：弱引用是当 GC 一旦发现就会立即回收的引用。&gt; 4. **虚引用**：虚引用即没有引用，必须和引用队列联合使用。&gt; #### 虚引用作用？&gt; 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生。 ### 垃圾回收器可以马上回收内存吗？&gt; 垃圾回收器通常是作为一个单独的低级别的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清楚和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。程序员可以手动执行 ```System.gc()```，通知 GC 运行，但是 Java 语言规范并不保证 GC 一定会执行。 ### 有什么办法可以主动通知虚拟机进行垃圾回收呢？&gt; ```System.gc() 请说明一下 Eden 区和 Survivor区 的含义以及工作原理？ Eden 区和 Survivor 区是 Java 堆的年轻代的两种分区，一般有两个 Survivor 区（From Survivor 和 To Surivior），且每一次 Minor GC 后，两个 Survivor 区的角色会互换。对象基本上都是在 Eden 区内创建的（除了如数组等大对象直接在老年代中创建），然后每次 Minor GC 的时候通过复制算法将 Eden 区和 From Survivor 区中存活的对象复制到 To Survivor 区中，然后两个 Survivor 区角色互换。大约经历15次 Minor GC 后，Survivor 区中存活的对象会进入老年代中。 为什么要分代？ 对传统的、基本的 GC 实现来说，由于它们在 GC 的整个工作过程中都要 “stop-the-world” ，导致整个 GC 堆耗时太长，因此需要想办法只收集其中的一部分以减少停顿时间。因此而诞生了几种不同的划分（partition）GC 堆的方式来实现部分收集，而分代式 GC 就是这其中的一个思路。 分配担保机制? 把新生代的对象提前转移到老年代中去，只要老年代上的空间足够存放，就不会出现 Full GC。执行 Minor GC 后，后面分配的对象如果能够存在 Eden 区的话，还是会在 Eden 区分配内存。 大对象直接进入老年代？ 大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。原因：为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。 动态对象年龄判定 如果 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需达到要求的年龄。 什么原因会导致Minor GC运行频繁？同样的，什么原因又会导致Minor GC运行很慢？请简要说明一下 可能是堆内存太小或者是年轻代分配内存过小。 简要介绍一下CMS的回收流程？ CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。从名字中的Mark Sweep这两个词可以看出，CMS 收集器是一种 “标记-清除”算法实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤： 初始标记： 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快。 并发标记： 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。 重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短。 并发清除： 开启用户线程，同时 GC 线程开始对为标记的区域做清扫。 CMS采用哪种回收算法？ 标记-清除算法 —— 会导致碎片问题 CMS 的浮动垃圾问题以及解决方法 由于 CMS 在并发清除的时候还有应用线程在工作，导致这些线程产生的垃圾在 GC 中无法被清除，而到下一次 CMS 并发清除又有一段时间，可能导致“Concurrent Mode Failure”而引发 Full GC，因此 CMS 不能像别的收集器一样等到老年代快满的时候才开始工作，而是应该到达一定的阈值后进行一次回收。可以通过设置参数 CMSInitiatingOccupancyFraction``` 来设置该阈值1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071 ### CMS 遇到“Concurrent Mode Failure”会怎样？&gt; 会启动后备预案：临时启动Serial Old收集器重新进行老年代的垃圾收集，但这样会导致停顿时间延长。 ### 使用 CMS 怎样解决内存碎片的问题呢？&gt; 开启 ```-XX: +UseCMSCompactAtFullCollection``` 参数，用于在 CMS 顶不住要进行 Full GC 时开启碎片合并过程，但这样解决了碎片问题，停顿时间又变长了。因此，可以设置 ```-XX: CMSFullGCsBeforeCompaction``` 参数用于设置执行多少次不压缩的 Full GC 后进行一次带压缩的 Full GC ### 介绍一下G1收集器？&gt; **G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器。**以极高概率满足 GC 停顿时间要求的同时，还具备高吞吐量性能特征。&gt; &gt; 被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备一下特点：&gt; &gt; 1. **并行与并发**：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 Java 程序继续执行。&gt; 2. **分代收集**：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。&gt; 3. **空间整合**：与 CMS 的“标记--清理”算法不同，**G1 从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。**&gt; 4. **可预测的停顿**：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。&gt; &gt; G1 收集器的运作大致分为以下几个步骤：&gt; &gt; 1. 初始标记&gt; 2. 并发标记&gt; 3. 最终标记&gt; 4. 筛选回收&gt; &gt; G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 GF 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。# Servlet# Spring # MySQL ### MySQL基础语法？&gt; (...) ### MySQL 基础架构？&gt; ![MySQL 基础架构](面经/36.png) &gt; &gt; 简单来说 MySQL 主要分为 **Server 层**和**存储引擎层**：&gt; &gt; **Server 层**：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binglog 日志模块。&gt; &gt; **存储引擎**： 主要负责数据的存储和读取，采用可以替换的插件式架构，支持 InnoDB、MyISAM、Memory 等多个存储引擎，其中 InnoDB 引擎有自有的日志模块 redolog 模块。现在最常用的存储引擎是 **InnoDB，它从 MySQL 5.5.5 版本开始就被当做默认存储引擎了**。&gt; #### Server 层组成部分介绍？&gt; **连接器**：**连接器主要和身份认证和权限相关的功能相关**，就好比一个级别很高的门卫一样。主要负责用户登录数据库，进行用户的身份认证，包括校验账户密码，权限等操作，如果用户账户密码已通过，连接器会到权限表中查询该用户的所有权限，之后在这个连接里的权限逻辑判断都是会依赖此时读取到的权限数据，也就是说，**后续只要这个连接不断开，即时管理员修改了该用户的权限，该用户也是不受影响的**。&gt; &gt; **查询缓存（MySQL 8.0 后移除）**：**查询缓存主要用来缓存我们所执行的 SELECT 语句以及该语句的结果集。**连接建立后，执行查询语句的时候，会先查询缓存，MySQL 会先校验这个 SQL 是否执行过，以 Key-Value 的形式缓存在内存中，Key 是查询预计，Value 是结果集。如果缓存 key 被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把结果缓存起来，方便下一次调用。当然在真正执行缓存查询的时候还是会校验用户的权限，是否有该表的查询条件。MySQL 查询不建议使用缓存，因为查询缓存失效在实际业务场景中可能会非常频繁，假如你对一个表更新的话，这个表上的所有的查询缓存都会被清空。对于不经常更新的数据来说，使用缓存还是可以的。所以，一般在大多数情况下我们都是不推荐去使用查询缓存的。MySQL 8.0 版本后删除了缓存的功能，官方也是认为该功能在实际的应用场景比较少，所以干脆直接删掉了。&gt; &gt; **分析器**：MySQL 没有命中缓存，那么就会进入分析器，**分析器主要是用来分析 SQL 语句是来干嘛的**，分析器也会分为几步：&gt; 1. **词法分析**，一条 SQL 语句有多个字符串组成，**首先要提取关键字，比如 select，提出查询的表，提出字段名，提出查询条件等等**。做完这些操作后，就会进入第二步。&gt; 2. **语法分析**，主要就是判断你输入的 SQL 是否正确，**是否符合 MySQL 的语法**。&gt; &gt; **优化器**：**它的作用就是按照它认为的最优的执行方案去执行**（有时候可能也不是最优），比如多个索引的时候该如何选择索引，多表查询的时候如何选择关联顺序等。可以说，**经过了优化器之后可以说这个语句具体该如何执行就已经定下来**。&gt; &gt; **执行器**：当选择了执行方案后，MySQL 就准备开始执行了，首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息，如果有权限，就会去调用引擎的接口，返回接口执行的结果。&gt; &gt; **binlog**：通用日志模块。### WHERE 和 HAVING区别？&gt; ```WHERE``` 是直接从表中进行筛选，而 ```HAVING``` 是从前面已经筛选过的字段中进一步筛选。即 ```HAVING``` 后面的字段必须在前面出现过，否则只能用 ```WHERE``` ；而当 ```WHERE``` 后面的字段是经过处理如avg()、max()……等方法处理后，则意味着处理后的字段不存在原表中，此时则必须使用 ```HAVING``` 而不能使用 ```WHERE```。### AUTO_INCREMENT 有什么需要注意的？&gt; 自增字段必须是索引,而且是索引的第一列,不一定要是主键。 ### MySQL 获取 AUTO_INCREMENT 下一值的方法？```. mysql&gt;CREATETABLE `get_max_id` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT &apos;业务主键&apos;, `content` char(25) DEFAULT NULL COMMENT &apos;业务内容&apos;, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; 1.max(id)：直接简单获取，同时，它无视其它客户端连接（db_connection）的影响。 1234567mysql&gt;select max(id) from get_max_id; +---------+ | max(id) | +---------+ | NULL | +---------+row in set (0.00 sec) 2.LAST_INSERT_ID()：返回最后一个INSERT 或 UPDATE 查询中， AUTO_INCREMENT 列设置的第一个表的值。但它有些限制的： 同一个 Connection 连接对象(同一客户端)中，SELECT 的结果为最后一次 的 AUTO_INCREMENT 属性列的 ID。这句话的重点在于“同一个”，即其他连接的客户端不对其查询的结果造成影响。假设客户端 A 和 B，表 ta 原自增 ID 为3，在A中插入记录后产生自增 ID 为4，在客户端 A 中通过该函数查询的结果为4，但在客户端 B 中查询的结果值仍为3。12345678910111213&gt; 2. 与表无关，即假设 ta 表和 tb 表，向 ta 插入记录后，再向 tb 插入记录，结果值为 tb 的max(id) 值。&gt; 3. 使用非魔术方法（&apos;magic&apos;）来 ```INSERT``` 或 ```UPDATE``` 一条记录时，即使用非0/非 NULL 值作为插入的字段，则 LAST_INSERT_ID() 返回值不会发生变化。&gt; 4. 同一条 INSERT 语句中，传入多个 VALUES 值，则 LAST_INSERT_ID() 返回值为该查询第一条记录的ID。&gt; 5. 在进阶方面，可运用作分表ID的唯一性。 ```.mysql&gt;select LAST_INSERT_ID(); +------------------+ | LAST_INSERT_ID() | +------------------+ | 0 | +------------------+row in set (0.00 sec) 3.查看表状态 show table status：该方式提供了当前 DB（use db_name;）下每个表的基本信息；可以通过 Auto_increment 属性的值。123456789```.mysql&gt; show table status where Name=&apos;get_max_id&apos;;+------------+--------+---------+------------+------+----------------+-------------+-----------------+--------------+-----------+----------------+---------------------+-------------+------------+-----------------+----------+----------------+---------+| Name | Engine | Version | Row_format | Rows | Avg_row_length | Data_length | Max_data_length | Index_length | Data_free | Auto_increment | Create_time | Update_time | Check_time | Collation | Checksum | Create_options| Comment |+------------+--------+---------+------------+------+----------------+-------------+-----------------+--------------+-----------+----------------+---------------------+-------------+------------+-----------------+----------+----------------+---------+| get_max_id | InnoDB | 10 | Compact | 0 | 0 | 16384 | 0 | 0 | 10485760 | 1 | 2015-04-20 11:49:07 | NULL | NULL | utf8_general_ci | NULL | | |+------------+--------+---------+------------+------+----------------+-------------+-----------------+--------------+-----------+----------------+---------------------+-------------+------------+-----------------+----------+----------------+---------+row in set (0.00 sec) 4.information_schema.tables：提供关于数据库中的表（包括视图）的信息。详细描述了某个表属于哪个schema，表类型，表引擎等等信息。 1234567mysql&gt; select table_name, AUTO_INCREMENT from information_schema.tables where table_name=&quot;get_max_id&quot;;+------------+----------------+| table_name | AUTO_INCREMENT |+------------+----------------+| get_max_id | 1 |+------------+----------------+1 row in set (0.01 sec) 5.@@IDENTITY全局变量：（基础：以@@开头的变量为全局变量，而以@开头的变量为用户自定义的变量。）此处 @@IDENTITY 表示最近一次向具有 identity 属性（auto_increment）的表 INSERT 数据时对应的自增列的值。此处得到的值是0。 类似于 LAST_INSERT_ID() 函数，该方式必须在同一个客户端内进行的 与 ```SELECT```，且不受其他客户端影响。123456789101112&gt; 2. 与表无关。&gt; 3. 非魔术方法插入不影响结果值。&gt; 4. 同一 ```INSERT``` 插入多条记录，取第一条记录的 ID 值为结果。```.mysql&gt; select @@IDENTITY;+------------+| @@IDENTITY |+------------+| 0 |+------------+1 row in set (0.00 sec) 一条MySQL语句的执行流程？ 查询语句执行流程 * from tb_student A where A.age123456789&gt; &gt; 1. 连接器检查用户权限，如果没有权限，则返回错误信息，否则进行下一步。&gt; 2. 在 MySQL 8.0 之前，会将这条语句作为 key 查询缓存，如果有缓存结果，则直接返回结果集，结束查询，否则进入下一步。在 MySQL 8.0 后，则直接忽略此步。&gt; 3. 分析器提取并分析关键字，提取名为 ```tb_student``` 的表，提取需要查询所有的列，查询条件是这个表的 id=&apos;1&apos;。然后判断这个 SQL 语句是否有语法错误，比如关键词是否正确等等，如果检查没问题就执行下一步。&gt; 4. 优化器根据自己的优化算法进行选择执行效率最好的一个方案（优化器认为，有时候不一定最好）。&gt; 5. 执行器根据上述方案调用对应的引擎接口执行查询操作并返回结果。&gt;#### 更新语句执行流程&gt; ```update tb_student A set A.age=&apos;19&apos; where A.name=&apos; 张三 &apos;; 执行更新的时候肯定需要记录日志，这就会引入 MySQL 自带的日志模块式 binlog（归档日志） ，所有的存储引擎都可以使用，常用的 InnoDB 引擎还自带了一个日志模块 redo log（重做日志），现在就以 InnoDB 模式下来探讨这个语句的执行流程。 连接器检查用户权限，如果没有权限，则返回错误信息，否则进行下一步。 在 MySQL 8.0 之前，会将这条语句作为 key 查询缓存，如果有缓存结果，则直接返回结果集，结束查询，否则进入下一步。在 MySQL 8.0 后，则直接忽略此步。 分析器提取并分析关键字，提取名为 的表，提取需要查询所有的列。然后判断这个 SQL 语句是否有语法错误，比如关键词是否正确等等，如果检查没问题就执行下一步。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129&gt; 4. 优化器根据自己的优化算法进行选择执行效率最好的一个方案（优化器认为，有时候不一定最好）。&gt; 5. 执行器然后拿到查询的语句，把 age 改为 19，然后调用引擎 API 接口，写入这一行数据&gt; 6. InnoDB 引擎把数据保存在内存中，同时记录 redo log，此时 redo log 进入 prepare 状态，然后告诉执行器，执行完成了，随时可以提交。&gt; 7. 执行器收到通知后记录 binlog。&gt; 8. 执行器调用引擎接口，提交 redo log 为 commit 提交状态。更新完成。 ### 为什么 MySQL 要 binlog 和 redo log 两个日志文件？/ MySQL 如何解决数据一致性问题？&gt; 这是因为最开始 MySQL 并没与 InnoDB 引擎( InnoDB 引擎是其他公司以插件形式插入 MySQL 的) ，MySQL 自带的引擎是 MyISAM，但是 redo log 是 InnoDB 引擎特有的，其他存储引擎都没有，这就导致会没有 crash-safe 的能力(crash-safe 的能力即使数据库发生异常重启，之前提交的记录都不会丢失)，binlog 日志只能用来归档。&gt; &gt; 并不是说只用一个日志模块不可以，只是 **InnoDB 引擎就是通过 redo log 来支持事务的**。那么，用两个日志模块，为什么 redo log 要引入 prepare 预提交状态？这里用反证法来说明下为什么要这么做？&gt; &gt; 1. **先写 redo log 直接提交**，然后写 binlog，假设写完 redo log 后，机器挂了，binlog 日志没有被写入，那么机器重启后，这台机器会通过 redo log 恢复数据，但是这个时候 bingog 并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时主从同步也会丢失这一条数据。&gt; &gt; 2. **先写 binlog，然后写 redo log**，假设写完了 binlog，机器异常重启了，由于没有 redo log，本机是无法恢复这一条记录的，但是 binlog 又有记录，那么和上面同样的道理，就会产生数据不一致的情况。&gt; &gt; 如果采用 **redo log 两阶段提交**的方式就不一样了，写完 binglog 后，然后再提交 redo log 就会防止出现上述的问题，从而保证了数据的一致性。&gt; #### MySQL更新数据库时异常重启的处理过程？/ MySQL 如何实现回滚？&gt; 那么问题来了，有没有一个极端的情况呢？假设 redo log 处于预提交状态，binglog 也已经写完了，这个时候发生了异常重启会怎么样呢？ 这个就要依赖于 MySQL 的处理机制了，MySQL 的处理过程如下：&gt; &gt; 1. 判断 redo log 是否完整，如果判断是完整的，就立即提交。&gt; 2. 如果 redo log 只是预提交但不是 commit 状态，这个时候就会去判断 binlog 是否完整，如果完整就提交 redo log, 不完整就回滚事务。&gt; &gt; 这样就解决了数据一致性的问题。 ### MySQL如果多次执行同一条 update 语句，会执行成功吗？&gt; 在 ```binlog_format=row``` 和 ```binlog_row_image=FULL``` 时，由于 MySQL 需要在 binlog 里面记录所有的字段，所以在读数据的时候就会把所有数据都读出来，那么重复数据的 update 不会执行。即 MySQL 调用了 InnoDB 引擎提供的“修改为 (1,55)”这个接口，但是引擎发现值与原来相同，不更新，直接返回。&gt; 在 ```binlog_format=statement``` 和 ```binlog_row_image=FULL``` 时，InnoDB 内部认真执行了 update 语句，即“把这个值修改成 (1,999)“这个操作，该加锁的加锁，该更新的更新。 ### 介绍一下 SQL 语句预编译？ &gt; 通常一条 SQL 在 db 接收到最终执行完毕返回可以分为下面三个过程：&gt; &gt; 1. 词法和语义解析&gt; 2. 优化sql语句，制定执行计划&gt; 3. 执行并返回结果&gt; &gt; 我们把这种普通语句称作 Immediate Statements。&gt; 但是很多情况，我们的一条 SQL 语句可能会反复执行，或者每次执行的时候只有个别的值不同（比如 query 的 where 子句值不同，update 的 set 子句值不同, insert 的 values 值不同）。如果每次都需要经过上面的词法语义解析、语句优化、制定执行计划等，则效率就明显不行了。&gt; &gt; 所谓预编译语句就是将这类语句中的值用占位符替代，可以视为将 SQL 语句模板化或者说参数化，一般称这类语句叫 Prepared Statements 或者 Parameterized Statements 预编译语句的优势在于归纳为：**一次编译、多次运行，省去了解析优化等过程**；此外**预编译语句能防止 SQL 注入**。当然就优化来说，很多时候最优的执行计划不是光靠知道 SQL 语句的模板就能决定了，往往就是需要通过具体值来预估出成本代价。 ### MySQL 如何获得最新插入的一条记录？ &gt; 通过 ```LAST_INSERT_ID()``` 获取岗插入的记录的 ID ，再用 SELECT 获取最新插入记录。### MySQL 集合操作？ &gt; (... )### char 与 varchar 的区别？ &gt; CHAR属于固定长度的字符类型，而VARCHAR属于可变长度的字符类型。 &gt; ![char 与 varchar 的区别](面经/37.png) &gt; 由于 CHAR 是固定长度的，所以它的处理速度比 VARCHAR 快得多，但是其缺点是浪费存储空间，程序需要对行尾空格进行处理，所以对于那些长度变化不大并且对查询速度有较高要求的数据可以考虑使用 CHAR 类型来存储。 &gt; 另外，随着 MySQL 版本的不断升级，VARCHAR 数据类型的性能也在不断改进并提高，所以在许多的应用中，VARCHAR 类型被更多地使用。 &gt; &gt; **MyISAM 存储引擎**：建议使用固定长度的数据列代替可变长度的数据列。&gt; **MEMORY 存储引擎**：目前都使用固定长度的数据行存储，因此无论使用 CHAR 或 VARCHAR 列都没有关系。两者都是作为 CHAR 类型处理。&gt; **InnoDB 存储引擎**：建议使用 VARCHAR 类型，对于 InnoDB 数据表，内部的行存储格式没有区别固定长度和可变长度列（所有数据行都使用指向数据列值的头指针），因此在本质上，使用固定长度的 CHAR 列不一定比使用可变长度 VARCHAR 列性能要好，因而，主要的性能因素是数据行使用的存储总量。由于 CHAR 平均占用的空间多于 VARCHAR ，因此使用 VARCHAR 来最小化需要处理的数据行的存储总量和磁盘 I/O 是比较好的。 ### 删除表的几种方式？&gt;#### DROP &gt; DROP 方法适用于完全放弃当前表，删除表全部数据和表结构，立刻释放磁盘空间，不管是 Innodb 和 MyISAM ```.DROP TABLE student; ``` &gt; #### TRUNCATE &gt; TURNCATE 适用于仅删除当前表中所有的数据，但保留表结构，删除后立刻释放磁盘空间，不管是 Innodb 和 MyISAM ```. TRUNCATE TABLE student; ``` &gt;#### DELETE / DELETE FROM &gt; DELETE 删除表中数据，但保留表结构，删除操作会被记录到 binlog 日志中，可以回滚；而且它可以与 WHERE 连用，进行条件查询删除特定行 &gt; &gt; **如果只针对一张表进行删除，则 DELETE 和 DELETE FROM 效果一样；如果需要联合其他表，则需要使用DELETE FROM**&gt; &gt; 对于 DELETE 操作，它会删除表全部数据，表结构不变，对于 MyISAM 会立刻释放磁盘空间，InnoDB 不会释放磁盘空间 ```.DELETE FROM student; ``` &gt; DELETE 操作以后，使用 ```OPTIMIZE TABLE table_name``` 会立刻释放磁盘空间，不管是 InnoDB 还是 MyISAM &gt; &gt; 对于与 WHERE 连用的 DELETE FROM 的带条件的删除，表结构不变，不管是 innodb 还是 MyISAM 都不会释放磁盘空间 ```. DELETE FROM student WHERE T_name = &quot;张三&quot;; ``` &gt; DELETE FROM 表以后虽然未释放磁盘空间，但是下次插入数据的时候，仍然可以使用这部分空间 &gt; #### TRUNCATE VS DELETE &gt; 1. **事务：**TRUNCATE 删除后不记录 binlog 日志，因此不可以回滚，更不可以恢复数据；而 DELETE 则记录 binlog，所以是可以回滚。因此 TRUNCATE 相当于保留原 MySQL 表的结果，重新创建了这个表，所有的状态都相当于新的，而 DELETE 的效果相当于一行行删除，即可以回滚&gt; 2. **效果：**效率上 TRUNCATE 比 DELETE 快，而且 TRUNCATE 删除后将重建索引（新插入数据后id从0开始记起），而 DELETE 不会删除索引 （新插入的数据将在删除数据的索引后继续增加）&gt; 3. **TRUNCATE 不会触发任何 DELETE 触发器**&gt; 4. **返回值：**DELETE 操作后返回删除的记录数，而 TRUNCATE 返回的是0或者-1（成功则返回0，失败返回-1） ### [表连接由哪几种？笛卡儿积用哪种？](https://mp.weixin.qq.com/s/vj6x_pbtq5t2pJUCcJkRQQ)### ACID 特性详解一下？ &gt; **原子性（Atomicity）**： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用。&gt; **一致性（Consistency）**： 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的。&gt; **隔离性（Isolation）**： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的。&gt; **持久性（Durability）**： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。### MySQL 并发带来的问题？&gt; **脏读（Dirty read）**：当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。&gt; &gt; **丢失修改（Lost to modify）**：指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。&gt; &gt; **不可重复读（Unrepeatableread）**：指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。&gt; &gt; **幻读（Phantom read）**：幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。### MySQL 事务 / 事务隔离级别？&gt; **READ-UNCOMMITTED(读取未提交)**： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。&gt; **READ-COMMITTED(读取已提交)**： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。&gt; **REPEATABLE-READ(可重复读)**： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。&gt; **SERIALIZABLE(可串行化)**： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。&gt; #### 如何查看事务隔离级别？&gt; ```SELECT @@tx_isolation; 12345mysql&gt; SELECT @@tx_isolation;+-----------------+| @@tx_isolation |+-----------------+| REPEATABLE-READ | 如何设置事务隔离级别？ [SESSION | GLOBAL] TRANSACTION ISOLATION LEVEL {READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE}```123 ### 查看全局/会话事务隔离级别的语句？&gt; ```SELECT @@global.tx_isolation; SELECT @@session.tx_isolation; SELECT @@tx_isolation; 并发控制语句？ TARNSACTION |BEGIN```：显式地开启一个事务；COMMIT:提交事务，使得对数据库做的所有修改成为永久性；ROLLBACK 回滚会结束用户的事务，并撤销正在进行的所有未提交的修改。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342 ### MySQL InnoDB 存储引擎的默认支持的隔离级别是？为什么默认是这个隔离级别？&gt; REPEATABLE-READ（可重读）。与 SQL 标准不同的地方在于InnoDB 存储引擎在 REPEATABLE-READ（可重读）事务隔离级别下使用的是 Next-Key Lock 锁(间隙锁)算法，因此可以避免幻读的产生。所以说 InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读） 已经可以完全保证事务的隔离性要求，即达到了 SQL标准的 SERIALIZABLE (可串行化)隔离级别。 ### MySQL InnoDB 存储引擎何时用得到 SERIALIZABLE (可串行化)隔离级别？&gt; 分布式事务的情况下### MySQL更新数据库时异常重启的处理过程？&gt; 判断 redo log 是否完整，如果判断是完整的，就立即提交。如果 redo log 只是预提交但不是 commit 状态，这个时候就会去判断 binlog 是否完整，如果完整就提交 redo log, 不完整就回滚事务。 ### MySQL 范式？### MySQL 优化?&gt; 1. 避免在 where 子句上进行 null 值判断 &gt; 2. 慎用 in 与 not in 能用 between 就不要用in &gt; 3. 避免在 where 字句对 = 左边进行表达式或函数操作 &gt; 4. 组合索引情况下，必须使用到索引的第一个字段才能使索引生效，并且尽可能使字段顺序与索引顺序一致 &gt; 5. 要注意索引并不是越多越好，索引可以提高查询效率但是会降低更改表的效率，并且也会占用存储空间，所以要视情况而定 &gt; 6. 可以使用 explain 语句来解析sql方便制定优化方案 ### MySQL 引擎？&gt; (...)### MySQL 分库分表？&gt; (...)### MySQL 索引？&gt; **normal**：表示普通索引。&gt; **unique**：表示唯一的，不允许重复的索引，可以有 null 值，如果该字段信息保证不会重复例如身份证号用作索引时，可设置为 unique，一个表可以有多个唯一索引。&gt; **full text**：表示 全文搜索的索引。 FULLTEXT 用于搜索很长一篇文章的时候，效果最好。用在比较短的文本，如果就一两行字的，普通的 INDEX 也可以。&gt; **union**：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并。&gt; &gt; 总结，索引的类别由建立索引的字段内容特性来决定，通常 normal 最常见。&gt; #### 唯一索引和主键的区别&gt; **唯一索引**：一个表中可以有多个唯一索引，索引中可以存在 null 值。&gt; **主键索引**：一种特殊的唯一索引，一个表中只能有一个主键索引，索引值不可以为 null 。 ### MySQL 如何查看是否创建索引？&gt; 1. ```EXPLAIN``` 关键字查看 type 字段，如果是 ALL 则没有索引。&gt; 2. ```SHOW INDEX FROM table_name``` 。 ### 如何检测 MySQL 中建立的索引是否生效？&gt; ```EXPLAIN``` 关键字查看 type 字段：这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为 const、eq_reg、ref、range、index 和 ALL。&gt; &gt; **const**：表中的一个记录的最大值能够匹配这个查询（索引可以是主键或惟一索引）。因为只有一行，这个值实际就是常数，因为 MySQL 先读这个值然后把它当做常数来对待。&gt; &gt; **eq_ref**：在连接中，MySQL在查询时，从前面的表中，对每一个记录的联合都从表中读取一个记录，它在查询使用了索引为主键或惟一键的全部时使用。&gt; &gt; **ref**：这个连接类型只有在查询使用了不是惟一或主键的键或者是这些类型的部分（比如，利用最左边前缀）时发生。对于之前的表的每一个行联合，全部记录都将从表中读出。这个类型严重依赖于根据索引匹配的记录多少—越少越好。&gt; &gt; **range**：这个连接类型使用索引返回一个范围中的行，比如使用&gt;或&lt;查找东西时发生的情况。&gt; &gt; **index**：这个连接类型对前面的表中的每一个记录联合进行完全扫描（比 ALL 更好，因为索引一般小于表数据）。&gt; &gt; **ALL**：这个连接类型对于前面的每一个记录联合进行完全扫描，这一般比较糟糕，应该尽量避免。### 索引是不是越多越好？&gt; 不是。索引本身也会占用一定的内存空间，过多的索引会占用过多的内存空间，影响 MySQL 的性能。数据量小的表不需要建立索引，因为建立索引会增加额外的开销。数据变更需要维护索引，因此更多的索引意味着更多的维护成本。 ### 触发器和存储过程区别？&gt; (...)### 处理大数据？&gt; 分库分表、缓存…… ### MVCC 实现原理？### MVCC 如何”加锁”？### 什么是一致性 hash？### 介绍一下负载均衡？### 如何保证缓存与数据库的数据一致性？### 知道 MySQL 插入和查询分别用的是什么锁吗？### 数据库中键的数据结构是？### MySQL 取唯一值（类似随机数）？### MySQL 查询关键字 in 、exist什么时候使用，怎么使用？### 数据库中一条记录中一个字段，多个线程对它修改，如何不加锁保证只有一个线程修改成功？### MySQL 的容错性、主从分离的详细种类### 数据库表中有三列 A、B、C，假设 A 的取值有1000种，B的取值有500种，C 的取值有100种，现在考虑 ABC 上建联合索引，问 SQL 中 ABC 的顺序应该怎么排？### 给你一个联合索引 ABC，查询条件为 A=1,B&gt;2,C=3，问你这个索引有没有被用到？### 有一张成绩表，写个 SQL 分别统计分数段在 0-10,10-20,20-30...90-100 的人数？# MyBatis # Redis ### 分布式锁有了解嘛？ # Nginx # ZooKeeper # Java工具 # 计算机网络 ### OSI分层作用? &gt; (...) ### 世界上有那么多主机，但IP有限，那么是如何解决的？ &gt; (...) ### 说一下IP分类? &gt; (...) ### 说一下IP子网划分? &gt; (...) ### 说一下IP子网聚合? &gt; (...) ### 路由器作用 &gt; (...) ### 网络层的路由算法有哪些，简述RIP，OSPF过程 &gt; (...) ### 简述ARP协议过程，是如何通过IP地址获取MAC地址的 &gt; (...) ### ping命令所使用的协议是什么（ICMP），简述其过程 &gt; (...) ### ICMP处于哪一层 &gt; (...) ### 介绍一下NAT? &gt; (...) ### 介绍一下DNS？ &gt; DNS是一个**分布式的客户机/服务器网络数据库**，用于实现IP地址与主机名称之间的映射（反之亦然）。之所以称之为分布式的，是因为互联网中不存在单独一个站点知道所用映射信息。 &gt; 从应用程序的角度来看，DNS是通过一个**域名解析器**的应用程序库来实现IP地址与主机名之间的映射操作的。 &gt; **DNS名称是分层的**（划分的层次通过句点“.”分割，大小写不敏感），因此可以实现拓展性。从左往右代表从根标签到子域名标签，每个标签最多可达63个字符长。DNS的分层结构说明没有一个单一的实体需要管理整个DNS名称空间的变化。 &gt; 名称服务器（DNS服务器）包含的映射信息至少存在两台服务器上，它们拥有完全一样的信息。一台成为**主服务器**，它的磁盘文件中包含区域数据库；其余的一台或多台服务器称为**辅助服务器**，它们使用区域传输进程，从主服务器中完整地获取其数据库中的映射信息副本。 &gt; 名称服务器中包含的IP映射信息，可以从三个渠道获取： &gt; 1. 直接来自主服务器的区域数据库（该服务器包含该区域的**授权信息**，因此该服务器亦可称为**授权服务器**）&gt; 2. 来自区域传输的结果（如一个从属/辅助服务器）&gt; 3. 来自处理解析过程的另一台服务器 ### 介绍一下DNS缓存？ &gt; 大部分名称服务器（DNS服务器）缓存它们学习的区域信息，直到称为生存时间（TTL）的时间限制为止。其中，TTL不宜过大，以减少网络中存在不正确缓存数据的窗口，提高缓存准确性。 &gt; 缓存同时使用于成功的解析和不成功的解析（否定解析）。缓存否定解析可以在出错的应用程序一再请求不存在的域名时降低网络流量。 ### 介绍一下DNS解析过程？ &gt; 1. 本地应用程序首先查询本地客户端域名解析器的缓存，如果不存在目标IP，则向本地客户端域名解析器申请域名解析。&gt; 2. 如果本地客户端解析器不知道解析地址的IP，则**递归地**向本地ISP提供的DNS服务器申请解析地址。同样，ISP提供的DNS服务器也会先查询DNS缓存，如果找到，则返回结果；若无法解析，则会再次**递归地**向上一级DNS域名服务器请求解析，直到根服务器。&gt; 3. 如果到达了根域名服务器，根服务器不回进一步处理处理请求，而是**迭代地**向下一级域名服务器返回需要联系的下一台根域名服务器的一个或多个IP地址。&gt; 4. 根据上一步提供的信息，该级服务器会向对应的根服务器**迭代地**请求解析，直到拿到解析成功或失败。并将解析结果进行缓存，然后**递归地**将解析结果按照上面的路径返回给客户端的对应的应用程序。返回过程中，各级服务器会对解析结果进行缓存。 ![DNS解析过程](面经/1.png) ### 介绍一下TCP三次握手、四次挥手？#### 正常开启、关闭![TCP三次握手、四次挥手1](面经/2.png) #### 同时开启、关闭![TCP三次握手、四次挥手2](面经/3.png) #### TCP状态转换图![TCP状态转换图](面经/4.png) #### TIME_WAIT（2MSL）&gt; TIME_WAIT状态时，TCP将会等待2倍于最大生存期（MSL）的时间，它代表任何报文在丢弃前在网络中允许的最大存在时间。这个2MSL时间能够让TCP重新发送最终的ACK以避免丢失的情况。**重新发送最终的ACK并不是重新发送了最后的那个ACK，而是通信的另一方重新发送了它的FIN。**事实上，TCP总是重传FIN知道它收到一个ACK。 ### TCP拥塞控制 &gt; (...) ### TCP滑动窗口 &gt; (...) ### TCP为什么传输安全 &gt; (...) ### HTTP 头结构？ &gt; 第一行：请求/响应行&gt; 第二行开始：头部字段&gt; HTTP报文头与主体之间通过空一行进行分隔 ![HTTP请求报文](面经/5.png) ![HTTP响应报文](面经/6.png) ### 讲一下HTTP协议栈 &gt; 网络层：IP&gt; 传输层：TCP&gt; 会话层：TSL/SSL、SPDY、WebSocket&gt; 应用层：HTTP、DNS ![HTTP协议栈1](面经/7.png) ![HTTP协议栈2](面经/8.png) ![HTTP协议栈3](面经/9.png) ### 介绍一下 HTTP：keep-alive？&gt; 在 HTTP/1.1 版本的默认连接是持久连接的（默认开启```Connection： keep-alive```），因此客户端会在持久连接上连续发送请求。当服务器想断开链接时，需要指定```Connection : close```。 &gt; 在 HTTP/1.1 之前的版本默认连接时非持久的，因此若想在旧版本的 HTTP 协议上维持持久连接，需要指定```Connection : keep-alive```。 ### 介绍一下长连接和短连接？&gt; **长连接**：指在一个 TCP 连接上可以连续发送多个数据包，在 TCP 连接保持期间，如果没有数据包发送，需要双方发检测包以维持此连接，一般需要自己做在线维持。在 HTTP 层上，长连接需要```Connection : keep-alive```。&gt; &gt; **短连接**：是指通信双方有数据交互时，就建立一个 TCP 连接，数据发送完成后，则断开此TCP连接，一般银行都使用短连接。 ### HTTP/1.0、HTTP/1.1、HTTP/1.x、HTTP/2.0，有什么区别及其改进? &gt;#### 影响HTTP 网络请求的因素&gt; 影响一个 HTTP 网络请求的因素主要有两个：**带宽**和**延迟**。 &gt; **带宽**：影响网速，在当前网络基础设施的建设上，带宽的影响明显降低。 &gt; **延迟**：&gt; &gt; 1. **浏览器阻塞（HOL blocking）**：浏览器会因为一些原因阻塞请求。浏览器对于同一个域名，同时只能有 4 个连接（这个根据浏览器内核不同可能会有所差异），超过浏览器最大连接数限制，后续请求就会被阻塞。&gt; 2. **DNS 查询（DNS Lookup）**：浏览器需要知道目标服务器的 IP 才能建立连接。将域名解析为 IP 的这个系统就是 DNS。这个通常可以利用DNS缓存结果来达到减少这个时间的目的。&gt; 3. **建立连接（Initial connection）**：HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能捎带 HTTP 请求报文，达到真正的建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。&gt; #### HTTP/1.0和HTTP/1.1的一些区别 &gt; 1. **缓存处理**：在HTTP1.0中主要使用header里的If-Modified-Since、Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。&gt; 2. **带宽优化及网络连接的使用**：HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。&gt; 3. **错误通知的管理**：在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。&gt; 4. **Host头处理**：在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。**HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）**。&gt; 5. **长连接**：HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。 &gt; #### HTTP/1.x + SPDY&gt; SPDY优化了HTTP1.X的请求延迟，解决了HTTP1.X的安全性，具体如下： &gt; &gt; 1. **降低延迟**：针对HTTP高延迟的问题，SPDY采取了**多路复用（multiplexing）**。多路复用通过多个请求stream共享一个（单个域名/IP地址）TCP连接的方式，解决了HOL blocking的问题，降低了延迟同时提高了带宽的利用率。&gt; 2. **请求优先级（request prioritization）**：多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。SPDY允许给每个request设置优先级，这样重要的请求就会优先得到响应。比如浏览器加载首页，首页的html内容应该优先展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能第一时间看到网页内容。&gt; 3. **header压缩**：HTTP/1.x的header很多时候都是重复多余的。选择合适的压缩算法可以减小包的大小和数量。&gt; 4. **基于HTTPS的加密协议传输**：大大提高了传输数据的可靠性。&gt; 5. **服务端推送（server push）**：采用了SPDY的网页，例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了。 &gt; &gt; SPDY（会话层）位于HTTP之下，TCP和SSL之上，这样可以轻松兼容老版本的HTTP协议(将HTTP1.x的内容封装成一种新的frame格式)，同时可以使用已有的SSL功能。 ![SPDY](面经/10.png)&gt; #### HTTP/2.0 VS SPDY&gt; HTTP/2.0可以说是SPDY的升级版（其实原本也是基于SPDY设计的），但是，HTTP/2.0 跟 SPDY 仍有不同的地方，如下：&gt; &gt; 1. HTTP/2.0 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS&gt; 2. HTTP/2.0 消息头的压缩算法采用 HPACK，而非 SPDY 采用的 DEFLATE&gt;#### HTTP/2.0 VS HTTP1.X相比的新特性 &gt; 1. **新的二进制格式（Binary Format），HTTP/1.x的解析是基于文本**：基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP/2.0的协议解析决定采用二进制格式，实现方便且健壮。&gt; 2. **多路复用（MultiPlexing）**：即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。&gt; 3. **header压缩**：如上文中所言，对前面提到过HTTP/1.x的header带有大量信息，而且每次都要重复发送，HTTP/2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。&gt; 4. **服务端推送（server push）**：同SPDY一样，HTTP/2.0也具有server push功能。 ### HTTPS与HTTP区别？ &gt; #### HTTP缺点 &gt; 1. 使用明文通信（不加密），内容可能被窃听&gt; 2. 不验证对方身份，有可能遭遇伪装&gt; 3. 无法验证报文的完整性，所以有可能遭到篡改 &gt;#### HTTPS（HTTP Secure） &gt; **HTTPS = HTTP + 加密 + 认证 + 完整性保护** &gt; &gt; **加密**：HTTP通信接口部分用SSL和TSL协议代替&gt; **认证**：SSL协议提供对方证书认证手段&gt; **完整性保护**：MD5、SHA-1等散列值方法、PGP验证SSL提供数字签名 ### 对称加密和非对称加密的区别？ &gt; **对称加密（共享密钥加密）**：加密和解密都使用同一个密钥。但如何将密钥安全地送至对方存在问题。由于简单效率较高，但不安全。&gt; **非对称加密（公开密钥加密）**：使用一对密钥：一把公开的公钥，一把私有的私钥。报文发送方使用**对方**公开的密钥对报文进行加密后发送，报文接收方使用私钥对报文进行解密。要想通过密文和公钥进行解密是几乎不可能的，因为解密过程就是在离散对数中进行求值。由于过程复杂，效率不高 ### HTTPS如何加密通信、认证？ &gt; 由于非对称加密的效率比对称加密的效率低得多，因此，HTTPS采用混合加密方式：用非对称加密方式对密钥进行加密进行传输，传输完成后，密文部分通过对称加密的方式进行传输。具体步骤为：&gt; &gt; 1. 开始时，**服务器**会把自己的**公钥**登录到数字证书认证机构上。而客户端在安装浏览器的时候，一般也会集成有**数字认证机构**的**公钥**。 &gt; 2. **数字认证机构**认证机构用**私钥**对**服务器**的**公钥**进行数字签名，并向服务器颁发**公钥证书（服务器公钥+数字签名）**。&gt; 3. 服务器向客户端发送自己的公钥证书后，客户端用**数字认证机构**集成的**公钥**验证数字签名，以确定服务器的真实性。&gt; 4. 客户端使用**服务器**的**公钥**对密文进行加密后向客户端进行传输。 &gt; 5. 服务器收到客户端发送的密文后用**自己的私钥**解密密文。 ![HTTPS如何加密通信、认证](面经/11.png) ### 简述HTTPS传输过程？&gt; 1. 客户端发送ClientHello报文开始SSL通信。报文中包含客户端支持的指定SSL版本、加密组件列表等。&gt; 2. 服务器接收到ClientHello后以ServerHello报文开始SSL通信。报文中包含服务端支持的指定SSL版本和从客户端提供的加密列表中筛选出来的加密组件（子）列表。&gt; 3. 服务器再发送Certificate报文，里面包含公钥证书。&gt; 4. 服务器最后发送ServerHelloDone报文，表明最初阶段SSL协商完成。&gt; 5. 客户端收到ServerHelloDone报文后，发送利用步骤3的公钥证书中的公钥加密后的ClientKeyExchange报文进行回应。里面包含用Pre-master Secret的随机码。&gt; 6. 客户端发送ChangeCipherSpec报文以提示服务器后面用Pre-master Secret密钥进行加密通信。&gt; 7. 客户端发送Finish报文，该报文包含至今所有报文的整体校验值。本次握手连接成功与否，要看服务器能否正确解密该报文作为评判标准。&gt; 8. 服务器收到Finish报文后也发送ChangeCipherSpec报文。&gt; 9. 服务器也发送Finish报文。&gt; 10. 服务器和客户端的Finish报文交换完毕后，SSL连接建立完成。此时通信会受到SSL保护，开始进行应用层HTTP协议通信。&gt; 11. 进行应用层HTTP协议通信。&gt; 12. 最后由客户端断开连接。断开连接时，发送close_notify报文。&gt; 13. 之后会发送TCP的FIN报文来关闭TCP通信。 ![HTTPS传输过程](面经/12.png) ### 介绍一下HTTP方法？ &gt; 注意HTTP方法大小写敏感，要用大写！ ![HTTP方法](面经/13.png) ### 解释一下HTTP状态码？&gt; 仅列举部分常问状态码： &gt; **302**：Found 临时性重定向：表示请求资源已经有新的URI了（但不是永久变化，可能后面还会变），希望用户（本次）能使用新的URI访问资源。E.g. 用户把URI保存成书签。 &gt; **304**：Not Modified 没有更新：表示客户端发送附带条件请求（指客户端采用GET方法发送的请求报文中包含If-Match、If-Modified-Since、If-None-Match、If-Range、If-Unmodified-Since中任一首部）时，服务器允许访问资源，但未满足条件的情况。该状态码返回时不包含响应主体部分。 &gt; **403**：Forbidden 服务器拒绝访问：该状态表示服务器理解了本次请求但是拒绝执行该任务，该请求不该重发给服务器。可能是客户端未获得授权等情况。 &gt; **404**：Not Found 未找到资源：表示服务器上无法找到请求的资源。也可以在服务器拒绝访问时不想给出任何理由时使用。 ### 当访问一个web应用，出现403错误，怎么排查可能出现的原因 &gt;#### 403状态码分类 &gt; **403.1**：错误是由于&quot;执行&quot;访问被禁止而造成的，若试图从目录中执行CGI、ISAPI或其他可执行程序，但该目录不允许执行程序时便会出现此种错误。 &gt; **403.2**：错误是由于&quot;读取&quot;访问被禁止而造成的。导致此错误是由于没有可用的默认网页并且没有对目录启用目录浏览，或者要显示的HTML网页所驻留的目录仅标记为&quot;可执行&quot;或&quot;脚本&quot;权限。 &gt; **403.3**：错误是由于&quot;写入&quot;访问被禁止而造成的，当试图将文件上载到目录或在目录中修改文件，但该目录不允许&quot;写&quot;访问时就会出现此种错误。 &gt; **403.4**：错误是由于要求SSL而造成的，您必须在要查看的网页的地址中使用&quot;https&quot;。 &gt; **403.5**：错误是由于要求使用128位加密算法的Web浏览器而造成的，如果您的浏览器不支持128位加密算法就会出现这个错误，您可以连接微软网站进行浏览器升级。 &gt; **403.6**：错误是由于IP地址被拒绝而造成的。如果服务器中有不能访问该站点的IP地址列表，并且您使用的IP地址在该列表中时您就会返回这条错误信息。 &gt; **403.7**：错误是因为要求客户证书，当需要访问的资源要求浏览器拥有服务器能够识别的安全套接字层(SSL) 客户证书时会返回此种错误。 &gt; **403.8**：错误是由于禁止站点访问而造成的，若服务器中有不能访问该站点的DNS名称列表，而您使用的DNS名称在列表中时就会返回此种信息。请注意区别403.6与403.8错误。 &gt; **403.9**：错误是由于连接的用户过多而造成的，由于Web服务器很忙，因通讯量过多而无法处理请求时便会返回这条错误。 &gt; **403.10**：错误是由于无效配置而导致的错误，当您试图从目录中执行CGI、ISAPI或其他可执行程序，但该目录不允许执行程序时便会返回这条错误。 &gt; **403.11**：错误是由于密码更改而导致无权查看页面。 &gt; **403.12**：错误是由于映射器拒绝访问而造成的。若要查看的网页要求使用有效的客户证书，而您的客户证书映射没有权限访问该Web站点时就会返回映射器拒绝访问的错误。 &gt; **403.13**：错误是由于需要查看的网页要求使用有效的客户证书而使用的客户证书已经被吊销，或者无法确定证书是否已吊销造成的。 &gt; **403.14**：错误Web 服务器被配置为不列出此目录的内容，拒绝目录列表。 &gt; **403.15**：错误是由于客户访问许可过多而造成的，当服务器超出其客户访问许可限制时会返回此条错误。 &gt; **403.16**：错误是由于客户证书不可信或者无效而造成的。 &gt; **403.17**：错误是由于客户证书已经到期或者尚未生效而造成的。 &gt;#### 导致403错误的主要原因 &gt; 1. 你的IP被列入黑名单。&gt; 2. 你在一定时间内过多地访问此网站（一般是用采集程序），被防火墙拒绝访问了。&gt; 3. 网站域名解析到了空间，但空间未绑定此域名。&gt; 4. 你的网页脚本文件在当前目录下没有执行权限。&gt; 5. 在不允许写/创建文件的目录中执行了创建/写文件操作。&gt; 6. 以http方式访问需要ssl连接的网址。&gt; 7. 浏览器不支持SSL 128时访问SSL 128的连接。&gt; 8. 在身份验证的过程中输入了错误的密码。&gt; 9. DNS解析错误，手动更改DNS服务器地址。&gt; 10. 连接的用户过多，可以过后再试。&gt; 11. 服务器繁忙，同一IP地址发送请求过多，遭到服务器智能屏蔽&gt;#### 403解决方法 &gt; 1、**重建dns缓存**：&gt; 对于一些常规的403 forbidden错误，首先尝试重建DNS缓存，在运行中输入cmd，然后输入ipconfig /flushdns即可。如果不行的话，就需要在hosts文件里把主页解析一下了。 &gt; 同时，查看是否在网站虚拟目录中添加默认文档，一般默认文档为：index.html；index.asp；index.php；index.jsp；default.htm；default.asp等。 &gt; &gt; 2、**修改文件夹安全属性**：&gt; 用以下命令修改文件夹安全属性：&gt; ```chcon -R -t httpd_user_content_t 所用命令解析： 123456789101112131415161718ls -Z -d public_html/＃显示文件／目录的安全语境－Z, --contextDisplay security context so it fits on most displays. Displays only mode, user, group, security context and file name.-d, --directorylist directory entries instead of contents, and do not dereference symbolic linkschcon -R -t httpd_user_content_t public_html/＃修改文件／目录的安全语境-R, --recursivechange files and directories recursively-t, --typeset type TYPE in the target security context``` &gt; 3、**关于apache导致的403错误的解决办法**:&gt; 打开apache的配置文件httpd.conf，找到这段代码： ```.Options FollowSymLinks AllowOverride None Order deny,allrw Deny from all 有时候由于配置了php后，这里的“Deny from all”已经拒绝了一切连接。把该行改成“allow from all”，修改后的代码如下，问题解决。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051Options FollowSymLinksAllowOverride NoneOrder deny,allowAllow from all``` &gt; 之所以会出现错误，是因为大多数的国外主机在配置Apache的时候启用了mod_security，也就是开启了安全检查，如果提交的信息中包含select , % , bin等关键字，Apache就会禁止，并给出403，404，500等错误。&gt; 4、**关于HawkHost空间出现403错误的解决方法**：&gt; 有的时候在共享服务器上安装了Mod security，当网址包含有“%”号等其它敏感字符时，就会被Mod security阻止。&gt; 解决HawkHost 403 Forbidden 错误的方法： &gt; 在.htaccess文件里添加如下代码： ```.SecFilterEngine OffSecFilterScanPOST Off``` &gt; 直接放在网站的根目录或者程序运行的目录下。&gt; 5、**关于WordPress导致的403错误解决方法**：&gt; 对于一些使用WordPress管理程序搭建的博客来说，就需要修改.htaccess文件，在后面添加上如下内容即可，其实就是disable mod_security ```.SecFilterEngine OffSecFilterScanPOST Off``` &gt; 另外dedecms的可能还需要再加一条，以让默认访问的是index.html文件的DirectoryIndex index.html。 &gt; 修改.htaccess文件，将文件上传之后，再重新打开之前出现403 Forbidden的URL就没有再出现错误，直接可以打开了。 ### 输入网址后发生的全过程 &gt; (...) ### hosts文件 &gt; 其作用就是将一些常用的网址域名与其对应的IP地址建立一个关联“数据库”，当用户在浏览器中输入一个需要登录的网址时，系统会首先自动从Hosts文件中寻找对应的IP地址，一旦找到，系统会立即打开对应网页，如果没有找到，则系统会再将网址提交DNS域名解析服务器进行IP地址的解析。也就是说Hosts的IP解析优先级比DNS要高。 &gt; &gt; hosts文件作用： &gt; &gt; 1、**加快域名解析**&gt; 对于要经常访问的网站，我们可以通过在Hosts中配置域名和IP的映射关系，提高域名解析速度。由于有了映射关系，当我们输入域名计算机就能很快解析出IP，而不用请求网络上的DNS服务器。&gt; 2、**方便局域网用户**&gt; 在很多单位的局域网中，会有服务器提供给用户使用。但由于局域网中一般很少架设DNS服务器，访问这些服务器时，要输入难记的IP地址。这对不少人来说相当麻烦。可以分别给这些服务器取个容易记住的名字，然后在Hosts中建立IP映射，这样以后访问的时候，只要输入这个服务器的名字就行了。&gt; 3、**屏蔽网站（域名重定向）**&gt; 有很多网站不经过用户同意就将各种各样的插件安装到你的计算机中，其中有些说不定就是木马或病毒。对于这些网站我们可以利用Hosts把该网站的域名映射到错误的IP或本地计算机的IP，这样就不用访问了。在WINDOWS系统中，约定 127.0.0.1 为本地计算机的IP地址, 0.0.0.0是错误的IP地址。 &gt; 如果，我们在Hosts中，写入以下内容： ```.127.0.0.1要屏蔽的网站A的域名0.0.0.0要屏蔽的网站B的域名 这样，计算机解析域名A和 B时，就解析到本机IP或错误的IP，达到了屏蔽网站A 和B的目的。4、顺利连接系统对于Lotus的服务器和一些数据库服务器，在访问时如果直接输入IP地址那是不能访问的，只能输入服务器名才能访问。那么我们配置好Hosts文件，这样输入服务器名就能顺利连接了。5、虚拟域名很多时候，网站建设者需要把”软环境“搭建好，再进行上传调试。但类似于邮件服务，则需要使用域名来辅助调试，这时就可以将本地 IP 地址与一个”虚拟域名“做地址指向，就可以达到要求的效果，且无需花费。如： 127.0.0.1 网站域名 之后在浏览器地址栏中输入对应的网站域名即可。 Cookie &amp; Session cookie：位于客户端上，用来维护用户计算机中的信息，直到用户删除。比如我们在网页上登录某个软件时输入用户名及密码时如果保存为cookie，则每次我们访问的时候就不需要登录网站了。我们可以在浏览器上保存任何文本，而且我们还可以随时随地的去阻止它或者删除。我们同样也可以禁用或者编辑cookie，但是有一点需要注意不要使用cookie来存储一些隐私数据，以防隐私泄露。session：称为会话信息，位于web服务器上，主要负责访问者与网站之间的交互，当访问浏览器请求http地址时，将传递到web服务器上并与访问信息进行匹配， 当关闭网站时就表示会话已经结束，网站无法访问该信息了，所以它无法保存永久数据，我们无法访问以及禁用网站。 区别： cookie以文本文件格式存储在客户端浏览器中，而session存储在服务端。 cookie的存储限制了数据量，只允许4KB，而session是无限量的。 我们可以轻松访问cookie值但是我们无法轻松访问session值，因此它更安全。 设置cookie时间可以使cookie过期。但是使用session-destory（），我们将会销毁会话。 WebSocketWebSocket即Web浏览器与Web服务器之间的全双工通信标准。 WebSocket特点 支持推送功能：服务端可以主动向客户端推送消息而不用等客户端请求。 减少通信量：WebSocket首部信息很小，通信量小。 WebSoket过程 RPC (…) Linux操作如何查看网络节点状态？ netstat -a -n -t-a：输出所有网络节点，包括处于或者未处于侦听状态的节点-n：按照点分十进制（或者十六进制）的形式打印IP地址-t：只选择TCP节点 操作系统设计模式软件工程数据结构算法大规模数据处理智力题","link":"/2019/09/05/面经/"}],"tags":[{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Game","slug":"Game","link":"/tags/Game/"},{"name":"Design Patterns","slug":"Design-Patterns","link":"/tags/Design-Patterns/"},{"name":"面试","slug":"面试","link":"/tags/面试/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"Numeric Types","slug":"Numeric-Types","link":"/tags/Numeric-Types/"},{"name":"Computer Networking","slug":"Computer-Networking","link":"/tags/Computer-Networking/"},{"name":"Dynamic_Programming","slug":"Dynamic-Programming","link":"/tags/Dynamic-Programming/"},{"name":"线程池","slug":"线程池","link":"/tags/线程池/"},{"name":"Sort","slug":"Sort","link":"/tags/Sort/"}],"categories":[{"name":"Android","slug":"Android","link":"/categories/Android/"},{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"},{"name":"Design Patterns","slug":"Design-Patterns","link":"/categories/Design-Patterns/"},{"name":"Creative","slug":"Design-Patterns/Creative","link":"/categories/Design-Patterns/Creative/"},{"name":"Constructive","slug":"Design-Patterns/Constructive","link":"/categories/Design-Patterns/Constructive/"},{"name":"Behavioral","slug":"Design-Patterns/Behavioral","link":"/categories/Design-Patterns/Behavioral/"},{"name":"面试","slug":"面试","link":"/categories/面试/"},{"name":"MySQL基础","slug":"MySQL基础","link":"/categories/MySQL基础/"},{"name":"hexo","slug":"hexo","link":"/categories/hexo/"},{"name":"Computer Networking","slug":"Computer-Networking","link":"/categories/Computer-Networking/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"四大组件","slug":"Android/四大组件","link":"/categories/Android/四大组件/"}]}